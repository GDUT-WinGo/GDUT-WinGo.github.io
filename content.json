{"meta":{"title":"Wingo's Blog","subtitle":"","description":"","author":"Wingo","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-04-19T06:45:50.304Z","updated":"2020-01-20T15:06:03.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-04-19T06:45:50.304Z","updated":"2020-01-20T15:05:42.000Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Dubbo 初步使用","slug":"Software/Dubbo 初步使用","date":"2020-04-17T01:50:34.000Z","updated":"2020-04-19T06:40:55.273Z","comments":true,"path":"2020/04/17/Software/Dubbo 初步使用/","link":"","permalink":"http://yoursite.com/2020/04/17/Software/Dubbo%20%E5%88%9D%E6%AD%A5%E4%BD%BF%E7%94%A8/","excerpt":"Dubbo + Zookeeper 的简单介绍，以及整合使用。","text":"Dubbo + Zookeeper 的简单介绍，以及整合使用。 基础理论应用的发展与演变： 当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架（ORM）是关键； 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的 Web 框架（MVC）是关键； 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架（RPC）是关键； Dubbo 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心（SOA）即 Service Oriented Architecture 是关键。 环境搭建Javayum search java-1.8 ！！！注意，需要下载两个 java-1.8.0-openjdk.x86_64 / java-1.8.0-openjdk-devel.x86_64 yum install ... whereis java查看 java 路径（/usr/lib/jvm/） 修改环境变量：vim /etc/profile 123export JAVA_HOME&#x3D;&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;java-1.8.0-openjdk-...export PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar javac环境变量是否配置正确 Zookeeper下载 zookeeper ：清华大学开源软件镜像站 wget [下载连接]下载压缩包 tar -zxvf zookeeper-x.x.x.tar.gz 在 /usr/local/ 下新建 zookeeper 目录进行解压 修改 zookeeper 配置文件名：zoo_sample.cfg 改为 zoo.cfg 配置环境变量：vi ~/.bash_profile 123export PATHexport ZOOKEEPER_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;zookeeper&#x2F;zookeeper-3.4.11&#x2F;export PATH&#x3D;$ZOOKEEPER_HOME&#x2F;bin:$PATH 常用操作 123zkServer.sh start # 开启 zookeeperjps # 显示当前所有 java 进程 pidzkServer.sh stop # 停止 zookeeper dubbo-admin netstat -aon|findstr “port-num” 查看占用端口的程序的 PID Dubbo 官方项目下载 修改 dubbo-admin 项目的配置（！！！zookeeper 的地址修改为自己配置的地址） 在 pom.xml 目录下：cmd 输入命令mvn clean package对项目进行打包 打包成功后生成 target 文件夹，target 目录下有一个可执行 jar 包 java -jar [jara_name]运行项目，运行成功后根据配置的路径进行访问 dubbo-monitor生成的 target 文件中有一个压缩包，解压后的 assembly.bin 目录中运行 start.bat 脚本进行项目运行 项目架构先来看一张官网给的架构图： 节点 角色说明 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 各节点间的调用关系说明： ​ 服务容器负责启动，加载，运行服务提供者。​ 服务提供者在启动时，向注册中心注册自己提供的服务。​ 服务消费者在启动时，向注册中心订阅自己所需的服务。​ 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。​ 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。​ 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 项目创建基于对官网给出的架构分析得知我们需要两个角色：服务的提供者；服务的消费者。 消费者在自身的项目中可以如同调用本地方法一般调用提供者的方法；那么消费者和提供者必须都受到同一套接口的规范，在两个项目中都编写接口显得有些繁琐，所以可以新建一个 Maven 项目专门用于定义接口。 最外层套一层壳，添加三个 module，其中外壳项目和提供接口的项目为 Maven 项目即可。 dubbo-api 此项目用于提供接口规范，不需要添加任何依赖。编写一个实体类和一个服务类接口即可。 1234567891011public class User implements Serializable &#123; private static final long serialVersionUID = 5433406871746033298L; private Integer userId; private String username; private String password; // ...&#125; 定义接口。 123456789public interface UserService &#123; /** * 获取用户列表的方法 * * @return 用户的信息列表 */ List&lt;User&gt; getUserList();&#125; 要让 dubbo-consumer 以及 dubbo-provider 获取此接口，需要给这两个项目添加 dubbo-api 项目的依赖。 123456&lt;!-- 添加自定义接口依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.wingo&lt;/groupId&gt; &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; dubbo-provider 服务提供者编写了接口的具体实现方法，并且要把实现的方法通过 Dubbo 暴露出去。 123456&lt;!-- 添加 Dubbo 依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba.boot&lt;/groupId&gt; &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;0.2.0&lt;/version&gt;&lt;/dependency&gt; Spring 以及 Dubbo 都要管理这个类。 12345678910@com.alibaba.dubbo.config.annotation.Service@Servicepublic class UserServiceImpl implements UserService &#123; @Override public List&lt;User&gt; getUserList() &#123; User user1 = new User(1,\"wingo\",\"123456\"); User user2 = new User(2,\"admin\",\"654321\"); return Arrays.asList(user1, user2); &#125;&#125; 在主类上标注 @EnableDubbo(scanBasePackages = “com.wingo.dubboprovider.service”)，并添加配置。 12345678910# 此服务的名称dubbo.application.name=user-service-provider# 注册中心的协议及地址dubbo.registry.address=127.0.0.1:2181dubbo.registry.protocol=zookeeper# 暴露的协议及端口dubbo.protocol.name=dubbodubbo.protocol.port=20881## 注册中心获取监控中心的信息dubbo.monitor.protocol=registry 启动项目，来到 dubbo-admin 的页面查看服务。 在 dubbo-admin 多了一个我们刚刚暴露出来的服务，由名称可以得知其暴露的是一个接口。 点击查看其对应的 IP 地址以及域名，正是本机的 IP 以及自定义的接口 20881 dubbo-monitor 中可以看到这个应用的名称正是配置文件中的 user-service-provider dubbo-consumer 消费者向 dubbo 请求所需要的服务。 1234567891011@RestControllerpublic class UserController &#123; @Reference UserService userService; @GetMapping(\"/users\") public List&lt;User&gt; userList ()&#123; return userService.getUserList(); &#125;&#125; 12345server.port=8082dubbo.application.name=dubbo-user-consumerdubbo.registry.address=zookeeper://127.0.0.1:2181dubbo.monitor.protocol=registry 启动消费者。 可以看出，提供者与消费者确实是通过接口通讯的。 成功请求数据。 Dubbo 特性 介绍一些 Dubbo 的使用特性。 高可用Zookeeper 宕机与 Dubbo 直连：注册中心全部宕掉后，服务提供者和服务消费者仍能通过本地缓存通讯。 集群负载均衡Random LoadBalance： 随机，按权重设置随机概率。在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。 RoundRobin LoadBalance： 轮循，按公约后的权重设置轮循比率。存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。 LeastActive LoadBalance： 最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。 ConsistentHash LoadBalance： 一致性 Hash，相同参数的请求总是发到同一提供者。当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。 服务降级 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心交易正常运作或高效运作。 mock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。 集群容错Failfast Cluster：快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录； Failsafe Cluster：失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作； Failback Cluster：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作； Forking Cluster：并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=”2” 来设置最大并行数； Broadcast Cluster：广播调用所有提供者，逐个调用，任意一台报错则报错 [2]。通常用于通知所有提供者更新缓存或日志等本地资源信息。","categories":[{"name":"Distributed","slug":"Distributed","permalink":"http://yoursite.com/categories/Distributed/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"}]},{"title":"Redis 点赞","slug":"Demo/Redis 点赞","date":"2020-04-09T06:29:14.000Z","updated":"2020-04-19T06:25:36.658Z","comments":true,"path":"2020/04/09/Demo/Redis 点赞/","link":"","permalink":"http://yoursite.com/2020/04/09/Demo/Redis%20%E7%82%B9%E8%B5%9E/","excerpt":"Redis 实现点赞功能。","text":"Redis 实现点赞功能。 环境搭建12345678910111213141516171819202122232425262728293031323334353637383940&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- Redis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- spring-json依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.8&lt;/version&gt;&lt;/dependency&gt;&lt;!-- spring-json依赖 --&gt; Redis 配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.wingo.springbootredis01.config;import com.fasterxml.jackson.annotation.JsonAutoDetect;import com.fasterxml.jackson.annotation.PropertyAccessor;import com.fasterxml.jackson.databind.ObjectMapper;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer;import org.springframework.data.redis.serializer.StringRedisSerializer;/** * @Author Wingo * @Date 2020-04-11 12:13 * @Description */@Configurationpublic class RedisConfig &#123; @Bean public StringRedisSerializer stringRedisSerializer() &#123; return new StringRedisSerializer(); &#125; @Bean public ObjectMapper objectMapper() &#123; ObjectMapper objectMapper = new ObjectMapper(); // 支持任意对象的 json 序列化和反序列化 objectMapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); return objectMapper; &#125; @Bean public Jackson2JsonRedisSerializer jackson2JsonRedisSerializer() &#123; Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(Object.class); jackson2JsonRedisSerializer.setObjectMapper(objectMapper()); return jackson2JsonRedisSerializer; &#125; @Bean public RedisTemplate redisTemplate(@Autowired RedisConnectionFactory redisConnectionFactory)&#123; RedisTemplate&lt;String,Object&gt; redisTemplate= new RedisTemplate&lt;&gt;(); // 序列化器 redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setDefaultSerializer(jackson2JsonRedisSerializer()); // 开启事务支持 redisTemplate.setEnableTransactionSupport(true); return redisTemplate; &#125;&#125; properties123456789101112131415161718# Redis数据库索引(默认为θ)spring.redis.database=0# Redis服务器地址spring.redis.host=192.168.31.100# Redis服务器连接端口spring.redis.port=6379# Redis服务器连接密码(默认为空)spring.redis.password=# 连接池最大连接数(使用负值表示没有限制)spring.redis.jedis.pool.max-active=10# 连接池最大阻塞等待时间(使用负值表示没有限制)spring.redis.jedis.pool.max-wait=-1# 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=5# 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0# 连接超时时间(毫秒)spring.redis.timeout=1000 单元测试123456789101112131415@RunWith(SpringRunner.class)@Slf4j@SpringBootTestclass SpringBootRedis01ApplicationTests &#123; @Autowired private RedisTemplate redisTemplate; @Test void simpleAdd() &#123; redisTemplate.opsForValue().set(\"test01\",\"这是一个测试01\"); log.info(redisTemplate.opsForValue().get(\"test01\").toString()); &#125;&#125; Redis 客户端存储正常，控制台正常输出，项目环境搭建完成。 点赞类型枚举类 LIKED ARTICLE 文章点赞；LIKED ⅥDEO 视频点赞； 代码实现 12345678910111213141516171819public enum MyType &#123; /** LIKED_ARTICLE */ LIKED_ARTICLE (\"文章点赞\"), /** LIKED_VIDEO */ LIKED_VIDEO (\"视频点赞\"), /** LIKED_VIDEO */ UNKONW_TYPE (\"未知类型\"); private String myType; /** * 构造器类 * @param myType */ MyType(String myType) &#123; this.myType = myType; &#125;&#125; 点赞工具类1234567891011121314151617181920public class LikedUtil &#123; /** 生成 Key */ public static String getKey(MyType myType, String subjectId) &#123; return myType + \":\" + subjectId; &#125; public static String getReportKey(MyType myType) &#123; MyType type; switch (myType) &#123; case LIKED_ARTICLE: type = MyType.LIKED_ARTICLE; break; case LIKED_VIDEO: type = MyType.LIKED_VIDEO; break; default: type = MyType.UNKONW_TYPE; &#125; return type + \"\"; &#125;&#125; 单元测试123456@Testvoid keyTest()&#123; MyType type = MyType.LIKED_ARTICLE; String result = LikedUtil.getKey(type, “1”); log.info(result);&#125; 自定义的 Key 格式：类型 + 类型实体的 id 简单实现该方案 Redis 数据库只存储点赞主体和被点赞主体的ID信息，数据类型采用 Hash 类型。 key ：LIKED_TYPE + subject_id，即使用文章的 id 作为 key 。field ： post_id 点赞人的id ； value 固定值 1 ：表示一个点赞主体对被点赞主体点了一次赞。 自定义接口1234567891011121314151617181920212223242526/** * @Author Wingo * @Date 2020-04-11 14:41 * @Description */public interface LikedSimpleService &#123; /** * 点赞 / 取消点赞功能 * * @param myType 点赞的类型 * @param subjectId 被点赞的主体的 id * @param postId 点赞主体的 id */ void liked(MyType myType, String subjectId, String postId); /** * 得到主体的总点赞数 * * @param myType 点赞的类型 * @param subjectId 被点赞的主体的 id * @return 总点赞数 */ Long count(MyType myType, String subjectId);&#125; 接口实现12345678910111213141516171819202122232425262728293031/** * @Author Wingo * @Date 2020-04-11 15:09 * @Description */@Servicepublic class LikedSimpleServiceImpl implements LikedSimpleService &#123; @Autowired private StringRedisTemplate redisTemplate; @Override public void liked(MyType myType, String subjectId, String postId) &#123; String key = LikedUtil.getKey(myType, subjectId); // 判断用户是否已经点赞，如果点过赞，取消点赞，如果没有点过点赞 Boolean liked = redisTemplate.opsForHash().hasKey(key, postId); if (Boolean.TRUE.equals(liked)) &#123; // 取消点赞 redisTemplate.opsForHash().delete(key, postId); &#125; else &#123; // 点赞 redisTemplate.opsForHash().put(key, postId, \"1\"); &#125; &#125; @Override public Long count(MyType myType, String subjectId) &#123; String key = LikedUtil.getKey(myType, subjectId); return redisTemplate.opsForHash().size(key); &#125;&#125; 单元测试12345678910111213141516171819202122232425262728293031@RunWith(SpringRunner.class)@Slf4j@SpringBootTestclass SpringBootRedis01ApplicationTests &#123; @Autowired private LikedSimpleService likedSimpleService; @Autowired private RedisTemplate redisTemplate; @Test void keyTest()&#123; MyType myType = MyType.LIKED_ARTICLE; for (int j = 1; j &lt;= 100; j++) &#123; for (int i = 1; i &lt;= j; i++) &#123; likedSimpleService.liked(myType, j+\"\", i+\"\"); &#125; &#125; &#125; @Test void countTest()&#123; MyType myType = MyType.LIKED_ARTICLE; int num = 0; while(num &lt;= 10)&#123; int subjectId = new Random().nextInt(100) + 1; long count = likedSimpleService.count(myType, Integer.toString(subjectId)); log.info(\"ID 为\" + subjectId + \"的文章点赞数为\" + count); num++; &#125;&#125; 初始化 100 篇文章的点赞信息，并且 id = num 的文章其点赞数为 num 复杂实现 前面的简单实现只缓存了 ID 的数据，而实际的应用场景中常常还需要更多的信息，比如文章标题、文章内容简介、用户昵称、用户头像、点赞排行等信息。根据需求继续完善项目。 方案设计 点赞数量统计：Hash key ：LIKED_TYPE + subject_id。 field ： post_id； value { json } 点赞的人的信息。 点赞排名统计： zSet key ：LIKED_TYPE_TOP。 field ： value { json } 被点赞主体的内容； score 记录被点赞主体的总赞数。 类型添加123456789101112131415161718192021222324252627public enum MyType &#123; /** LIKED_ARTICLE */ LIKED_ARTICLE (\"文章点赞\"), /** LIKED_VIDEO */ LIKED_VIDEO (\"视频点赞\"), /** LIKED_ARTICLE_TOP */ LIKED_ARTICLE_TOP (\"文章点赞排行\"), /** LIKED_VIDEO_TOP */ LIKED_VIDEO_TOP (\"视频点赞排行\"), /** LIKED_VIDEO */ UNKONW_TYPE (\"未知类型\"); private String myType; /** * 构造器类 * @param myType */ MyType(String myType) &#123; this.myType = myType; &#125; public String getMyType()&#123; return this.myType; &#125;&#125; 1234567891011121314151617181920212223242526public class LikedUtil &#123; LikedUtil()&#123; throw new IllegalStateException(\"Utility class\"); &#125; /** 生成 Key */ public static String getKey(MyType myType, String subjectId) &#123; return myType + \":\" + subjectId; &#125; /** 生成排行榜 Key */ public static String getTopKey(MyType myType) &#123; MyType type; switch (myType) &#123; case LIKED_ARTICLE: type = MyType.LIKED_ARTICLE_TOP; break; case LIKED_VIDEO: type = MyType.LIKED_VIDEO_TOP; break; default: type = MyType.UNKONW_TYPE; &#125; return type.toString(); &#125;&#125; 12345678@Datapublic class Article &#123; private Integer articleId; private String title; private String summary; private String img;&#125; 1234567@Datapublic class User &#123; private Integer userId; private String username; private String avatar;&#125; 自定义接口1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * @Author Wingo * @Date 2020-04-12 12:45 * @Description */public interface LikedService &#123; /** * 点赞/取消点赞 * * @param type 类型 * @param subjectId 被点赞主体 ID * @param postId 点赞主体 ID * @param postUser 点赞主体的概要信息 * @param subject 被点赞主体概要信息 */ void liked(MyType type, String subjectId, String postId, Object subject, Object postUser); /** * 获取主体点赞数量 * * @param type 类型 * @param subjectId 被点赞主体 ID * @return 点赞数量 */ Long count(MyType type, String subjectId); /** * 获取点赞主体的详情列表 * * @param type 类型 * @param subjectId 被点赞主体 ID * @return 点赞主体的详情列表 */ List&lt;Object&gt; getPostUserSet(MyType type, String subjectId); /** * 排行查询 * * @param type 业务类型 * @param top 前 top 名 * @return 排行列表 */ Set&lt;Object&gt; getSubjectTopN(MyType type, Long top);&#125; 接口实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package com.wingo.springbootredis01.service.impl;import com.wingo.springbootredis01.constant.Common;import com.wingo.springbootredis01.constant.MyType;import com.wingo.springbootredis01.service.LikedService;import com.wingo.springbootredis01.util.LikedUtil;import lombok.extern.slf4j.Slf4j;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.stereotype.Service;import java.util.List;import java.util.Set;/** * @Author Wingo * @Date 2020-04-12 12:50 * @Description */@Slf4j@Servicepublic class LikedServiceImpl implements LikedService &#123; @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate; @Override public void liked(MyType type, String subjectId, String postId, Object subject, Object postUser) &#123; String key = LikedUtil.getKey(type, subjectId); Boolean liked = redisTemplate.opsForHash().hasKey(key, postId); if (Boolean.TRUE.equals(liked)) &#123; // 取消赞 redisTemplate.opsForHash().delete(key, postId); &#125; else &#123; // 点赞 redisTemplate.opsForHash().put(key, postId, postUser); &#125; String reportKey = LikedUtil.getTopKey(type); if (Boolean.TRUE.equals(liked)) &#123; redisTemplate.opsForZSet().incrementScore(reportKey, subject, Common.DECLINE); &#125; else &#123; Double score = redisTemplate.opsForZSet().score(reportKey, subject); if (score == null) &#123; redisTemplate.opsForZSet().add(reportKey, subject, Common.INCREASE); &#125; else &#123; redisTemplate.opsForZSet().incrementScore(reportKey, subject, Common.INCREASE); &#125; &#125; &#125; @Override public Long count(MyType type, String subjectId) &#123; String key = LikedUtil.getKey(type, subjectId); return redisTemplate.opsForHash().size(key); &#125; @Override public List&lt;Object&gt; getPostUserSet(MyType type, String subjectId) &#123; String key = LikedUtil.getKey(type, subjectId); return redisTemplate.opsForHash().values(key); &#125; @Override public Set&lt;Object&gt; getSubjectTopN(MyType type, Long top) &#123; String key = LikedUtil.getTopKey(type); return redisTemplate.opsForZSet().reverseRange(key, 0, top); &#125;&#125; 单元测试12345678910111213141516171819202122232425@Testvoid keyTest()&#123; MyType myType = MyType.LIKED_ARTICLE; for (int j = 1; j &lt;= 100; j++) &#123; Article article= new Article(); article.setArticleId(j); article.setTitle(\"文章标题\"+j); article.setImg(\"文章图片\"+j); article.setSummary(\"文章摘要\"+j); for (int i = 1; i &lt;= j; i++) &#123; User user = new User(); user.setUserId (i); user.setUsername(\"user\"+ i); user.setAvatar(\"avatar\"+ i); likedService.liked(myType, j+\"\", i+\"\", article, user); &#125; &#125;&#125;@Testvoid countTest()&#123; MyType myType = MyType.LIKED_ARTICLE; log.info(likedService.getSubjectTopN(myType, (long) 10).toString());&#125; 用户信息被写入缓存。 ​ 取得排名前十的文章信息。","categories":[{"name":"Demo","slug":"Demo","permalink":"http://yoursite.com/categories/Demo/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"}]},{"title":"H2 配置","slug":"Software/H2 配置","date":"2020-04-06T09:33:57.000Z","updated":"2020-04-19T06:41:20.626Z","comments":true,"path":"2020/04/06/Software/H2 配置/","link":"","permalink":"http://yoursite.com/2020/04/06/Software/H2%20%E9%85%8D%E7%BD%AE/","excerpt":"Spring Boot 整合 H2 数据库.","text":"Spring Boot 整合 H2 数据库. 添加依赖12345678910111213&lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 常用配置12345678910111213141516171819202122# 若使用内存数据库 spring.datasource.url=jdbc:h2:mem:test# ./ 表示根目录下生成数据库文件 ~/ 表示用户根目录 spring.datasource.url=jdbc:h2:./db/testspring.datasource.driverClassName=org.h2.Driverspring.datasource.username=saspring.datasource.password=# 使用 H2 数据平台spring.datasource.platform=h2# 内存模式的数据库信息读取# spring.datasource.schema=classpath:db/schema.sql# spring.datasource.data=classpath:db/data.sqlspring.h2.console.settings.web-allow-others=true# 浏览器访问路径 &#123;path&#125;/h2spring.h2.console.path=/h2# 程序启动时启动 H2spring.h2.console.enabled=truespring.jpa.database-platform=org.hibernate.dialect.H2Dialectspring.jpa.generate-ddl=truespring.jpa.show-sql=truespring.jpa.hibernate.ddl-auto=update","categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}],"tags":[{"name":"H2","slug":"H2","permalink":"http://yoursite.com/tags/H2/"}]},{"title":"Mybatis-Plus","slug":"Software/Mybatis/Mybatis-Plus","date":"2020-04-06T03:44:35.000Z","updated":"2020-04-19T06:41:50.713Z","comments":true,"path":"2020/04/06/Software/Mybatis/Mybatis-Plus/","link":"","permalink":"http://yoursite.com/2020/04/06/Software/Mybatis/Mybatis-Plus/","excerpt":"Mybatis-Plus 整合 H2 数据库小案例。","text":"Mybatis-Plus 整合 H2 数据库小案例。 Mybatis-Plus 官方文档 SQL 语句 12345678910111213141516-- 建表语句CREATE TABLE user( id BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID', name VARCHAR(30) NULL DEFAULT NULL COMMENT '姓名', age INT(11) NULL DEFAULT NULL COMMENT '年龄', email VARCHAR(50) NULL DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (id));-- 插入数据INSERT INTO user (name, age, email) VALUES('Jone', 18, 'test1@baomidou.com'),('Jack', 20, 'test2@baomidou.com'),('Tom', 28, 'test3@baomidou.com'),('Sandy', 21, 'test4@baomidou.com'),('Billie', 24, 'test5@baomidou.com'); 环境搭建热部署 ctrl + shift + alt + /勾选 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!-- mybatis-plus --&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.3.1.tmp&lt;/version&gt; &lt;/dependency&gt; &lt;!-- H2 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 用于返回 JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 热部署 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;scope&gt;true&lt;/scope&gt; &lt;/dependency&gt; 1234567891011121314151617181920# 若使用内存数据库 spring.datasource.url=jdbc:h2:mem:test# ./ 表示根目录下生成数据库文件 ~/ 表示用户根目录spring.datasource.url=jdbc:h2:./db/testspring.datasource.driverClassName=org.h2.Driverspring.datasource.username=saspring.datasource.password=# 使用 H2 数据平台spring.datasource.platform=h2# 内存模式的数据库信息读取# spring.datasource.schema=classpath:db/schema.sql# spring.datasource.data=classpath:db/data.sqlspring.h2.console.settings.web-allow-others=true# 浏览器访问路径 &#123;path&#125;/h2spring.h2.console.path=/h2# 程序启动时启动 H2spring.h2.console.enabled=true# 打印 SQL 语句mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl 项目搭建VO12345678910111213141516171819202122232425262728293031323334353637383940public class ResponseVO extends HashMap&lt;String, Object&gt; &#123; private static final Integer SUCCESS_STATUS = 200; private static final Integer ERROR_STATUS = -1; private static final String SUCCESS_MSG = \"一切正常\"; private static final String ERROR_MSG = \"出现错误\"; private static final long serialVersionUID = 1L; public ResponseVO success(String msg) &#123; put(\"msg\", SUCCESS_MSG); put(\"status\", SUCCESS_STATUS); return this; &#125; public ResponseVO error(String msg) &#123; put(\"msg\", ERROR_MSG); put(\"status\", ERROR_STATUS); return this; &#125; public ResponseVO setData(String key, Object obj) &#123; @SuppressWarnings(\"unchecked\") HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) get(\"data\"); if (data == null) &#123; data = new HashMap&lt;&gt;(16); put(\"data\", data); &#125; data.put(key, obj); return this; &#125; /** * 返回JSON字符串 */ @Override public String toString() &#123; return JSONObject.toJSONString(this); // com.alibaba.fastjson &#125;&#125; Entity12345678910@Datapublic class User &#123; @TableId(type=IdType.AUTO) // 自增 private Long id; private String name; private Integer age; private String email;&#125; Mapper1234@Component // 可不加：防止编译器报错public interface UserMapper extends BaseMapper&lt;User&gt; &#123;&#125; Controller1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253@Controllerpublic class UserController &#123; @Autowired private UserMapper userMapper; @GetMapping(value = \"/selectList\") @ResponseBody public ResponseVO selectList()&#123; ResponseVO responseVO = new ResponseVO(); List&lt;User&gt; userList = userMapper.selectList(new QueryWrapper&lt;User&gt;().orderByDesc(\"id\")); responseVO.setData(\"userList\",userList); return responseVO; &#125; @GetMapping(value = \"/insert/&#123;name&#125;/&#123;age&#125;\") public String insert(@PathVariable(\"name\") String name, @PathVariable(\"age\") Integer age)&#123; User user = new User(); user.setName(name); user.setAge(age); user.setEmail(name + age +\"@wingo-email.com\"); userMapper.insert(user); return \"redirect:/selectList\"; &#125; @GetMapping(value = \"/delete/&#123;id&#125;\") public String delete(@PathVariable(\"id\") Integer id)&#123; userMapper.deleteById(id); return \"redirect:/selectList\"; &#125; @GetMapping(value = \"/age-eq/&#123;age&#125;\") public ResponseVO ageEqual(@PathVariable(\"age\") Integer age)&#123; ResponseVO responseVO = new ResponseVO(); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.eq(\"age\",age); List&lt;User&gt; userList = userMapper.selectList(queryWrapper); responseVO.setData(\"userList\",userList); return responseVO; &#125; @GetMapping(value = \"/age/&#123;gt&#125;/&#123;lt&#125;\") @ResponseBody public ResponseVO age(@PathVariable(\"gt\") Integer gt, @PathVariable(\"lt\") Integer lt)&#123; ResponseVO responseVO = new ResponseVO(); QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.gt(\"age\",gt); queryWrapper.lt(\"age\",lt); List&lt;User&gt; userList = userMapper.selectList(queryWrapper); responseVO.setData(\"userList\",userList); return responseVO; &#125;&#125; 接口测试 分页配置1234567891011121314151617@Configurationpublic class MyBatisConfig &#123; /** * MyBatis-puls 分页插件配置 * @return */ @Bean public PaginationInterceptor paginationInterceptor() &#123; PaginationInterceptor paginationInterceptor = new PaginationInterceptor(); // 设置请求的页面大于最大页后操作， true 调回到首页，false 继续请求 默认 false paginationInterceptor.setOverflow(false); // 设置最大单页限制数量，默认 500 条，-1 不受限制 paginationInterceptor.setLimit(500); return paginationInterceptor; &#125;&#125; 代码生成器1234567891011&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 官方文档查看支持的其它引擎 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.29&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/*** 代码生成器*/public class Generator &#123; /** * 读取控制台内容 */ public static String scanner(String tip) &#123; Scanner scanner = new Scanner(System.in); StringBuilder help = new StringBuilder(); help.append(\"请输入\" + tip + \"：\"); System.out.println(help.toString()); if (scanner.hasNext()) &#123; String ipt = scanner.next(); if (StringUtils.isNotEmpty(ipt)) &#123; return ipt; &#125; &#125; throw new MybatisPlusException(\"请输入正确的\" + tip + \"！\"); &#125; public static void main(String[] args) &#123; // 代码生成器 AutoGenerator mpg = new AutoGenerator(); // 全局配置 GlobalConfig gc = new GlobalConfig(); String projectPath = System.getProperty(\"user.dir\"); gc.setOutputDir(projectPath + \"/src/main/java\"); gc.setAuthor(\"wingo\"); gc.setOpen(false); // gc.setSwagger2(true); // 实体属性 Swagger2 注解 gc.setBaseResultMap(true); gc.setBaseColumnList(true); mpg.setGlobalConfig(gc); // 数据源配置 DataSourceConfig dsc = new DataSourceConfig(); dsc.setUrl(\"jdbc:mysql://localhost:3306/[db-name]?useSSL=false\"); dsc.setDriverName(\"com.mysql.jdbc.Driver\"); dsc.setUsername(\"root\"); dsc.setPassword(\"123456\"); mpg.setDataSource(dsc); // 包配置 PackageConfig pc = new PackageConfig(); pc.setModuleName(scanner(\"模块名\")); pc.setParent(\"com.wingo.mybatisplus\"); mpg.setPackageInfo(pc); // 自定义配置 InjectionConfig cfg = new InjectionConfig() &#123; @Override public void initMap() &#123; // to do nothing &#125; &#125;; List&lt;FileOutConfig&gt; focList = new ArrayList&lt;&gt;(); // 模板引擎是 freemarker focList.add(new FileOutConfig(\"/templates/mapper.xml.ftl\") &#123; @Override public String outputFile(TableInfo tableInfo) &#123; // 自定义输入文件名称 return projectPath + \"/src/main/resources/mapper/\" + pc.getModuleName() + \"/\" + tableInfo.getEntityName() + \"Mapper\" + StringPool.DOT_XML; &#125; &#125;); cfg.setFileOutConfigList(focList); mpg.setCfg(cfg); mpg.setTemplate(new TemplateConfig().setXml(null)); // 策略配置 StrategyConfig strategy = new StrategyConfig(); strategy.setNaming(NamingStrategy.underline_to_camel); strategy.setColumnNaming(NamingStrategy.underline_to_camel); strategy.setEntityLombokModel(true); // 使用 Lombok 插件 strategy.setInclude(scanner(\"表名\")); // 自定义继承类，可直接使用官方的顶级实现 // strategy.setSuperServiceClass(\"com.wingo.common.service.IService\"); // strategy.setSuperServiceImplClass(\"com.wingo.common.service.impl.ServiceImpl\"); // Controller配置 strategy.setSkipView(false); strategy.setControllerMappingHyphenStyle(true); strategy.setRestControllerStyle(false); // @Controller @RestController strategy.setTablePrefix(pc.getModuleName() + \"_\"); mpg.setStrategy(strategy); // 选择 freemarker 引擎需要指定如下加，注意 pom 依赖必须有！ mpg.setTemplateEngine(new FreemarkerTemplateEngine()); mpg.execute(); &#125;&#125; Service 顶级实现","categories":[{"name":"ORM","slug":"ORM","permalink":"http://yoursite.com/categories/ORM/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"vue 入手小项目","slug":"FrontEnd/Vue/Vue 小案例","date":"2020-04-04T07:47:41.000Z","updated":"2020-04-19T06:26:24.663Z","comments":true,"path":"2020/04/04/FrontEnd/Vue/Vue 小案例/","link":"","permalink":"http://yoursite.com/2020/04/04/FrontEnd/Vue/Vue%20%E5%B0%8F%E6%A1%88%E4%BE%8B/","excerpt":"Vue 实现一个小 Demo。","text":"Vue 实现一个小 Demo。 环境搭建 首先系统需要安装 Node.js 提供一个 Javascript 运行环境：Node 是一个服务器端 JavaScript 解释器。 系统命令行输入node -v查看 Node.js 是否安装成功。 利用 npm 命令安装 Vue： 12345npm install vuenpm install --global vue-clinpm install webpack -g# 进入到存放目录的目录下进行项目初始化vue init webpack demo_vue 初始化项目选项： 将项目导入 IDEA IntelliJ，命令行中输入npm run dev运行项目。（IDEA 中需要安装 Vue.js 插件） 在 IDEA 中打开项目目录中的文件时可能会报错，错误原因是 Js 的版本太低了，在配置中修改 Js 的版本即可。 配置 Element-UI 依赖，打开 package.json，找到 devDependencies 并在最后加上&quot;element-ui&quot;: “^2.2.1”，再通过cnpm install进行安装，安装完成后npm run dev启动。打开 main.js 在里面添加三行内容。 12345import ElementUI from 'element-ui' // 导入依赖import 'element-ui/lib/theme-chalk/index.css' // 避免后期打包样式不同: ...'./App'; 之前// ...Vue.use(ElementUI) // 注册// ... 新建一个组件 NewContact.vue： 123456789101112&lt;template&gt; &lt;el-row&gt; &lt;el-button type&#x3D;&quot;success&quot;&gt;1&lt;&#x2F;el-button&gt; &lt;&#x2F;el-row&gt;&lt;&#x2F;template&gt;&lt;script&gt;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 打开项目的初始组件 HelloWorld.vue 对其进行修改，并且打开 router/index.js 添加自定义的路由配置： 1234&lt;template&gt;&lt;!-- 路由标签 --&gt; &lt;router-link to&#x3D;&quot;newcontact&quot;&gt;&lt;h1&gt;&#123;&#123; msg &#125;&#125;&lt;&#x2F;h1&gt;&lt;&#x2F;router-link&gt;&lt;&#x2F;template&gt; 12345678910111213141516171819import Vue from 'vue'import Router from 'vue-router'import HelloWorld from '@/components/HelloWorld' // 引入组件: @ 代表根目录import NewContact from '@/components/NewContact'Vue.use(Router)export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125;, &#123; path: '/newcontact',// 与 router-link to 相对应，路由到 /newcontact name: 'NewContact', component: NewContact &#125; ]&#125;) 页面效果：点击 Rout to NewContact 路由到 NewContact 组件对应的页面。 自定义组件NewContact 组件中代码如下： @Click用于绑定函数；:data用于绑定数据；表格绑定数据情况下·prop·用于数据传递；slot-scope=&quot;del&quot;定义作用域，用于获取 table 的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;template&gt; &lt;el-row&gt; 姓名：&#123;&#123;info.name&#125;&#125; &lt;el-input v-model&#x3D;&quot;info.name&quot; placeholder&#x3D;&quot;请输入姓名&quot;&gt;&lt;&#x2F;el-input&gt; 年龄：&#123;&#123;info.age&#125;&#125; &lt;el-input v-model&#x3D;&quot;info.age&quot; placeholder&#x3D;&quot;请输入年龄&quot;&gt;&lt;&#x2F;el-input&gt; 性别：&#123;&#123;info.sex&#125;&#125; &lt;el-select v-model&#x3D;&quot;info.sex&quot; placeholder&#x3D;&quot;请选择&quot;&gt; &lt;el-option v-for&#x3D;&quot;item in options&quot; :key&#x3D;&quot;item&quot; :value&#x3D;&quot;item&quot;&gt;&lt;&#x2F;el-option&gt; &lt;&#x2F;el-select&gt; &lt;&#x2F;el-select&gt; &lt;el-button @click&#x3D;&quot;create&quot;&gt;创建&lt;&#x2F;el-button&gt; &lt;template&gt; &lt;el-table :data&#x3D;&quot;tabledata&quot; align&#x3D;&quot;left&quot;&gt; &lt;el-table-column prop&#x3D;&quot;name&quot; label&#x3D;&quot;姓名&quot;&gt;&lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;age&quot; label&#x3D;&quot;年龄&quot;&gt;&lt;&#x2F;el-table-column&gt; &lt;el-table-column prop&#x3D;&quot;sex&quot; label&#x3D;&quot;性别&quot;&gt;&lt;&#x2F;el-table-column&gt; &lt;el-table-column label&#x3D;&quot;操作&quot;&gt; &lt;template slot-scope&#x3D;&quot;de&quot;&gt; &lt;el-button size&#x3D;&quot;mini&quot; type&#x3D;&quot;danger&quot; @click&#x3D;&quot;del(de.$index)&quot;&gt;删除&lt;&#x2F;el-button&gt; &lt;&#x2F;template&gt; &lt;&#x2F;el-table-column&gt; &lt;&#x2F;el-table&gt; &lt;&#x2F;template&gt; &lt;&#x2F;el-row&gt;&lt;&#x2F;template&gt;&lt;script&gt; export default &#123; name: &quot;NewContact&quot;, data() &#123; return &#123; info: &#123; name: &#39;&#39;, age: &#39;&#39;, sex: &#39;&#39; &#125;, options: [ &#39;女&#39;, &#39;男&#39;, ], tabledata: [ &#123;name: &#39;test01&#39;, age: 11, sex: &#39;man&#39;&#125;, &#123;name: &#39;test02&#39;, age: 22, sex: &#39;women&#39;&#125;, &#123;name: &#39;test03&#39;, age: 33, sex: &#39;men&#39;&#125; ] &#125; &#125; &#125;&lt;&#x2F;script&gt;&lt;style&gt;&lt;&#x2F;style&gt; 此时访问页面：localhost:8080/#/newcontact 显示如下： 方法绑定12345678910111213141516171819&lt;script&gt;data()&#123; export default &#123; name: &quot;NewContact&quot;, data() &#123; &#x2F;&#x2F; ... &#125; methods: &#123; create()&#123; &#x2F;&#x2F; v-model 双向绑定：用户填写的信息自动绑定到对应的对象中 this.tabledata.push(this.info) &#x2F;&#x2F; 给 tabledata 添加一个对象（之前我们创建的 info ） this.info &#x3D; &#123;name: &#39;&#39;, age: &#39;&#39;, sex: &#39;&#39;&#125; &#x2F;&#x2F; 点击创建后，让option还原，而不是停留在所选的项 &#125;, del(index)&#123; &#x2F;&#x2F; splice(修改位置, 移除元素个数) this.tabledata.splice(index,1) &#x2F;&#x2F; 删除点击的对象，index 是 de.$index传过来的 &#125; &#125;&lt;&#x2F;script&gt; 添加完自定义的方法之后就可以正常的进行添加和删除信息的操作了。 本地存储数据在 src 文件夹下新建一个 store 文件夹，即与 App.vue、components 同属一个层级，在里面新建一个 store.js。 12345678910const STORAGE_KEY = 'info'//名字随便起export default &#123;//向往输出，以便组件接收 fetch() &#123;//我们定义的获取数据的方法 return JSON.parse(window.localStorage.getItem(STORAGE_KEY) || '[]') &#125;, save(items) &#123;//我们定义的保存数据的方法 window.localStorage.setItem(STORAGE_KEY, JSON.stringify(items)) &#125;&#125; getItem和setItem是 window.localStorage 的获取和保存数据的方法，获取的数据使用 JSON.stringify 和 JSON.parse 把数据转成字符串和解析，方便我们写入 tabledata。 12345678910111213141516171819&lt;script&gt;data()&#123; export default &#123; name: &quot;NewContact&quot;, data() &#123; &#x2F;&#x2F; ... &#125; methods: &#123; &#x2F;&#x2F; ... &#125; watch: &#123; &#x2F;&#x2F; watch 是 vue 的监听，一旦监听对象有变化就会执行相应操作 tabledata: &#123; &#x2F;&#x2F; 被监听的对象 handler(items)&#123; Storage.save(items) &#125;, &#x2F;&#x2F; 监听对象变化后所做的操作，保存数据 deep: true &#x2F;&#x2F; 深度监听，防止数据层级过多监听不到 &#125; &#125;&lt;&#x2F;script&gt; 测试结果： 项目打包打开 /config/index.js 进行一点小修改。 123456789build: &#123; index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: './', // 加了个 . 避免生产路径的错误 productionSourceMap: false, // 修改为 false &#125; 打包成功后在项目路径下生成一个 dist 文件夹，打开 index.html 即可运行此项目。","categories":[{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/categories/FrontEnd/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Spring Boot 任务","slug":"Spring Boot/Spring Boot 任务","date":"2020-04-01T02:50:45.000Z","updated":"2020-04-19T06:43:44.041Z","comments":true,"path":"2020/04/01/Spring Boot/Spring Boot 任务/","link":"","permalink":"http://yoursite.com/2020/04/01/Spring%20Boot/Spring%20Boot%20%E4%BB%BB%E5%8A%A1/","excerpt":"Spring Boot 中的异步任务，定时任务，邮件任务的使用。","text":"Spring Boot 中的异步任务，定时任务，邮件任务的使用。 异步任务 在 Java 应用中，绝大多数情况下都是通过同步的方式来实现交互处理的。但是在处理与第三方系统交互的时候，容易造成响应迟缓的情况，之前大部分都是使用多线程来完成此类任务。其实，在Spring 3.x 之后，就已经内置了@Async、@EnableAysnc来完美解决这个问题。 在 Spring 中运用 Async 注解需要注意几点： 方法名必须是 public 进行修饰的，且不能是 static 方法； 不能与调用的方法在同一个类中； 需要把该方法注入到 Spring 容器中，就是在一个类中添加异步方法，并在此类上使用@Component之类的注解。 测试实例定义 Task 类，创建三个处理函数分别模拟三个执行任务的操作，操作消耗时间随机取（10 秒内）。 12345678910111213141516171819202122232425262728293031323334353637@Componentpublic class Task &#123; public static Random random =new Random(); @Async // 注释为异步任务， public Future&lt;String&gt; doTaskOne() throws Exception &#123; System.out.println(\"Doing Task One\"); long start = System.currentTimeMillis(); Thread.sleep(random.nextInt(10000)); long end = System.currentTimeMillis(); System.out.println(\"Task One Finished：Spend \" + (end - start) + \" Millisecond\"); // 若不用 Future 进行回调，无法确定任务已经完成 return new AsyncResult&lt;&gt;(\"Task One Finished\"); // 返回异步调用结果 &#125; @Async public Future&lt;String&gt; doTaskTwo() throws Exception &#123; System.out.println(\"Doing Task Two\"); long start = System.currentTimeMillis(); Thread.sleep(random.nextInt(10000)); long end = System.currentTimeMillis(); System.out.println(\"Task Two Finished：Spend \" + (end - start) + \" Millisecond\"); return new AsyncResult&lt;&gt;(\"Task Two Finished\"); &#125; @Async public Future&lt;String&gt; doTaskThree() throws Exception &#123; System.out.println(\"Doing Task Three\"); long start = System.currentTimeMillis(); Thread.sleep(random.nextInt(10000)); long end = System.currentTimeMillis(); System.out.println(\"Task Three Finished：Spend \" + (end - start) + \" Millisecond\"); return new AsyncResult&lt;&gt;(\"Task Three Finished\"); &#125;&#125; 12345678@SpringBootApplication@EnableAsync // 异步任务生效public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 123456789101112131415161718192021@Testpublic void test() throws Exception &#123; long start = System.currentTimeMillis(); Future&lt;String&gt; taskOne = task.doTaskOne(); Future&lt;String&gt; taskTwo = task.doTaskTwo(); Future&lt;String&gt; taskThree = task.doTaskThree(); while(true) &#123; if(taskOne.isDone() &amp;&amp; taskTwo.isDone() &amp;&amp; taskThree.isDone()) &#123; // 三个任务都调用完成，退出循环等待 break; &#125; Thread.sleep(1000); &#125; long end = System.currentTimeMillis(); System.out.println(\"All Finished，总耗时：\" + (end - start) + \"毫秒\");&#125; 定时任务 项目开发中经常需要执行一些定时任务，比如需要在每天凌晨时候，分析一次前一天的日志信息。Spring 为我们提供了异步执行任务调度的方式，提供 TaskExecutor 、TaskScheduler 接口。 注解：@EnableScheduling、@Scheduled corn 表达式 *******从左到右分别代表：秒 分 时 日 月 星期 年份，这里 * 指所有可能的值。 在线 Cron 表达式生成器 测试1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011121314151617@Servicepublic class TaskService &#123; /** * second（秒）, minute（分）, hour（时）, day of month（日）, month（月）, day of week（周几）. * 例子： * 0 0/5 14,18 * * ? 每天14点整，和18点整，每隔5分钟执行一次 * 0 15 10 ? * 1-6 每个月的周一至周六10:15分执行一次 * 0 0 2 ? * 6L 每个月的最后一个周六凌晨2点执行一次 * 0 0 2 LW * ? 每个月的最后一个工作日凌晨2点执行一次 * 0 0 2-4 ? * 1#1 每个月的第一个周一凌晨2点到4点期间，每个整点都执行一次； */ @Scheduled(cron = \"0,1,2,3,4 * * * * MON-SAT\") public void runTask()&#123; System.out.println(new Date()+\"Doing Schedule Task\"); &#125;&#125; 邮件任务 最早期的时候使用 JavaMail 相关 API 来开发，需要自己去封装消息体，代码量比较庞大；后来 Spring 推出了 JavaMailSender 简化了邮件发送过程，JavaMailSender 提供了强大的邮件发送功能，可支持各种类型的邮件发送。现在 Spring Boot 在 JavaMailSender 的基础上又进行了封装，就有了现在的 spring-boot-starter-mail，让邮件发送流程更加简洁和完善。 测试1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 123456spring.mail.username=邮箱账号# 在邮件站点的个人中心中获取spring.mail.password=xxxxxspring.mail.host=smtp.163.com // 邮件协议对应的服务器spring.mail.protocol=smtp // 邮件协议spring.mail.properties.mail.smtp.ssl.enable=true 12345678910111213141516@AutowiredJavaMailSenderImpl mailSender;@Testpublic void testSimpleMessage()&#123; SimpleMailMessage message = new SimpleMailMessage(); message.setSubject(\"第一封测试邮件\"); message.setText(\"邮件测试...\"); message.setFrom(\"你的邮箱账号\"); message.setTo(\"发送对象的邮箱账号\"); mailSender.send(message);&#125; 123456789101112131415161718@Testpublic void testMimeMessage() throws Exception&#123; // 创建复杂消息 MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(mimeMessage, true); helper.setSubject(\"第二封邮件\"); helper.setText(\"&lt;b style='color:red'&gt;邮件测试....&lt;/b&gt;\",true); helper.setFrom(\"你的邮箱账号\"); helper.setTo(\"发送对象的邮箱账号\"); // 发送邮件 helper.addAttachment(\"1.jpg\",new File(\"C:\\\\Users\\\\12746\\\\Pictures\\\\22\\\\1.jpg\")); helper.addAttachment(\"2.jpg\",new File(\"C:\\\\Users\\\\12746\\\\Pictures\\\\22\\\\2.jpg\")); mailSender.send(mimeMessage);&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Aysnc","slug":"Aysnc","permalink":"http://yoursite.com/tags/Aysnc/"},{"name":"Scheduled","slug":"Scheduled","permalink":"http://yoursite.com/tags/Scheduled/"},{"name":"Email","slug":"Email","permalink":"http://yoursite.com/tags/Email/"}]},{"title":"Spring Boot 安全","slug":"Spring Boot/Spring Boot 安全","date":"2020-04-01T02:50:45.000Z","updated":"2020-04-19T06:43:06.632Z","comments":true,"path":"2020/04/01/Spring Boot/Spring Boot 安全/","link":"","permalink":"http://yoursite.com/2020/04/01/Spring%20Boot/Spring%20Boot%20%E5%AE%89%E5%85%A8/","excerpt":"Shiro 轻量级安全框架的介绍及使用；Sping 安全框架 Spring Security 的介绍及使用。","text":"Shiro 轻量级安全框架的介绍及使用；Sping 安全框架 Spring Security 的介绍及使用。 Spring Security简介 Spring Security 是针对 Spring 项目的安全框架，也是 Spring Boot 底层安全模块默认的技术选型。可以实现强大的 web 安全控制。对于安全控制，我们仅需引入 spring-boot-starter-security 模块，进行少量的配置，即可实现强大的安全管理。 WebSecurityConfigurerAdapter：自定义 Security 策略； AuthenticationManagerBuilder：自定义认证策略； @EnableWebSecurity：开启 WebSecurity。 应用程序的两个主要区域是“认证”和“授权”（或者访问控制）。这两个主要区域是 Spring Security 的两个目标。 “认证”（Authentication），是建立一个经过声明的主体的过程，即你是谁； “授权”（Authorization）指确定一个主体是否允许在你的应用程序执行一个动作的过程，即你能干什么。 入门实例引入依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;&lt;/dependency&gt; 建立一个 Web 层的请求接口： 12345678@RestController@RequestMapping(\"/user\")public class UserController &#123; @GetMapping public String getUsers() &#123; return \"Hello Spring Security\"; &#125;&#125; 自定义用户认证逻辑 系统一般都有自定义的用户体系，Spring Security 提供了接口可以自定义认证逻辑以及登录界面。 1234567// 密码加密接口public interface PasswordEncoder &#123; // 对密码进行加密 String encode(CharSequence var1); // 对密码进行判断匹配 boolean matches(CharSequence var1, String var2);&#125; 12345// 实现 Spring Security 中的 PasswordEncoder 接，这里用提供的默认实现@Beanpublic PasswordEncoder passwordEncoder() &#123; return new BCryptPasswordEncoder(); &#125; 配置用户认证逻辑： UserDetails 就是封装了用户信息的对象，返回 UserDetails 的实现类 User 的时候，可以通过 User 的构造方法，设置对应的参数。 12345678910111213141516171819@Componentpublic class MyUserDetailsService implements UserDetailsService &#123; private Logger logger = LoggerFactory.getLogger(getClass()); @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; logger.info(\"用户的用户名: &#123;&#125;\", username); // TODO 根据用户名，查找到对应的密码，与权限 // 封装用户信息，并返回。参数分别是：用户名，密码，用户权限 String password = passwordEncoder.encode(\"123456\"); logger.info(\"password: &#123;&#125;\", password); // 每次打印的密码都不一样，因为经过了加密 // 参数分别是：用户名，密码，用户权限 User user = new User(username, password, AuthorityUtils.commaSeparatedStringToAuthorityList(\"admin\")); return user; &#125;&#125; 自定义登录页面： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;自定义登录页面&lt;/h2&gt; &lt;form action=\"/user/login\" method=\"post\"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名：&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"username\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码：&lt;/td&gt; &lt;td&gt;&lt;input type=\"password\" name=\"password\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=\"2\"&gt;&lt;button type=\"submit\"&gt;登录&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 配置模块12345678910111213141516@Configurationpublic class BrowerSecurityConfig extends WebSecurityConfigurerAdapter &#123; protected void configure(HttpSecurity http) throws Exception &#123; http.formLogin() // 定义当需要用户登录时候，转到的登录页面。 .loginPage(\"/login.html\") // 设置登录页面 .loginProcessingUrl(\"/user/login\") // 自定义的登录接口 .and() .authorizeRequests() // 定义哪些 URL 需要被保护，哪些不需要被保护 .antMatchers(\"/login.html\").permitAll() // 设置所有人都可以访问登录页面 .anyRequest() // 任何请求，登录后可以访问 .authenticated() .and() .csrf().disable(); // 关闭 csrf 防护 &#125;&#125; Shiro Apache Shiro是一个功能强大且易于使用的 Java安 全框架，它为开发人员提供了一种直观，全面的身份验证，授权，加密和会话管理解决方案。 核心 API Subject： 用户主体（把操作交给SecurityManager）；SecurityManager：安全管理器（关联Realm）；Realm：Shiro 连接数据的桥梁。 入门实例SQL 建表语句： 1234567CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varbinary(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL, `perms` varchar(64) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8 导入依赖： 12345678910111213141516&lt;!-- shiro --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.theborakompanioni&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-extras-shiro&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 自定义 Realm 类123456789101112131415161718192021222324252627282930313233343536373839@Slf4jpublic class UserRealm extends AuthorizingRealm &#123; @Autowired private UserRepository userRepository; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection arg0) &#123; log.info(\"执行授权逻辑\"); Subject subject = SecurityUtils.getSubject(); User user = userRepository.findUserByUsername((String) subject.getSession().getAttribute(\"username\")); // 给用户进行授权 SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(); info.addStringPermission(user.getPerms()); return info; &#125; @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken arg0) throws AuthenticationException &#123; log.info(\"执行认证逻辑\"); Subject subject = SecurityUtils.getSubject(); Session session = subject.getSession(); UsernamePasswordToken token = (UsernamePasswordToken)arg0; User user = userRepository.findUserByUsername(token.getUsername()); session.setAttribute(\"username\", token.getUsername()); if(user==null)&#123; // shiro 底层会抛出UnKnowAccountException return null; &#125; // 判断密码 return new SimpleAuthenticationInfo(user,user.getPassword(),getName()); &#125;&#125; Shiro 配置类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Slf4j@Configurationpublic class ShiroConfig &#123; @Autowired @Qualifier(\"shiroCacheManager\") private ShiroCacheManager shiroCacheManager; @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Autowired DefaultWebSecurityManager securityManager)&#123; ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 设置安全管理器 shiroFilterFactoryBean.setSecurityManager(securityManager); // 注入缓存管理器 securityManager.setCacheManager(shiroCacheManager); // 设置过滤器链 Map&lt;String,String&gt; filterMap = new LinkedHashMap&lt;&gt;(16); filterMap.put(\"/index\", \"anon\"); filterMap.put(\"/favicon.ico\", \"anon\"); // 添加访问权限 filterMap.put(\"/toAdd\", \"perms[user:add]\"); filterMap.put(\"/toUpdate\", \"perms[user:update]\"); // 注意：要放在允许访问的页面后面，否则允许访问无效 filterMap.put(\"/**\", \"authc\"); // 如果没有认证通过 跳转到的 url 地址 shiroFilterFactoryBean.setLoginUrl(\"/login\"); shiroFilterFactoryBean.setSuccessUrl(\"/index\"); // 未授权跳转页面 shiroFilterFactoryBean.setUnauthorizedUrl(\"/error\"); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterMap); return shiroFilterFactoryBean; &#125; // 安全管理器 @Bean public DefaultWebSecurityManager getDefaultWebSecurityManager(@Autowired UserRealm userRealm)&#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 关联 realm securityManager.setRealm(userRealm); return securityManager; &#125; @Bean public UserRealm getRealm()&#123; return new UserRealm(); &#125; /** 配置 ShiroDialect，用于 Thymeleaf 和 Shiro 标签配合使用 */ // 添加 xmlns:shiro=\"http://www.pollix.at/thymeleaf/shiro\" 标签校验规范 @Bean public ShiroDialect getShiroDialect()&#123; return new ShiroDialect(); &#125;&#125; 控制器类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Controllerpublic class UserController &#123; @GetMapping(\"/login\") public String login()&#123; return \"login\"; &#125; @GetMapping(\"/index\") public String hello(Model model)&#123; Subject subject = SecurityUtils.getSubject(); model.addAttribute(\"username\", subject.getSession().getAttribute(\"username\")); return \"index\"; &#125; @GetMapping(\"/toAdd\") public String add()&#123; return \"/user/add\"; &#125; @GetMapping(\"/toUpdate\") public String update()&#123; return \"/user/update\"; &#125; @GetMapping(\"/toExit\") public String exit()&#123; Subject subject = SecurityUtils.getSubject(); subject.logout(); return \"redirect:/login\"; &#125; @PostMapping(\"/login\") public String login(String username, String password, Model model)&#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username,password); try &#123; Session session = subject.getSession(); session.setAttribute(\"username\", username); subject.login(token); return \"redirect:/index\"; &#125; catch (UnknownAccountException e) &#123; model.addAttribute(\"msg\", \"用户名不存在\"); return \"login\"; &#125;catch (IncorrectCredentialsException e) &#123; model.addAttribute(\"msg\", \"密码错误\"); return \"login\"; &#125; &#125;&#125; 高级自定义缓存管理器：Spring 接管 Shiro 的缓存管理。 实现 Shiro 提供的 Cache 和 CacheManager 接口 👉 实现 Cache 缓存接口底层使用 SpringCache 实现。 ShiroCache12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*** 自定义 Shiro 缓存，实现 ShiroCache 接口** @param &lt;K&gt;* @param &lt;V&gt;*/public class ShiroCache&lt;K,V&gt; implements org.apache.shiro.cache.Cache&lt;K,V&gt; &#123; // Spring 的缓存管理器 private CacheManager springCacheManager; // Spring 的缓存对象 private Cache springCache; // 构造器 public ShiroCache(org.springframework.cache.CacheManager springCacheManager, String cacheName) &#123; this.springCacheManager = springCacheManager; this.springCache = springCacheManager.getCache(cacheName); &#125; // 自定义实现，都由 Spring 的缓存对象进行操作 @Override public V get(K key) throws CacheException &#123; Cache.ValueWrapper valueWrapper = springCache.get(key); if (valueWrapper == null) &#123; return null; &#125; return (V) valueWrapper.get(); &#125; @Override public V put(K key, V value) throws CacheException &#123; springCache.put(key, value); return value; &#125; @Override public V remove(K key) throws CacheException &#123; V value = this.get(key); springCache.evict(key); return value; &#125; /** * 清空缓存 * @throws CacheException */ @Override public void clear() throws CacheException &#123; springCache.clear(); &#125; /** * 获取所有缓存key的集合 * * @return */ @Override public Set&lt;K&gt; keys() &#123; return (Set&lt;K&gt;) springCacheManager.getCacheNames(); &#125; /** * 获取所有缓存value值的集合 * * @return */ @Override public Collection&lt;V&gt; values() &#123; List&lt;V&gt; list = new ArrayList&lt;&gt;(); Set&lt;K&gt; keys = keys(); for (K k : keys) &#123; list.add(this.get(k)); &#125; return list; &#125; /** * 获取缓存对象的数量 * * @return */ @Override public int size() &#123; int size = keys().size(); return size; &#125;&#125; ShiroCacheManager12345678910111213public class ShiroCacheManager&lt;K, V&gt; implements CacheManager &#123; // Spring 的缓存管理器 private org.springframework.cache.CacheManager springCacheManager; public ShiroCacheManager(org.springframework.cache.CacheManager springCacheManager) &#123; this.springCacheManager = springCacheManager; &#125; @Override public &lt;K, V&gt; Cache&lt;K, V&gt; getCache(String cacheName) throws CacheException &#123; // 通过缓存名在缓存管理器中获取对应的缓存 return new ShiroCache&lt;&gt;(springCacheManager, cacheName); &#125;&#125; 1234567891011121314151617/*** shiro 的缓存管理器* @return*/@Bean(name = \"shiroCacheManager\")public ShiroCacheManager shiroCacheManager()&#123; // 创建一个 Redis 缓存的默认配置 RedisCacheConfiguration conf = RedisCacheConfiguration.defaultCacheConfig(); // 设置会话的有效期 conf = conf.entryTtl(Duration.ofSeconds(30)); RedisCacheManager cacheManager = RedisCacheManager .builder(redisConnectionFactory) .cacheDefaults(conf) .build(); // 不用 ShiroCacheManager 返回的其实是一个 RedisCacheManager return new ShiroCacheManager(cacheManager);&#125; 注入自定义的缓存管理器 12345678910111213141516@Slf4j@Configurationpublic class ShiroConfig &#123; @Autowired @Qualifier(\"shiroCacheManager\") private ShiroCacheManager shiroCacheManager; @Bean public ShiroFilterFactoryBean getShiroFilterFactoryBean(@Autowired DefaultWebSecurityManager securityManager)&#123; // ... // 注入缓存管理器 securityManager.setCacheManager(shiroCacheManager); // ... &#125;&#125; ShiroSessionDAO1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Repositorypublic class ShiroSessionDAO extends AbstractSessionDAO &#123; @Autowired private RedisTemplate&lt;Serializable, Session&gt; redisTemplate; private String name = \"shiro-session:\"; private long timeout = 30; @Override protected Serializable doCreate(Session session) &#123; // 生成会话的唯一id Serializable sessionId = generateSessionId(session); super.create(session); redisTemplate.opsForValue().set(name + sessionId, session); return sessionId; &#125; @Override protected Session doReadSession(Serializable sessionId) &#123; super.readSession(sessionId); // 更新缓存 redisTemplate.expire(sessionId, timeout, TimeUnit.MINUTES); return redisTemplate.opsForValue().get(sessionId); &#125; @Override public void update(Session session) throws UnknownSessionException &#123; redisTemplate.opsForValue().set(name + session.getId(), session); &#125; @Override public void delete(Session session) &#123; redisTemplate.delete(name + session.getId()); &#125; @Override public Collection&lt;Session&gt; getActiveSessions() &#123; Set&lt;Serializable&gt; set = redisTemplate.keys(name + \"*\"); List&lt;Session&gt; sessionList = new ArrayList&lt;&gt;(); for (Serializable sessionId : set) &#123; sessionList.add(redisTemplate.opsForValue().get(name + sessionId)); &#125; return sessionList; &#125;&#125; 配置类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100@Configurationpublic class ShiroConfig &#123; @Autowired @Qualifier(\"shiroCacheManager\") private ShiroCacheManager shiroCacheManager; /** * 配置自定义SessionDAO * @return */ @Bean public SessionDAO sessionDAO() &#123; SessionDAO sessionDAO = new ShiroSessionDAO(shiroCacheManager); return sessionDAO; &#125; /** * 配置会话管理器 * @return */ @Bean public SessionManager sessionManager()&#123; // WEB 环境非 HttpSession 会话管理器 DefaultWebSessionManager sessionManager = new DefaultWebSessionManager(); // 注入自定义的 SessionDao sessionManager.setSessionDAO(sessionDAO()); return sessionManager; &#125; /** * 配置安全管理器 * * @return */ @Bean public SecurityManager securityManager() &#123; DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 注入自定义Realm securityManager.setRealm(shiroRealm()); // 注入缓存管理器 securityManager.setCacheManager(shiroCacheManager); // 注入会话管理器 securityManager.setSessionManager(sessionManager()); return securityManager; &#125; /** * 装配 自定义Realm * * @return */ @Bean public ShiroRealm shiroRealm() &#123; return new ShiroRealm(); &#125; /** * 配置权限权限过滤器 * @return */ @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean() &#123; ShiroFilterFactoryBean filter = new ShiroFilterFactoryBean(); // 注入安全管理器 filter.setSecurityManager(securityManager()); // 未认证的跳转地址 filter.setLoginUrl(\"/login\"); Map&lt;String, String&gt; chain = new LinkedHashMap&lt;&gt;(); chain.put(\"/login\", \"anon\"); // 登录链接不拦截 chain.put(\"/css/**\", \"anon\"); chain.put(\"/img/**\", \"anon\"); chain.put(\"/js/**\", \"anon\"); chain.put(\"/lib/**\", \"anon\"); chain.put(\"/**\", \"user\"); filter.setFilterChainDefinitionMap(chain); return filter; &#125; /** * 启用 Shiro 注解 * @return */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor() &#123; AuthorizationAttributeSourceAdvisor advisor = new AuthorizationAttributeSourceAdvisor(); // 注入安全管理器 advisor.setSecurityManager(securityManager()); return advisor; &#125; /** * 启用 Shiro Thymeleaf 标签支持 * @return */ @Bean public ShiroDialect shiroDialect() &#123; return new ShiroDialect(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"}]},{"title":"Spring Boot 检索","slug":"Spring Boot/Spring Boot 检索","date":"2020-03-31T06:50:45.000Z","updated":"2020-04-19T06:43:37.795Z","comments":true,"path":"2020/03/31/Spring Boot/Spring Boot 检索/","link":"","permalink":"http://yoursite.com/2020/03/31/Spring%20Boot/Spring%20Boot%20%E6%A3%80%E7%B4%A2/","excerpt":"ElasticSearch 基本介绍以及在 Spring Boot 中的整合使用。","text":"ElasticSearch 基本介绍以及在 Spring Boot 中的整合使用。 ElasticSearch如今的应用经常需要添加检索功能，开源的 ElasticSearch 是目前全文搜索引擎的首选。他可以快速的存储、搜索和分析海量数据。Spring Boot 通过整合 Spring Data ElasticSearch 为我们提供了非常便捷的检索功能支持。 Elasticsearch 是一个分布式搜索服务，提供 Restful API，底层基于 Lucene，采用多 shard（分片）的方式保证数据安全，并且提供自动 resharding 的功能，github 等大型的站点也是采用了 ElasticSearch 作为其搜索服务。 Elasticsearch 本身就是分布式的，即便只有一个节点，Elasticsearch 默认也会对的数据进行分片和副本操作，向集群添加新数据时，数据也会在新加入的节点中进行平衡 相关概念一个 ElasticSearch 集群可以包含多个索引 ，相应的每个索引可以包含多个类型 。这些不同的类型存储着多个文档 ，每个文档又有多个属性 。 Elasticsearch 也是基于 Lucene 的全文检索库，本质也是存储数据，很多概念与关系型数据库是一致的，如下对照： 索引库 关系型数据库 类型（type） Table 数据表 文档（Document） Row 行 字段（Field） Columns 列 另外，在 Elasticsearch 有一些集群相关的概念： 索引集（Indices，index 的复数）：逻辑上的完整索引； 分片（shard）：数据拆分后的各个部分； 副本（replica）：每个分片的复制。 整合 Spring Boot 提供了两种方式操作 Elasticsearch，Jest 和 SpringData。 Docker 安装部署 ElasticSearch 12345# 下载镜像docker pull elasticsearch# Elasticsearch 启动是会默认分配 2G 的内存 ，我们启动是设置小一点，防止我们内存不够启动失败# 9200 是 Elasticsearch 默认的 web 通信接口，9300 是分布式情况下，Elasticsearch 各个节点的通信端口docker run -e ES_JAVA_OPTS=\"-Xms256m -Xmx256m\" -d -p 9200:9200 -p 9300:9300 --name es01 5c1e1ecfe33a Jest ElasticSearch already has a Java API which is also used by ElasticSearch internally, but Jest fills a gap, it is the missing client for ElasticSearch Http Rest interface. 添加依赖： 12345&lt;dependency&gt; &lt;groupId&gt;io.searchbox&lt;/groupId&gt; &lt;artifactId&gt;jest&lt;/artifactId&gt; &lt;version&gt;5.3.3&lt;/version&gt;&lt;/dependency&gt; 配置服务器： 1spring.elasticsearch.jest.uris=http://127.0.0.1:9200 ## Elasticsearch 服务器 编写实体类： 12345678910111213141516171819202122232425public class Article &#123; // If @JestId value is null, it will be set the value of ElasticSearch generated \"_id\". @JestId // @JestId annotation can be used to mark a property of a bean as id private Integer id; private String author; private String title; private String content; // Getter / Setter @Override public String toString() &#123; final StringBuilder sb = new StringBuilder( \"&#123;\\\"Article\\\":&#123;\" ); sb.append( \"\\\"id\\\":\" ) .append( id ); sb.append( \",\\\"author\\\":\\\"\" ) .append( author ).append( '\\\"' ); sb.append( \",\\\"title\\\":\\\"\" ) .append( title ).append( '\\\"' ); sb.append( \",\\\"content\\\":\\\"\" ) .append( content ).append( '\\\"' ); sb.append( \"&#125;&#125;\" ); return sb.toString(); &#125;&#125; 测试12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringbootElasticsearchApplicationTests &#123; @Autowired JestClient jestClient; @Test public void createIndex() &#123; // 初始化一个文档 Article article = new Article(); article.setId( 1 ); article.setTitle( \"好消息\" ); article.setAuthor( \"张三\" ); article.setContent( \"Hello World\" ); // 构建一个索引 Index index = new Index.Builder(article).index(\"shekou\").type(\"news\").build(); try &#123; // 执行 jestClient.execute(index); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void search() &#123; // 查询表达式 String query = \"&#123;\\n\" + \" \\\"query\\\" : &#123;\\n\" + \" \\\"match\\\" : &#123;\\n\" + \" \\\"content\\\" : \\\"hello\\\"\\n\" + \" &#125;\\n\" + \" &#125;\\n\" + \"&#125;\"; // 构建搜索功能 Search search = new Search.Builder(query).addIndex(\"shekou\").addType(\"news\").build(); try &#123; // 执行 SearchResult result = jestClient.execute(search); System.out.println(result.getJsonString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 搜索表达式查询： Searching Document Spring Dataspring-data-elasticsearch 使用之前必须先确定 Elasticsearch 版本：点击查看官方文档 Spring Data 通过注解来声明字段的映射属性，注解的详细用法： @Document 作用在类，标记实体类为文档对象，一般有两个属性： indexName：对应索引库名称； type：对应在索引库中的类型； shards：分片数量，默认5； replicas：副本数量，默认1。 @Id作用在成员变量，标记一个字段作为 id 主键。 @Field作用在成员变量，标记为文档的字段，并指定字段映射属性： type：字段类型，是枚举：FieldType，可以是 text、long、short、date、integer、object 等： Text：存储数据时候，会自动分词，并生成索引； Keyword：存储数据时候，不会分词建立索引； Numerical：数值类型，分两类： 基本数据类型：long、interger、short、byte、double、float、half_float； 浮点数的高精度类型：scaled_float 需要指定一个精度因子，比如 10 或 100。Elasticsearch 会把真实值乘以这个因子后存储，取出时再还原。 Date：日期类型 Elasticsearch 可以对日期格式化为字符串存储，但是建议我们存储为毫秒值，存储为 long，节省空间。 index：是否索引，布尔类型，默认是true； store：是否存储，布尔类型，默认是false； analyzer：分词器名称。 CRUD Spring Data 的强大之处，就在于你不用写任何 DAO 处理，自动根据方法名或类的信息进行 CRUD 操作。只要你定义一个接口，然后继承 Repository 提供的一些子接口，就能具备各种基本的 CRUD 功能。 123public interface ItemRepository extends ElasticsearchRepository&lt;Item,Long&gt; &#123;&#125; 测试12345678910111213141516171819202122// 创建一个实体类并标注为文档@Document(indexName = \"item\", type = \"docs\", shards = 1, replicas = 0)public class Item &#123; @Id private Long id; @Field(type = FieldType.Text) private String title; @Field(type = FieldType.Keyword) private String category; @Field(type = FieldType.Keyword) private String brand; @Field(type = FieldType.Double) private Double price; @Field(index = false, type = FieldType.Keyword) private String images;&#125; 调用 elasticsearchTemplate 创建索引并映射： 1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTest(classes = EsDemoApplication.class)public class EsDemoApplicationTests &#123; @Autowired private ElasticsearchTemplate elasticsearchTemplate; @Test public void testCreateIndex() &#123; // 根据 Item 类的 @Document 注解信息来创建 elasticsearchTemplate.createIndex(Item.class); &#125; @Test public void insert() &#123; Item item = new Item(1L, \"Redmi\", \" 手机\", \"小米\", 1499.00, \"RedmiImage.jpg\"); itemRepository.save(item); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"}]},{"title":"Spring Boot 消息中间件","slug":"Spring Boot/Spring Boot 消息队列","date":"2020-03-31T03:50:45.000Z","updated":"2020-04-19T06:44:07.737Z","comments":true,"path":"2020/03/31/Spring Boot/Spring Boot 消息队列/","link":"","permalink":"http://yoursite.com/2020/03/31/Spring%20Boot/Spring%20Boot%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/","excerpt":"MQ 基本介绍以及与 Spring Boot 的整合使用。","text":"MQ 基本介绍以及与 Spring Boot 的整合使用。 概述在大多数应用程序中，可通过消息服务中间件来提升系统异步通信、扩展解耦能力。 消息代理（message broker）；目的地（destination）。 当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地。消息队列主要有两种形式的目的地。 队列（queue）：点对点消息通信（point-to-point）；主题（topic）：发布（publish）/ 订阅（subscribe）消息通信。 应用场景：异步处理（邮件）、应用解耦、流量削峰（秒杀）。 JMS：Java 消息服务（Java Message Service）应用程序接口是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java 消息服务是一个与具体平台无关的API，绝大多数 MOM 提供商都对 JMS 提供支持。 AMQP：高级消息队列协议（Advanced Message Queuing Protocol）, 对于面向消息中间件的应用层协议。 常见消息中间件ActiveMQ Apache ActiveMQ 是 Apache 软件基金会所研发的开放源代码消息中间件。 RabbitMQ RabbitMQ 是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ 服务器是用 Erlang 语言编写的， Kafka 发布订阅消息系统、分布式日志服务。本身是做日志储存的，所以对消息的顺序有严格的要求。开源流处理平台，由 Scala 和 java 编写，目标是为处理实时数据提供一个统一、高吞吐、低延迟的平台。其持久化层本质上是一个按照分布式事务日志架构的大规模发布 / 订阅消息队列。 编码接口JMS 编码接口： ConnectionFactory：创建连接到消息中间件的连接工厂； Connection：通信链路； Destination：消息发布和接收的地点，包括队列和主题； Session：会话，表示一个单线程的上下文； MessageConsumer：会话创建，用于接收消息； MessageProducer：会话创建，用于发送消息； Message：消息对象，包括消息头，消息属性，消息体。 一个 Connection 可以创建多个会话，即一个连接可以供多个线程使用。 Spring 支持 spring-jms 提供了对 JMS 的支持；spring-rabbit 提供了对 AMQP 的支持。 需要 ConnectionFactory 的实现来连接消息代理； 提供 JmsTemplate、RabbitTemplate 来发送消息； @JmsListener（JMS）、@RabbitListener（AMQP）注解在方法上监听消息代理发布的消息； @EnableJms、@EnableRabbit 开启支持。 Spring Boot 自动配置 JmsAutoConfiguration、RabbitAutoConfiguration RabbitMQ核心概念Message 消息：消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括 routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。 Publisher 消息的生产者：是一个向交换器发布消息的客户端应用程序。 Exchange 交换器：用来接收生产者发送的消息并将这些消息路由给服务器中的队列。Exchange 有 4 种类型：direct（默认：routing key = binding key）、fanout（广播）、 topic,、和 headers（匹配消息的 Header 而不是路由键），不同类型的 Exchange 转发消息的策略有所区别。 topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符： # 匹配 0 个或多个单词；*匹配一个单词。 Queue 消息队列：用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。 Binding 绑定：用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。 Exchange 和 Queue 的绑定可以是多对多的关系。 Connection 网络连接：比如一个TCP连接。 Channel 信道：多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的 TCP 连接内的虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁 TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条 TCP 连接。 Consumer消息的消费者：表示一个从消息队列中取得消息的客户端应用程序。 Virtual Host 虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。每个 vhost 本质上就是一个 mini 版的 RabbitMQ 服务器，拥有自己的队列、交换器、绑定和权限机制。vhost 是 AMQP 概念的基础，必须在连接时指定，RabbitMQ 默认的 vhost 是 / 。 Broker 表示消息队列服务器实体。 RabbitMQ 整合导入模块依赖的 starter： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; Spring Boot 配置： 123456## 配置 rabbitMq 服务器rabbitmq: host: 127.0.0.1 port: 5672 username: root password: root 配置一个直连型的交换机： 123456789101112131415161718192021@Configurationpublic class DirectRabbitConfig &#123; // 初始化队列名：TestDirectQueue @Bean public Queue TestDirectQueue() &#123; return new Queue(\"TestDirectQueue\",true); // true 持久化 &#125; // 初始化 Direct 交换机：TestDirectExchange @Bean DirectExchange TestDirectExchange() &#123; return new DirectExchange(\"TestDirectExchange\"); &#125; // 定义队列和交换机绑定, 并设置用于匹配键：TestDirectRouting @Bean Binding bindingDirect() &#123; return BindingBuilder.bind(TestDirectQueue()).to(TestDirectExchange()).with(\"TestDirectRouting\"); &#125;&#125; 写个简单的接口进行消息推送（根据需求也可以改为定时任务等等，具体看需求）： 1234567891011121314151617181920@RestControllerpublic class SendMessageController &#123; @Autowired RabbitTemplate rabbitTemplate; // 使用 RabbitTemplate：提供了接收 / 发送等方法 @GetMapping(\"/sendDirectMessage\") public String sendDirectMessage() &#123; String messageId = String.valueOf(UUID.randomUUID()); String messageData = \"test message, hello!\"; String createTime = LocalDateTime.now().format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")); Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put(\"messageId\",messageId); map.put(\"messageData\",messageData); map.put(\"createTime\",createTime); // 将消息携带绑定键值 TestDirectRouting 发送到交换机 TestDirectExchange rabbitTemplate.convertAndSend(\"TestDirectExchange\", \"TestDirectRouting\", map); return \"ok\"; &#125;&#125; consumer 创建一个消费者项目，消费者进行消息监听，需要手动创建消息接收的监听类。 123456789@Component@RabbitListener(queues = \"TestDirectQueue\") // 监听的队列名称 TestDirectQueuepublic class DirectReceiver &#123; @RabbitHandler public void process(Map testMessage) &#123; System.out.println(\"DirectReceiver 消费者收到消息: \" + testMessage.toString()); &#125;&#125; 回调函数12345678910111213141516171819202122232425262728293031323334@Configurationpublic class RabbitConfig &#123; @Bean public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory)&#123; RabbitTemplate rabbitTemplate = new RabbitTemplate(); rabbitTemplate.setConnectionFactory(connectionFactory); // 设置开启 Mandatory 才能触发回调函数，无论消息推送结果怎么样都强制调用回调函数 rabbitTemplate.setMandatory(true); // 交换机相关信息 rabbitTemplate.setConfirmCallback(new RabbitTemplate.ConfirmCallback() &#123; @Override public void confirm(CorrelationData correlationData, boolean ack, String cause) &#123; System.out.println(\"ConfirmCallback: \"+\"相关数据：\"+correlationData); System.out.println(\"ConfirmCallback: \"+\"确认情况：\"+ack); System.out.println(\"ConfirmCallback: \"+\"原因：\"+cause); &#125; &#125;); // 队列相关信息 rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() &#123; @Override public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) &#123; System.out.println(\"ReturnCallback: \"+\"消息：\"+message); System.out.println(\"ReturnCallback: \"+\"回应码：\"+replyCode); System.out.println(\"ReturnCallback: \"+\"回应信息：\"+replyText); System.out.println(\"ReturnCallback: \"+\"交换机：\"+exchange); System.out.println(\"ReturnCallback: \"+\"路由键：\"+routingKey); &#125; &#125;); return rabbitTemplate; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"}]},{"title":"Spring Boot 缓存","slug":"Spring Boot/Spring Boot 缓存","date":"2020-03-31T01:59:45.000Z","updated":"2020-04-19T06:43:27.077Z","comments":true,"path":"2020/03/31/Spring Boot/Spring Boot 缓存/","link":"","permalink":"http://yoursite.com/2020/03/31/Spring%20Boot/Spring%20Boot%20%E7%BC%93%E5%AD%98/","excerpt":"JSR107、Spring 缓存抽象。","text":"JSR107、Spring 缓存抽象。 JRS107 Java Caching 定义了 5 个核心接口，分别是 CachingProvider, CacheManager, Cache, Entry 和 Expiry。 • CachingProvider：定义了创建、配置、获取、管理和控制多个 CacheManager。一个应用可以在运行期访问多个 CachingProvider； • CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的 Cache，这些 Cache存在于 CacheManager 的上下文中。一个 CacheManager 仅被一个 CachingProvider 所拥有； • Cache：是一个类似 Map 的数据结构并临时存储以 Key 为索引的值。一个 Cache 仅被一个 CacheManager 所拥有； • Entry：是一个存储在 Cache 中的 key-value 对； • Expiry：每一个存储在 Cache 中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。 Spring 缓存抽象Spring 3.1 以上版本定义了 org.springframework.cache.Cache 和 org.springframework.cache.CacheManager 接口来统一不同的缓存技术；并支持使用 JCache（JSR-107）注解简化我们开发。 Cache 接口为缓存的组件规范定义，包含缓存的各种操作集合；Cache 接口下 Spring 提供了各种 xxxCache 的实现；如 RedisCache、EhCacheCache 、ConcurrentMapCache等。 每次调用需要缓存功能的方法时，Spring 会检查检查指定参数的指定的目标方法是否已经被调用过：如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 确定方法需要被缓存以及他们的缓存策略；从缓存中读取之前缓存存储的数据。 注解基本流程添加缓存模块的 stater： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 引入 Redis 的 starter，容器中默认保存的是 RedisCacheManager。RedisCacheManager 负责创建RedisCache，RedisCache 负责操作 Redis 缓存数据。默认保存数据 Key / Value 都是 Object，默认使用的是 JDK 序列化器。 在 Spring Boot 主类中添加 EnableCaching 注解开启缓存功能： 1234567@SpringBootApplication@EnableCachingpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在类上添加CacheConfig进行缓存配置；在方法上添加@Cacheable，标注此方法返回值需要被缓存。 12345@CacheConfig(cacheNames = \"users\")public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123; @Cacheable User findByName(String name);&#125; 注解详解@CacheConfig：主要用于配置该类中会用到的一些共用的缓存配置。在这里@CacheConfig(cacheNames = &quot;users&quot;)：配置了该数据访问对象中返回的内容将存储于名为 users 的缓存对象中，我们也可以不使用该注解，直接通过@Cacheable自己配置缓存集的名字来定义。 @Cacheable：配置了 findByName 函数的返回值将被加入缓存。同时在查询时，会先从缓存中获取，若不存在才再发起对数据库的访问。该注解主要有下面几个参数： value、cacheNames：两个等同的参数（cacheNames为 Spring 4 新增，作为value的别名），用于指定缓存存储的集合名。由于 Spring 4 中新增了@CacheConfig，因此在 Spring 3 中原本必须有的value属性，也成为非必需项了； key：缓存对象存储在 Map 集合中的 key 值，非必需，缺省按照函数的所有参数组合作为 key 值，若自己配置需使用 SpEL 表达式，比如：@Cacheable(key = &quot;#p0&quot;)：使用函数第一个参数作为缓存的 key 值，更多关于 SpEL 表达式的详细内容可参考官方文档； condition：缓存对象的条件，非必需，也需使用 SpEL 表达式，只有满足表达式条件的内容才会被缓存，比如：@Cacheable(key = &quot;#p0&quot;, condition = &quot;#p0.length() &lt; 3&quot;)，表示只有当第一个参数的长度小于3的时候才会被缓存； unless：另外一个缓存条件参数，非必需，需使用 SpEL 表达式。它不同于condition参数的地方在于它的判断时机，该条件是在函数被调用之后才做判断的，所以它可以通过对 result 进行判断； keyGenerator：用于指定 key 生成器，非必需。若需要指定一个自定义的 key 生成器，需要开发者实现org.springframework.cache.interceptor.KeyGenerator接口，并使用该参数来指定。需要注意的是：该参数与key是互斥的； cacheManager：用于指定使用哪个缓存管理器，非必需。只有当有多个时才需要使用； cacheResolver：用于指定使用那个缓存解析器，非必需。需通过org.springframework.cache.interceptor.CacheResolver接口来实现自己的缓存解析器，并用该参数指定。 @CachePut：配置于函数上，能够根据参数定义条件来进行缓存，它与@Cacheable不同的是，它每次都会真实调用函数，所以主要用于数据新增和修改操作上。它的参数与@Cacheable类似，具体功能可参考上面对@Cacheable参数的解析。 @CacheEvict：配置于函数上，通常用在删除方法上，用来从缓存中移除相应数据。除了同@Cacheable一样的参数之外，它还有下面两个参数： allEntries：非必需，默认为 false。当为 true 时，会移除所有数据； beforeInvocation：非必需，默认为 false，会在调用方法之后移除数据。当为 true 时，会在调用方法之前移除数据。 TemplateSpring Boot 提供了帮助操作 Redis 的 Helper 类 RedisTemplate：RedisTemplate的 K:V 均为 Object；StringRedisTemplate 继承自 RedisTemplate，是专为 String:String 类型的 K:V 提供服务。 在 RedisAutoConfiguration 中 Spring Boot 自动注册了 RedisTemplate 和 StringRedisTemplate。 数据操作 Redis 中常见的五大类数据类型：String，List，Set，Hash 和 ZSet。 RedisTemplate 封装了对五大类数据进行操作的方法，每一个方法都会返回一个 Operations 对象。 123456789RedisTemplate.opsForValue(); // StringRedisTemplate.opsForList();RedisTemplate.opsForSet();RedisTemplate.opsForHash();RedisTemplate.opsForZSet(); Redis 实现缓存入门基础 String 最基础的数据类型；List 元素不具有唯一性；有序；是一个双向链表；既可以是栈，也可以是队列；Set 元素具有唯一性；无序；Hash 存储的是key-value结构，key必须是string；类似于 MySQL 中的一条记录。 Redis 命令接口 Redis 提供了许多命令供我们使用，同样在 Spring Boot 中也封装了对应类型的命令接口供开发者使用。 123456789101112131415161718192021/** * Interface for the commands supported by Redis. * * @author Costin Leau * @author Christoph Strobl */public interface RedisCommands extends RedisKeyCommands, RedisStringCommands, RedisListCommands, RedisSetCommands, RedisZSetCommands, RedisHashCommands, RedisTxCommands, RedisPubSubCommands, RedisConnectionCommands, RedisServerCommands, RedisScriptingCommands, RedisGeoCommands, HyperLogLogCommands &#123; /** * 'Native' or 'raw' execution of the given command along-side the given arguments. The command is executed as is, * with as little 'interpretation' as possible - it is up to the caller to take care of any processing of arguments or * the result. * * @param command Command to execute * @param args Possible command arguments (may be null) * @return execution result. */ Object execute(String command, byte[]... args);&#125; 在 Spring Boot 配置文件中添加 Redis 配置： 1234567891011121314151617## 默认密码为空redis: host: 127.0.0.1 # Redis服务器连接端口 port: 6379 jedis: pool: # 连接池最大连接数（使用负值表示没有限制） max-active: 100 # 连接池中的最小空闲连接 max-idle: 10 # 连接池最大阻塞等待时间（使用负值表示没有限制） max-wait: 100000 # 连接超时时间（毫秒） timeout: 5000 # 默认是索引为 0 的数据库 database: 0 代码示例1234567891011121314151617181920@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBootCacheApplicationTests &#123; @Autowired EmployeeMapper employeeMapper; @Autowired StringRedisTemplate stringRedisTemplate; @Autowired RedisTemplate redisTemplate; // 向 Redis 中保存一个对象并取出打印 @Test public void test() &#123; Employee employee = employeeMapper.getEmpById(1); redisTemplate.opsForValue().set(\"emp01\",employee); Object emp01 = redisTemplate.opsForValue().get(\"emp01\"); System.out.println(emp01); &#125;&#125; 注意，Redis 中对象的保存是需要进行序列化的，默认使用 JdkSerializationRedisSerializer 序列化器，所以在 Redis 中查看保存的对象是序列化后的二进制编码，正常使用是没有问题的，查询出来的时候会自动反序列化。 如果习惯于使用 String，那么可以将其 JSON 化，两种方式：使用第三方 JSON 或者向容器中添加自定义 RedisTemplate 改变其默认序列化器。 添加自定义 RedisTemplate： 123456789101112@Configurationpublic class MyRedisConfig &#123; @Bean public RedisTemplate&lt;Object,Employee&gt; empRedisTemplate(RedisConnectionFactory connectionFactory)&#123; RedisTemplate&lt;Object,Employee&gt; template = new RedisTemplate&lt;Object, Employee&gt;(); template.setConnectionFactory(connectionFactory); Jackson2JsonRedisSerializer&lt;Employee&gt; serializer = new Jackson2JsonRedisSerializer&lt;Employee&gt;(Employee.class); template.setDefaultSerializer(serializer); return template; &#125;&#125; Lettuce Jedis 在实现上是直接连接 Redis 服务器，在多个线程间共享一个 Jedis 实例时是线程不安全的，如果想要在多线程场景下使用 Jedis ，需要使用连接池，每个线程都使用自己的 Jedis 实例，当连接数量增多时，会消耗较多的物理资源。 与 Jedis 相比， Lettuce 则完全克服了其线程不安全的缺点： Lettuce 是一个可伸缩的线程安全的 Redis 客户端，支持同步、异步和响应式模式。多个线程可以共享一个连接实例，而 不必担心多线程并发问题。它基于优秀 Netty NIO 框架构建，支持 Redis 的更多高级功能。 12345678910&lt;!-- redis 访问启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- redis 客户端 Lettuce 数据库连接池依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-pool2&lt;/artifactId&gt;&lt;/dependency&gt; 123456789101112131415161718# Redis数据库索引（默认为0）spring.redis.database=0# Redis服务器地址 （默认localhost）spring.redis.host=localhost# Redis服务器连接端口 （默认6379）spring.redis.port=6379# Redis服务器连接密码（默认为空）spring.redis.password=123456# 连接超时时间spring.redis.timeout=10000ms# 最大连接数（使用负值表示没有限制） 默认 8spring.redis.lettuce.pool.max-active=8# 最小空闲连接 默认 0spring.redis.lettuce.pool.min-idle=0# 最大空闲连接 默认 8spring.redis.lettuce.pool.max-idle=8# 最大阻塞等待时间（使用负值表示没有限制） 默认 -1msspring.redis.lettuce.pool.max-wait=-1ms 缓存原理 要使用 Spring Boot 的缓存功能，还需要提供一个缓存的具体实现。 Spring Boot 一定的顺序去侦测缓存实现。 Spring 提供了一个统一访问缓存的接口：CacheManager ctrl + alt + b 可查看这个接口的实现 在 RedisCacheManager 中查看 Redis 缓存的默认配置类：RedisCacheConfiguration： 从源码了解到 Sping Boot 的 Reids 缓存对 Key 和 Value 默认的序列化器分别是 String 类型和 JDK 序列器。 在 RedisCacheManager 中可以看到如何实例化这个类： 实例化这个类必须传入一个 connectionFactory，用 redis 缓存所以传入一个 redisConnectionFactory。 1234567891011121314@Configurationpublic class CacheConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; /** * SpringCacheManager 缓存管理器：使用的缓存产品是Redis * @return */ @Bean(name = \"springCacheManager\") public RedisCacheManager springCacheManager()&#123; RedisCacheManager cacheManager = RedisCacheManager.create(redisConnectionFactory); return cacheManager; &#125;&#125; Redis 配置123456789101112131415161718192021222324252627282930313233@Configurationpublic class RedisConfig &#123; @Autowired private RedisConnectionFactory redisConnectionFactory; @Bean public StringRedisSerializer stringRedisSerializer() &#123; StringRedisSerializer stringRedisSerializer = new StringRedisSerializer(); return stringRedisSerializer; &#125; @Bean public StringRedisTemplate stringRedisTemplate() &#123; StringRedisTemplate stringRedisTemplate =new StringRedisTemplate(); stringRedisTemplate.setConnectionFactory(redisConnectionFactory); // 开启事务支持 stringRedisTemplate.setEnableTransactionSupport(true); return stringRedisTemplate; &#125; @Bean public RedisTemplate redisTemplate()&#123; RedisTemplate&lt;Object,Object&gt; redisTemplate= new RedisTemplate&lt;&gt;(); // 序列化器 redisTemplate.setConnectionFactory(redisConnectionFactory); redisTemplate.setKeySerializer(stringRedisSerializer()); //redisTemplate.setHashKeySerializer(stringRedisSerializer()); // 开启事务支持 redisTemplate.setEnableTransactionSupport(true); return redisTemplate; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"},{"name":"Cache","slug":"Cache","permalink":"http://yoursite.com/tags/Cache/"}]},{"title":"MyBatis 插件之拦截器","slug":"Software/Mybatis/Mybatis 插件之拦截器","date":"2020-03-29T08:18:40.000Z","updated":"2020-04-19T06:41:44.234Z","comments":true,"path":"2020/03/29/Software/Mybatis/Mybatis 插件之拦截器/","link":"","permalink":"http://yoursite.com/2020/03/29/Software/Mybatis/Mybatis%20%E6%8F%92%E4%BB%B6%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/","excerpt":"MyBatis 拦截器的详细用法介绍。","text":"MyBatis 拦截器的详细用法介绍。 在很多业务场景下我们需要去拦截 SQL，达到不入侵原有代码业务处理一些东西，比如：分页操作，数据权限过滤操作， SQL 执行时间性能监控等等。在某些应用场景下就需要使用到 MyBatis 的拦截器。 Mybatis 核心对象Configuration 初始化基础配置：比如 MyBatis 的别名等，一些重要的类型对象，如：插件，映射器，ObjectFactory 和 typeHandler 对象等，MyBatis 所有的配置信息都保存在 Configuration 对象之中； SqlSessionFactory SqlSession 工厂：SqlSession 作为 MyBatis工作的主要顶层 API，表示与数据库交互的会话，完成必要数据库增删改查功能； Executor MyBatis 执行器：是 MyBatis 调度的核心，负责 SQL 语句的生成和查询缓存的维护； ParameterHandler：负责对用户传递的参数转换成 JDBC Statement 所需要的参数； ResultSetHandler： 负责将 JDBC 返回的 ResultSet 结果集对象转换成 List 类型的集合； TypeHandler：负责 Java 数据类型和 JDBC 数据类型之间的映射和转换； MappedStatement：维护了一条 &lt;select | update | delete | insert&gt; 节点的封装； SqlSource：负责根据用户传递的 parameterObject，动态地生成 SQL 语句，将信息封装到 BoundSql 对象中，并返回； BoundSql：表示动态生成的 SQL 语句以及相应的参数信息。 拦截器原理实现Mybatis 支持对 Executor、StatementHandler、PameterHandler 和 ResultSetHandler 接口进行拦截，也就是说可以对这个四种类型的对象进行代理。 注解@Intercepts在实现 Interceptor 接口的类声明，使该类注册成为拦截器。 @Signature(type = Executor.class,method = &quot;&quot;, args = {) type：表示拦截的类，这里是 Executor 的实现类； method：表示拦截的方法，这里是拦截 Executor 的 query 方法； args：表示方法参数。 123456789@Slf4j@Component@Intercepts(&#123;@Signature(type = Executor.class, method = \"update\", args = &#123;MappedStatement.class, Object.class&#125;), @Signature(type = Executor.class, method = \"query\", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class SqlInterceptor implements Interceptor &#123; private Properties properties; // ...后面给出详细方法&#125; intercept 方法 要想拦截目标对象的目标方法的执行，可以通过 invocation 来获取拦截的目标方法及参数，以及执行目标方法，包含代理的几个重要元素 method、target、args。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// 通过 invocation 拦截目标对象的目标方法执行中需要被打印输出的信息@Overridepublic Object intercept(Invocation invocation) throws Throwable &#123; // MappedStatement 维护了一条 mapper.xml 文件里面 select 、update、delete、insert 节点的封装 MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0]; Object parameter = null; if (invocation.getArgs().length &gt; 1) &#123; parameter = invocation.getArgs()[1]; &#125; // 取得 SQL 标识符 String sqlId = mappedStatement.getId(); // 取得动态生成的 SQL 语句以及相应的参数信息对象 BoundSql boundSql = mappedStatement.getBoundSql(parameter); // 取得 Mybatis 的配置信息 Configuration configuration = mappedStatement.getConfiguration(); Object returnValue = null; long start = System.currentTimeMillis(); // 继续执行原目标方法 returnValue = invocation.proceed(); // 获取实体类 Class&lt;?&gt; parameterType = getParameterType(mappedStatement); // 判断是否包含 SQL 语句打印注解 if (!hasSqlPrintAnnotation(parameterType)) &#123; return returnValue; &#125; long end = System.currentTimeMillis(); long time = (end - start); // 筛选出执行时间较长的 SQL 语句以便优化 if (time &gt; 1) &#123; // 自定义输出的 SQL 语句 String sql = getSql(configuration, boundSql, sqlId, time); log.info(sql); &#125; // 返回执行后的结果 return returnValue;&#125;// 获取实体对象类private Class&lt;?&gt; getParameterType(MappedStatement statement) &#123; if (statement.getParameterMap() == null || statement.getParameterMap().getType() == null) &#123; return null; &#125; return statement.getParameterMap().getType();&#125;// 判断实体类上是否包含自定义的 SQl 打印的注解 @SqlPrintprivate static boolean hasSqlPrintAnnotation(Class&lt;?&gt; classType) &#123; return classType == null ? Boolean.FALSE : classType.isAnnotationPresent(SqlPrint.class);&#125;private static String getSql(Configuration configuration, BoundSql boundSql, String sqlId, long time) &#123; String sql = showSql(configuration, boundSql); StringBuilder str = new StringBuilder(100); str.append(sqlId); str.append(\" : \"); // 具体执行的 SQL 语句 str.append(sql); str.append(\" &gt;&gt;&gt;&gt;&gt;&gt; \"); // SQL 执行的时间 str.append(\"SQL执行耗时: \"); str.append(time); str.append(\"ms\"); return str.toString();&#125;// 组装需要打印的 SQLprivate static String showSql(Configuration configuration, BoundSql boundSql) &#123; // 取得参数的对象，实际上就是一个多个参数的 map 结构 Object parameterObject = boundSql.getParameterObject(); // 查询 SQL 中的参数 List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); // 将 SQL 中一个或多个回车换行符号替换成一个空格 String sql = boundSql.getSql().replaceAll(\"[\\\\s]+\", \" \"); if (!parameterMappings.isEmpty() &amp;&amp; parameterObject != null) &#123; // Mybatis 在启动时就会通过 TypeHandlerRegistry 进行注册，即建立 JdbcType, JavaType, TypeHandler 三者之间的关系。 // 因此，这意味着在 Mybatis 启动时我们也需要通过 TypeHandlerRegistry 将我们的所有的枚举类型（JavaType）与自定义的枚举 // TypeHandler（EnumTypeHandler）建立联系 TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); // 自定义 TypeHandler 时会走这个逻辑，建立 JavaType 和 JdbcType 之间的联系 if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; // 替换 SQL 中的占位符 “?” 为具体的参数，replaceFirst 作为是替换匹配到的第一个占位符 “?” sql = sql.replaceFirst(\"\\\\?\", getFormatParameterValue(parameterObject)); &#125; // 没有自定义的 TypeHandler，走通用逻辑 else &#123; // 拿到 target（拦截对象）的元数据 MetaObject metaObject = configuration.newMetaObject(parameterObject); // 参数是按顺序存储的，下面逻辑按顺序来替换 for (ParameterMapping parameterMapping : parameterMappings) &#123; // 获取参数的名称 String propertyName = parameterMapping.getProperty(); // 如果元数据对象中存在该参数，则替换相应的占位符 “?” if (metaObject.hasGetter(propertyName)) &#123; Object obj = metaObject.getValue(propertyName); sql = sql.replaceFirst(\"\\\\?\", getFormatParameterValue(obj)); &#125; // 如果有额外的参数，走下面的逻辑 else if (boundSql.hasAdditionalParameter(propertyName)) &#123; Object obj = boundSql.getAdditionalParameter(propertyName); sql = sql.replaceFirst(\"\\\\?\", getFormatParameterValue(obj)); &#125; &#125; &#125; &#125; // 返回组装好的 SQL return sql;&#125;// 按类型格式化 SQL 里的参数private static String getFormatParameterValue(Object obj) &#123; String value = null; if (obj instanceof String) &#123; value = \"'\" + obj.toString() + \"'\"; &#125; else if (obj instanceof Date) &#123; DateFormat formatter = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.CHINA); value = \"'\" + formatter.format(new Date()) + \"'\"; &#125; else &#123; if (obj != null) &#123; value = obj.toString(); &#125; else &#123; value = \"\"; &#125; &#125;&#125; plugin 方法 包装目标对象，包装的意思就是为目标对象创建一个代理。 1234567891011@Overridepublic Object plugin(Object target) &#123; // 判断目标对象类型是否为所需类型 if (target instanceof Executor) &#123; // 为 target 创建一个动态代理，以此来实现方法拦截和增强功能：回调 intercept 方法 return Plugin.wrap(target, this); &#125; else &#123; // 无需拦截则直接返回目标对象本身 return target; &#125;&#125;","categories":[{"name":"ORM","slug":"ORM","permalink":"http://yoursite.com/categories/ORM/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"}]},{"title":"synchronized & Lock","slug":"Java/HighConcurrency/synchronized & Lock","date":"2020-03-28T11:31:54.000Z","updated":"2020-04-19T06:28:54.098Z","comments":true,"path":"2020/03/28/Java/HighConcurrency/synchronized & Lock/","link":"","permalink":"http://yoursite.com/2020/03/28/Java/HighConcurrency/synchronized%20&%20Lock/","excerpt":"synchronized 和 Lock 实现同步互斥访问。","text":"synchronized 和 Lock 实现同步互斥访问。 如果对临界资源加上互斥锁，当一个线程在访问该临界资源时，其他线程便只能等待。 在 Java 中，每一个对象都拥有一个锁标记（monitor），也称为监视器，多线程同时访问某个对象时，线程只有获取了该对象的锁才能访问。 synchronized 在 Java 中，可以使用 synchronized 关键字来标记一个方法或者代码块，当某个线程调用该对象的 synchronized 方法或者访问 synchronized 代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。 synchronized 方法两个线程分别调用 insertData() 对象插入数据。（非同步） 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; final InsertData insertData = new InsertData(); // 匿名内部类 new Thread() &#123; public void run() &#123; insertData.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread() &#123; public void run() &#123; insertData.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; &#125;class InsertData &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); public void insert(Thread thread)&#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(thread.getName()+\"在插入数据\"+i); arrayList.add(i); &#125; &#125;&#125; 输出结果表明两个线程在同时执行insert方法。而如果在insert方法前面加上关键字 synchronized。 12345678910class InsertData &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); // 同步方法 public synchronized void insert(Thread thread)&#123; for(int i=0;i&lt;5;i++)&#123; System.out.println(thread.getName()+\"在插入数据\"+i); arrayList.add(i); &#125; &#125;&#125; 输出结果表明两线程顺序执行。 synchronized 代码块123456789101112131415class InsertData &#123; private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); // private Object object = new Object(); public void insert(Thread thread)&#123; // 同步代码块 // this 代表获取当前对象的锁，也可以是类中的一个属性，代表获取该属性的锁。 // synchronized (object) &#123; synchronized (this) &#123; for(int i=0;i&lt;100;i++)&#123; System.out.println(thread.getName()+\"在插入数据\"+i); arrayList.add(i); &#125; &#125; &#125;&#125; 类锁 VS. 对象锁 另外，每个类也会有一个锁，它可以用来控制对 static 数据成员的并发访问。并且如果一个线程执行一个对象的非 static synchronized 方法，另外一个线程需要执行这个对象所属类的 static synchronized 方法，此时不会发生互斥现象，因为访问 static synchronized 方法占用的是类锁，而访问非 static synchronized 方法占用的是对象锁，所以不存在互斥现象。 Lock 接口 Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问； Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。 12345678public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try catch 块中进行，并且将释放锁的操作放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。 123456789Lock lock = ...;lock.lock();try&#123; // 处理任务&#125;catch(Exception ex)&#123; &#125;finally&#123; lock.unlock(); // 释放锁&#125; tryLock 方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回 true，如果获取失败（即锁已被其他线程获取），则返回 false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。 tryLock(long time, TimeUnit unit) 和 tryLock 方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。 123456789101112Lock lock = ...;if(lock.tryLock()) &#123; try&#123; // 处理任务 &#125;catch(Exception ex)&#123; &#125;finally&#123; lock.unlock(); // 释放锁 &#125; &#125; else &#123; // 如果不能获取锁，则直接做其他事情&#125; lockInterruptibly 方法比较特殊，当通过这个方法去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。也就使说，当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程 A 获取到了锁，而线程B只有继续等待，那么对线程 B 调用 threadB.interrupt() 能够中断线程 B的等待过程。 123456789public void method() throws InterruptedException &#123; lock.lockInterruptibly(); try &#123; // ... &#125; finally &#123; lock.unlock(); &#125; &#125; ReentrantLock 可重入锁的一种，后面详细介绍，先来看一下常用用法。 123456789101112131415161718192021222324252627282930313233// 错误案例public class Test &#123; public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.insert(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void insert(Thread thread) &#123; // 注意！！！这是一个局部变量 Lock lock = new ReentrantLock(); // 实例化一个 ReentrantLock 类型对象 // 每个线程执行到 lock.lock() 处获取的是不同的锁，此锁无效 lock.lock(); try &#123; System.out.println(thread.getName()+\"得到了锁\"); &#125; catch (Exception e) &#123; &#125;finally &#123; System.out.println(thread.getName()+\"释放了锁\"); lock.unlock(); &#125; &#125;&#125; 将 lock 声明为类的属性，即全局变量。 12345public class Test &#123; private Lock lock = new ReentrantLock(); // 全局变量 //...&#125; lockInterruptibly() 响应中断的使用方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public class Test &#123; // 全局变量 private Lock lock = new ReentrantLock(); public static void main(String[] args) &#123; Test test = new Test(); MyThread thread1 = new MyThread(test); MyThread thread2 = new MyThread(test); thread1.start(); thread2.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; thread2.interrupt(); &#125; public void insert(Thread thread) throws InterruptedException&#123; lock.lockInterruptibly(); // 线程 1 获得锁 线程 2 处于等待，并且将被打断等待 try &#123; System.out.println(thread.getName()+\"得到了锁\"); long startTime = System.currentTimeMillis(); for( ; ;) &#123; if(System.currentTimeMillis() - startTime &gt;= 10000) break; // 插入数据 &#125; &#125; finally &#123; System.out.println(Thread.currentThread().getName()+\"执行finally\"); lock.unlock(); System.out.println(thread.getName()+\"释放了锁\"); &#125; &#125;&#125;class MyThread extends Thread &#123; private Test test = null; public MyThread(Test test) &#123; this.test = test; &#125; @Override public void run() &#123; try &#123; test.insert(Thread.currentThread()); &#125; catch (InterruptedException e) &#123; System.out.println(Thread.currentThread().getName()+\"被中断\"); &#125; &#125;&#125; ReadWriteLock 接口 将文件的读写操作分开，分成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。 1234567public interface ReadWriteLock &#123; // 读锁 Lock readLock(); // 写锁 Lock writeLock();&#125; ReentrantReadWriteLock 实现了 ReadWriteLock 接口。 12345678910111213141516171819202122232425262728293031323334public class Test &#123; private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); public static void main(String[] args) &#123; final Test test = new Test(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); new Thread()&#123; public void run() &#123; test.get(Thread.currentThread()); &#125;; &#125;.start(); &#125; public void get(Thread thread) &#123; rwl.readLock().lock(); try &#123; long start = System.currentTimeMillis(); while(System.currentTimeMillis() - start &lt;= 1) &#123; System.out.println(thread.getName()+\"正在进行读操作\"); &#125; System.out.println(thread.getName()+\"读操作完毕\"); &#125; finally &#123; rwl.readLock().unlock(); &#125; &#125;&#125; 两线程同时进行读操作。 锁的种类 介绍与锁相关的几个概念。 可重入锁 如果说锁具备可重入性，那这个锁为可重入锁即基于线程的分配，而不是基于方法调用的分配。像 synchronized 和 ReentrantLock 都是可重入锁。 当一个线程执行到某个 synchronized 方法时，比如说 methodA，而在 methodA 中会调用另外一个 synchronized 方法 methodB，此时线程不必重新去申请锁，而是可以直接执行方法 methodB。因为可重入锁的分配是基于线程的，同一线程不必重新申请锁。 可中断锁 在 Java 中，synchronized 就不是可中断锁，而 Lock 是可中断锁。 公平锁 公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。 非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。 在 Java 中，synchronized 就是非公平锁，它无法保证等待的线程获取锁的顺序。而对于 ReentrantLock 和 ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。 读写锁 读写锁将对一个资源（比如文件）的访问分成了 2 个锁，一个读锁和一个写锁。正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"High Concurrency","slug":"High-Concurrency","permalink":"http://yoursite.com/tags/High-Concurrency/"}]},{"title":"Thread","slug":"Java/HighConcurrency/Thread","date":"2020-03-28T08:24:10.000Z","updated":"2020-04-19T06:30:05.388Z","comments":true,"path":"2020/03/28/Java/HighConcurrency/Thread/","link":"","permalink":"http://yoursite.com/2020/03/28/Java/HighConcurrency/Thread/","excerpt":"介绍线程相关知识以及 Java 中 Thread 类方法的具体使用。","text":"介绍线程相关知识以及 Java 中 Thread 类方法的具体使用。 线程的状态NEW (新建)：一个尚未启动的线程处于这一状态。 RUNNABLE (可运行) ：一个正在 Java 虚拟机中执行的线程处于这一状态。 处于 runnable 状态下的线程正在 Java 虚拟机中执行，但它可能正在等待来自于操作系统的其它资源，比如处理器。当进行阻塞式的 IO 操作时，或许底层的操作系统线程确实处在阻塞状态，但我们关心的是 JVM 的线程状态。JVM 把那些都视作资源，CPU 也好，硬盘，网卡也罢，有东西在为线程服务，它就认为线程在“执行”。如果 JVM 中的线程状态发生改变了，通常是自身机制引发的。 BLOCKED (阻塞) ：一个正在阻塞等待一个监视器锁的线程处于这一状态。 synchronize 机制有可能让线程进入 BLOCKED 状态。当因为获取不到锁而无法进入同步块时，线程处于 BLOCKED 状态。如果有线程长时间处于 BLOCKED 状态，要考虑是否发生了死锁（deadlock）的状况。BLOCKED 状态可以视作为一种特殊的 waiting，是传统 waiting 状态的一个细分。 WAITING (等待) ：一个正在无限期等待另一个线程执行一个特别的动作的线程处于这一状态。 wait / notify，join 方法进入 WATING 状态。其中 wait / notify 可用于协作关系：当条件不满足时调用 wait 释放锁，让补充条件的线程运行，但条件满足后由此补充线程唤醒，唤醒后原有线程处于阻塞队列等待取锁。wait(0)：无限等待。 TIMED_WAITING (计时等待) ：一个正在限时等待另一个线程执行一个动作的线程处于这一状态。 双保险：即使条件永远得不到满足，线程也会在规定时间后自我唤醒。调用 sleep 方法进入 TIMED_WAITING 状态，此状态不释放锁（与锁无关），只能等其自我唤醒。sleep(0)：几乎不等待。 TERMINATED (终止) ：一个已经退出的线程处于这一状态。 常用方法start 方法 start() 用来启动一个线程，当调用 start 方法后，系统才会开启一个新的线程来执行用户定义的子任务，在这个过程中，会为相应的线程分配需要的资源。 run 方法 run() 方法是不需要用户来调用的，当通过 start 方法启动一个线程之后，当线程获得了 CPU 执行时间，便进入 run 方法体去执行具体的任务。注意，继承 Thread 类必须重写 run 方法，在 run 方法中定义具体要执行的任务。 sleep 方法 sleep 方法相当于让线程睡眠，交出 CPU，让 CPU 去执行其他的任务。注意 sleep 方法与锁无关。 123456789101112131415161718192021222324252627282930313233public class Test &#123; private int i = 10; private Object object = new Object(); public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread1 = test.new MyThread(); MyThread thread2 = test.new MyThread(); thread1.start(); thread2.start(); // 等待上一个线程运行完同步代码块才可运行 &#125; class MyThread extends Thread&#123; @Override public void run() &#123; synchronized (object) &#123; i++; System.out.println(\"i:\"+i); try &#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"进入睡眠状态\"); Thread.currentThread().sleep(10000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println(\"线程\"+Thread.currentThread().getName()+\"睡眠结束\"); i++; System.out.println(\"i:\"+i); &#125; &#125; &#125;&#125; yield 方法 调用 yield 方法会让当前线程交出 CPU 权限，让 CPU 去执行其他的线程。它跟 sleep 方法类似，同样不会释放锁。但是 yield 不能控制具体的交出 CPU 的时间，另外，yield 方法只能让拥有相同优先级的线程有获取 CPU 执行时间的机会。 注意，调用 yield 方法并不会让线程进入阻塞状态，而是让线程重回就绪状态，它只需要等待重新获取 CPU 执行时间，这一点是和 sleep 方法不一样的。 join 方法 假如在 main 线程中，调用 thread.join 方法，则 main 方法会等待 thread 线程执行完毕或者等待一定的时间。如果调用的是无参 join 方法，则等待 thread 执行完毕，如果调用的是指定了时间参数的 join 方法，则等待一定的时间。 123456789101112131415161718192021222324252627282930public class Test &#123; public static void main(String[] args) throws IOException &#123; System.out.println(\"进入线程\"+Thread.currentThread().getName()); Test test = new Test(); MyThread thread1 = test.new MyThread(); thread1.start(); try &#123; System.out.println(\"线程\"+Thread.currentThread().getName()+\"等待\"); thread1.join(); System.out.println(\"线程\"+Thread.currentThread().getName()+\"继续执行\"); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(\"进入线程\"+Thread.currentThread().getName()); try &#123; Thread.currentThread().sleep(5000); &#125; catch (InterruptedException e) &#123; // TODO: handle exception &#125; System.out.println(\"线程\"+Thread.currentThread().getName()+\"执行完毕\"); &#125; &#125;&#125; interrupt 方法 单独调用 interrupt 方法可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程；另外，通过可以通过 interrupt 方法和 isInterrupted 方法来停止正在运行的线程。 12345678910111213141516171819202122232425262728public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); // 此线程睡眠 2s &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); // 阻塞状态中被打断，抛出异常 InterruptedException &#125; class MyThread extends Thread&#123; @Override public void run() &#123; try &#123; System.out.println(\"进入睡眠状态\"); Thread.currentThread().sleep(10000); System.out.println(\"睡眠完毕\"); &#125; catch (InterruptedException e) &#123; System.out.println(\"得到中断异常\"); &#125; System.out.println(\"run方法执行完毕\"); &#125; &#125;&#125; 上面的例子表明了 interrupt 方法可以中断处于阻塞状态的线程，那么能不能中断处于非阻塞状态的线程呢？答案是不能。但是如果配合 isInterrupted 方法能够中断正在运行的线程，因为调用 interrupt 方法相当于将中断标志位置为 true，那么可以通过调用 isInterrupted 方法判断中断标志是否被置位来中断线程的执行。 1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) throws IOException &#123; Test test = new Test(); MyThread thread = test.new MyThread(); thread.start(); try &#123; Thread.currentThread().sleep(2000); &#125; catch (InterruptedException e) &#123; &#125; thread.interrupt(); &#125; class MyThread extends Thread&#123; @Override public void run() &#123; int i = 0; // 不推荐这么用，可自定义一个标识符用于退出循环 while(!isInterrupted() &amp;&amp; i&lt;Integer.MAX_VALUE)&#123; System.out.println(i+\" while循环\"); i++; &#125; &#125; &#125;&#125; 线程属性getId()：获取线程 ID；getName()、setName()：设置、获取线程名称；getPriority()、setPriority()：设置、获取优先级；setDaemon()、isDaemon()：设置、判断守护进程；Thread 类有一个比较常用的静态方法 currentThread() 用来获取当前线程。 守护线程和用户线程的区别在于：守护线程依赖于创建它的线程，而用户线程则不依赖。举个简单的例子：如果在 main 线程中创建了一个守护线程，当 main 方法运行完毕之后，守护线程也会随着消亡。而用户线程则不会，用户线程会一直运行直到其运行完毕。在 JVM 中，像垃圾收集器线程就是守护线程。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"High Concurrency","slug":"High-Concurrency","permalink":"http://yoursite.com/tags/High-Concurrency/"}]},{"title":"线程与进程","slug":"Java/HighConcurrency/线程与进程","date":"2020-03-28T06:25:21.000Z","updated":"2020-03-28T08:22:27.976Z","comments":true,"path":"2020/03/28/Java/HighConcurrency/线程与进程/","link":"","permalink":"http://yoursite.com/2020/03/28/Java/HighConcurrency/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B/","excerpt":"Java 中的应用程序和进程相关的概念知识、阐述如何创建线程以及如何创建进程。","text":"Java 中的应用程序和进程相关的概念知识、阐述如何创建线程以及如何创建进程。 在 Java 中，一个应用程序对应着一个 JVM 实例。Java采用的是单线程编程模型，即在程序中如果没有主动创建线程的话，只会创建一个线程，通常称为主线程。但是要注意，虽然只有一个线程来执行任务，不代表 JVM 中只有一个线程，JVM 实例在创建的时候，同时会创建很多其他的线程（比如垃圾收集器线程）。 由于 Java 采用的是单线程编程模型，因此在进行 UI 编程时要注意将耗时的操作放在子线程中进行，以避免阻塞主线程（在UI编程时，主线程即UI线程，用来处理用户的交互事件）。 线程的创建 1）继承 Thread 类； 2）实现 Runnable 接口。 继承 Thread 类12345678910111213class MyThread extends Thread&#123; private static int num = 0; public MyThread()&#123; num++; &#125; @Override public void run() &#123; System.out.println(\"主动创建的第\"+num+\"个线程\"); &#125;&#125; 创建好了自己的线程类之后，就可以创建线程对象了，然后通过start()方法去启动线程。 123456public class Test &#123; public static void main(String[] args) &#123; MyThread thread = new MyThread(); // 创建一个子线程对象 thread.start(); // 运行子线程的 run() 方法 &#125;&#125; 注意，不是调用run()方法启动线程，run()方法中只是定义需要执行的任务，如果调用run()方法，即相当于在主线程中执行run()方法，跟普通的方法调用没有任何区别，此时并不会创建一个新的线程来执行定义的任务。 123456789101112131415161718192021222324// 错误案例public class Test &#123; public static void main(String[] args) &#123; System.out.println(\"主线程ID:\"+Thread.currentThread().getId()); // 获取主线程的 ID MyThread thread01 = new MyThread(\"Thread01\"); thread01.start(); // 正确调用，开启子线程运行 run() 方法 MyThread thread02 = new MyThread(\"Thread02\"); thread02.run(); // 错误调用，运行主程序的 run() 方法 &#125;&#125; class MyThread extends Thread&#123; private String name; public MyThread(String name)&#123; this.name = name; &#125; @Override public void run() &#123; System.out.println(\"name:\"+name+\" 子线程ID:\"+Thread.currentThread().getId()); &#125;&#125; 实现 Runnable 接口Runnable 的中文意思是”任务“，顾名思义，通过实现 Runnable 接口，我们定义了一个子任务，然后将子任务交由 Thread 去执行。注意，这种方式必须将 Runnable 作为 Thread 类的参数，然后通过 Thread 的start()方法来创建一个新线程来执行该子任务。如果调用 Runnable 的run()方法的话，是不会创建新线程的，这根普通的方法调用没有任何区别。 123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123; System.out.println(\"主线程ID：\"+Thread.currentThread().getId()); MyRunnable runnable = new MyRunnable(); Thread thread = new Thread(runnable); // 将任务 Runnable 交由 Thread 处理 thread.start(); &#125;&#125; class MyRunnable implements Runnable&#123; public MyRunnable() &#123; &#125; @Override public void run() &#123; System.out.println(\"子线程ID：\"+Thread.currentThread().getId()); &#125;&#125; Thread VS. Runnable 事实上，查看 Thread 类的实现源代码会发现 Thread 类是实现了 Runnable 接口的。 在 Java 中，这两种方式都可以用来创建线程去执行子任务，具体选择哪一种方式要看自己的需求。直接继承 Thread 类的话，可能比实现 Runnable 接口看起来更加简洁，但是由于 Java 只允许单继承，所以如果自定义类需要继承其他类，则只能选择实现 Runnable 接口。 进程的创建 1）通过 Runtime.exec() 方法来； 2）通过 ProcessBuilder 的 start() 方法。 首先要讲的是 Process 类，Process 类是一个抽象类，在它里面主要有几个抽象的方法。 12345678910// java.lang.Processpublic abstract class Process &#123; abstract public OutputStream getOutputStream(); // 获取进程的输出流 abstract public InputStream getInputStream(); // 获取进程的输入流 abstract public InputStream getErrorStream(); // 获取进程的错误流 abstract public int waitFor() throws InterruptedException; // 让进程等待 abstract public int exitValue(); // 获取进程的退出标志 abstract public void destroy(); // 摧毁进程&#125; ProcessBuilderProcessBuilder 是一个 final 类，它有两个构造器。 123456789101112131415161718192021public final class ProcessBuilder &#123; private List&lt;String&gt; command; private File directory; private Map&lt;String,String&gt; environment; private boolean redirectErrorStream; // 传递创建进程需要的命令参数 public ProcessBuilder(List&lt;String&gt; command) &#123; if (command == null) throw new NullPointerException(); this.command = command; &#125; // 不定长字符串的形式 public ProcessBuilder(String... command) &#123; this.command = new ArrayList&lt;String&gt;(command.length); for (String arg : command) this.command.add(arg); &#125; // ....&#125; 通过 ProcessBuilder 来启动一个进程打开 cmd，并获取 ip 地址信息。 123456789101112public class Test &#123; public static void main(String[] args) throws IOException &#123; ProcessBuilder pb = new ProcessBuilder(\"cmd\",\"/c\",\"ipconfig/all\"); // 也可以是一个 List Process process = pb.start(); Scanner scanner = new Scanner(process.getInputStream()); while(scanner.hasNextLine())&#123; System.out.println(scanner.nextLine()); &#125; scanner.close(); &#125;&#125; Runtime.exec()由于任何进程只会运行于一个虚拟机实例当中，所以在Runtime中采用了单例模式，即只会产生一个虚拟机实例. 12345678910111213141516171819public class Runtime &#123; private static Runtime currentRuntime = new Runtime(); public static Runtime getRuntime() &#123; return currentRuntime; &#125; private Runtime() &#123;&#125; // ... public Process exec(String[] cmdarray, String[] envp, File dir) // 所有实现的最终实现 throws IOException &#123; return new ProcessBuilder(cmdarray) // 调用 ProcessBuilder 进行实现 .environment(envp) .directory(dir) .start(); &#125;&#125; 通过 Runtime.exec() 来启动一个进程打开 cmd，并获取 ip 地址信息。 123456789101112public class Test &#123; public static void main(String[] args) throws IOException &#123; String cmd = \"cmd \"+\"/c \"+\"ipconfig/all\"; // 不支持不定长参数，必须进行拼接 Process process = Runtime.getRuntime().exec(cmd); Scanner scanner = new Scanner(process.getInputStream()); while(scanner.hasNextLine())&#123; System.out.println(scanner.nextLine()); &#125; scanner.close(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"High Concurrency","slug":"High-Concurrency","permalink":"http://yoursite.com/tags/High-Concurrency/"}]},{"title":"行为型模式","slug":"Java/DesignPatterns/行为型模式","date":"2020-03-24T08:30:21.000Z","updated":"2020-04-19T06:27:11.986Z","comments":true,"path":"2020/03/24/Java/DesignPatterns/行为型模式/","link":"","permalink":"http://yoursite.com/2020/03/24/Java/DesignPatterns/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式之行为型模式。","text":"设计模式之行为型模式。 模板方法模式 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Client &#123; public static void main(String[] args) &#123; // 制作红豆豆浆 System.out.println(\"---制作红豆豆浆---\"); SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk(); redBeanSoyaMilk.make(); System.out.println(\"---制作花生豆浆---\"); SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk(); peanutSoyaMilk.make(); &#125;&#125;// 抽象类，表示豆浆public abstract class SoyaMilk &#123; // final 类型的模板方法：防止子类覆盖 final void make() &#123; select(); addCondiments(); soak(); beat(); &#125; // 选材料 void select() &#123; System.out.println(\"第一步：选择好的新鲜黄豆\"); &#125; // 添加不同的配料：抽象方法由子类具体实现 abstract void addCondiments(); // 浸泡 void soak() &#123; System.out.println(\"第三步：黄豆和配料开始浸泡（3小时）\"); &#125; void beat() &#123; System.out.println(\"第四步：黄豆和配料放到豆浆机去打碎\"); &#125;&#125;public class PeanutSoyaMilk extends SoyaMilk &#123; @Override void addCondiments() &#123; System.out.println(\" 加入上好的花生 \"); &#125;&#125;public class RedBeanSoyaMilk extends SoyaMilk &#123; @Override void addCondiments() &#123; System.out.println(\" 加入上好的红豆 \"); &#125;&#125; 钩子方法1234567891011121314151617181920212223242526272829/抽象类，表示豆浆 public abstract class SoyaMilk &#123; final void make() &#123; select(); // 钩子 if(customerWantCondiments()) &#123; addCondiments(); &#125; soak(); beat(); &#125; // 选材料 void select() &#123; System.out.println(\"第一步：选择好的新鲜黄豆\"); &#125; // 钩子：添加不同的配料：抽象方法由子类具体实现 abstract void addCondiments(); // 浸泡 void soak() &#123; System.out.println(\"第三步：黄豆和配料开始浸泡（3小时）\"); &#125; void beat() &#123; System.out.println(\"第四步：黄豆和配料放到豆浆机去打碎\"); &#125; // 钩子方法：决定是否需要添加配料 boolean customerWantCondiments() &#123; return true; &#125; &#125; Spring 命令模式 命令模式（Command Pattern）：在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计。 命名模式使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活，实现解耦。请求发起者和请求执行者之间的解耦是通过命令对象实现的，命令对象起到了纽带桥梁的作用。 在命名模式中，会将一个请求封装为一个对象，以便使用不同参数来表示不同的请求(即命名)，同时命令模式也支持可撤销的操作。 空命令也是一种设计模式，它为我们省去了判空的操作。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128public class Client &#123; public static void main(String[] args) &#123; // 使用命令设计模式，完成通过遥控器对电灯进行操作 // 创建电灯的对象：接受者 LightReceiver lightReceiver = new LightReceiver(); // 创建电灯相关的开关命令 LightOnCommand lightOnCommand = new LightOnCommand(lightReceiver); LightOffCommand lightOffCommand = new LightOffCommand(lightReceiver); // 需要一个遥控器：调用者 RemoteController remoteController = new RemoteController(); // 给我们的遥控器设置命令, 比如 no = 0 是电灯的开和关的操作 remoteController.setCommand(0, lightOnCommand, lightOffCommand); System.out.println(\"---按下灯的开按钮---\"); remoteController.onButtonWasPushed(0); System.out.println(\"---按下灯的关按钮---\"); remoteController.offButtonWasPushed(0); System.out.println(\"---按下撤销按钮---\"); remoteController.undoButtonWasPushed(); &#125;&#125;// 创建命令接口public interface Command &#123; // 执行动作(操作) public void execute(); // 撤销动作(操作) public void undo();&#125;// 接收者public class LightReceiver &#123; public void on() &#123; System.out.println(\" 电灯打开了... \"); &#125; public void off() &#123; System.out.println(\" 电灯关闭了... \"); &#125;&#125;// 电灯操作命令具体实现public class LightOffCommand implements Command &#123; // 聚合 LightReceiver：接收者 LightReceiver light; // 构造器 public LightOffCommand(LightReceiver light) &#123; super(); this.light = light; &#125; @Override public void execute() &#123; // 调用接收者的方法 light.off(); &#125; @Override public void undo() &#123; // 调用接收者的方法 light.on(); &#125;&#125;public class LightOnCommand implements Command &#123; // 聚合 LightReceiver LightReceiver light; // 构造器 public LightOnCommand(LightReceiver light) &#123; super(); this.light = light; &#125; @Override public void execute() &#123; // 调用接收者的方法 light.on(); &#125; @Override public void undo() &#123; // 调用接收者的方法 light.off(); &#125;&#125;// 空命令模式public class NoCommand implements Command &#123; @Override public void execute() &#123; &#125; @Override public void undo() &#123; &#125;&#125;public class RemoteController &#123; // 开按钮的命令数组 Command[] onCommands; Command[] offCommands; // 执行撤销的命令 Command undoCommand; // 构造器，完成对按钮初始化 public RemoteController() &#123; onCommands = new Command[5]; offCommands = new Command[5]; for (int i = 0; i &lt; 5; i++) &#123; onCommands[i] = new NoCommand(); offCommands[i] = new NoCommand(); &#125; &#125; // 给我们的按钮设置你需要的命令 public void setCommand(int no, Command onCommand, Command offCommand) &#123; onCommands[no] = onCommand; offCommands[no] = offCommand; &#125; // 按下开按钮 public void onButtonWasPushed(int no) &#123; // no 0 // 找到你按下的开的按钮， 并调用对应方法 onCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = onCommands[no]; &#125; // 按下开按钮 public void offButtonWasPushed(int no) &#123; // no 0 // 找到你按下的关的按钮， 并调用对应方法 offCommands[no].execute(); // 记录这次的操作，用于撤销 undoCommand = offCommands[no]; &#125; // 按下撤销按钮 public void undoButtonWasPushed() &#123; undoCommand.undo(); &#125;&#125; 访问者模式 访问者模式（Visitor Pattern），封装一些作用于某种数据结构的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。 主要将数据结构与数据操作分离，解决数据结构和操作耦合性问题，其基本原理是在被访问的类里面加一个对外提供接待访问者的接口。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495public class Client &#123; public static void main(String[] args) &#123; // 创建 ObjectStructure：枚举元素，用来允许访问者访问元素 ObjectStructure objectStructure = new ObjectStructure(); // 双分派：1.分派访问者 objectStructure.attach(new Man()); objectStructure.attach(new Woman()); // 成功 2.根据访问者分发任务 Success success = new Success(); objectStructure.display(success); System.out.println(\"=======\"); Fail fail = new Fail(); objectStructure.display(fail); System.out.println(\"===待定测评===\"); Wait wait = new Wait(); objectStructure.display(wait); &#125;&#125;// 数据结构，管理 Man Womanpublic class ObjectStructure &#123; // 维护了一个集合 private List&lt;Person&gt; persons = new LinkedList&lt;&gt;(); // 增加 Element public void attach(Person p) &#123; persons.add(p); &#125; // 移除 Element public void detach(Person p) &#123; persons.remove(p); &#125; // 显示测评情况 public void display(Action action) &#123; for(Person p: persons) &#123; p.accept(action); &#125; &#125;&#125;// Elementpublic abstract class Person &#123; public abstract void accept(Action action);&#125;public class Man extends Person &#123; @Override public void accept(Action action) &#123; action.getManResult(this); &#125;&#125;public class Woman extends Person&#123; @Override public void accept(Action action) &#123; action.getWomanResult(this); &#125;&#125;// Visitor：为 Element 提供具体操作public abstract class Action &#123; // 男性评价 public abstract void getManResult(Man man); // 女性评价 public abstract void getWomanResult(Woman woman);&#125;public class Success extends Action &#123; @Override public void getManResult(Man man) &#123; System.out.println(\" 男人给好评 !\"); &#125; @Override public void getWomanResult(Woman woman) &#123; System.out.println(\" 女人给好评 !\"); &#125;&#125;public class Fail extends Action &#123; @Override public void getManResult(Man man) &#123; System.out.println(\" 男人给差评 !\"); &#125; @Override public void getWomanResult(Woman woman) &#123; System.out.println(\" 女人给差评 !\"); &#125;&#125;public class Wait extends Action &#123; @Override public void getManResult(Man man) &#123; System.out.println(\" 男人给的评价是该歌手待定 \"); &#125; @Override public void getWomanResult(Woman woman) &#123; System.out.println(\" 女人给的评价是该歌手待定 \"); &#125;&#125; 迭代器模式 迭代器模式，提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示，即：不暴露其内部的结构。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163public class Client &#123; public static void main(String[] args) &#123; // 创建学院 List&lt;College&gt; collegeList = new ArrayList&lt;College&gt;(); ComputerCollege computerCollege = new ComputerCollege(); InfoCollege infoCollege = new InfoCollege(); collegeList.add(computerCollege); collegeList.add(infoCollege); OutPutImpl outPutImpl = new OutPutImpl(collegeList); outPutImpl.printCollege(); &#125;&#125;// 接口public interface College &#123; public String getName(); // 添加系 public void addDepartment(String name, String desc); // 返回一个迭代器 public Iterator createIterator();&#125;// 系public class Department &#123; private String name; private String desc; public Department(String name, String desc) &#123; super(); this.name = name; this.desc = desc; &#125; // Getter / Setter&#125;public class ComputerCollege implements College &#123; Department[] departments; int numOfDepartment = 0 ; // 保存当前数组的对象个数 public ComputerCollege() &#123; departments = new Department[5]; addDepartment(\"Java 专业\", \" Java 专业 \"); addDepartment(\"PHP 专业\", \" PHP 专业 \"); addDepartment(\"大数据专业\", \" 大数据专业 \"); &#125; @Override public String getName() &#123; return \"计算机学院\"; &#125; @Override public void addDepartment(String name, String desc) &#123; Department department = new Department(name, desc); departments[numOfDepartment] = department; numOfDepartment += 1; &#125; @Override public Iterator createIterator() &#123; // 实现了数据共享 return new ComputerCollegeIterator(departments); &#125;&#125;public class ComputerCollegeIterator implements Iterator &#123; Department[] departments; int position = 0; // 遍历的位置 public ComputerCollegeIterator(Department[] departments) &#123; this.departments = departments; &#125; //判断是否还有下一个元素 @Override public boolean hasNext() &#123; if(position &gt;= departments.length || departments[position] == null) &#123; return false; &#125;else &#123; return true; &#125; &#125; @Override public Object next() &#123; Department department = departments[position]; position += 1; return department; &#125; // 删除的方法，默认空实现 public void remove() &#123; &#125;&#125;public class InfoCollege implements College &#123; List&lt;Department&gt; departmentList; public InfoCollege() &#123; departmentList = new ArrayList&lt;Department&gt;(); addDepartment(\"信息安全专业\", \" 信息安全专业 \"); addDepartment(\"网络安全专业\", \" 网络安全专业 \"); addDepartment(\"服务器安全专业\", \" 服务器安全专业 \"); &#125; @Override public String getName() &#123; // TODO Auto-generated method stub return \"信息工程学院\"; &#125; @Override public void addDepartment(String name, String desc) &#123; // TODO Auto-generated method stub Department department = new Department(name, desc); departmentList.add(department); &#125; @Override public Iterator createIterator() &#123; return new InfoColleageIterator(departmentList); &#125;&#125;public class InfoColleageIterator implements Iterator &#123; List&lt;Department&gt; departmentList; // 信息工程学院是以 List 方式存放系 int index = -1; // 索引 public InfoColleageIterator(List&lt;Department&gt; departmentList) &#123; this.departmentList = departmentList; &#125; // 判断 list 中还有没有下一个元素 @Override public boolean hasNext() &#123; if(index &gt;= departmentList.size() - 1) &#123; return false; &#125; else &#123; index += 1; return true; &#125; &#125; @Override public Object next() &#123; return departmentList.get(index); &#125; // 默认 public void remove() &#123; &#125;&#125;public class OutPutImpl &#123; // 学院集合 List&lt;College&gt; collegeList; public OutPutImpl(List&lt;College&gt; collegeList) &#123; this.collegeList = collegeList; &#125; // 遍历所有学院,然后调用 printDepartment 输出各个学院的系 public void printCollege() &#123; // 从 collegeList 取出所有学院, Java 中的 List 已经实现 Iterator Iterator&lt;College&gt; iterator = collegeList.iterator(); while(iterator.hasNext()) &#123; // 取出一个学院 College college = iterator.next(); System.out.println(\"=== \"+college.getName() +\"====\" ); printDepartment(college.createIterator()); // 得到对应迭代器 &#125; &#125; // 输出学院，输出系 public void printDepartment(Iterator iterator) &#123; while(iterator.hasNext()) &#123; Department d = (Department)iterator.next(); System.out.println(d.getName()); &#125; &#125;&#125; JDK-ArrayList 提供了一种设计思想，就是一个类应该只有一个引起变化的原因（叫做单一责任原则）。在聚合类中，我们把迭代器分开，就是要把管理对象集合和遍历对象集合的责任分开，这样一来集合改变的话，只影响到聚合对象。而如果遍历方式改变的话，只影响到了迭代器。 观察者模式 观察者模式：对象之间多对一依赖的一种设计方案，被依赖的对象为 Subject，依赖的对象为 Observer，Subject通知 Observer 变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class Client &#123; public static void main(String[] args) &#123; // 创建一个 WeatherData WeatherData weatherData = new WeatherData(); // 创建观察者 CurrentConditions currentConditions = new CurrentConditions(); BaiduSite baiduSite = new BaiduSite(); // 注册到 weatherData weatherData.registerObserver(currentConditions); weatherData.registerObserver(baiduSite); // 测试 System.out.println(\"通知各个注册的观察者, 看看信息\"); weatherData.setData(10f, 100f, 30.3f); weatherData.removeObserver(currentConditions); // 测试 System.out.println(); System.out.println(\"通知各个注册的观察者, 看看信息\"); weatherData.setData(10f, 100f, 30.3f); &#125;&#125;// 观察者接口public interface Observer &#123; public void update(float temperature, float pressure, float humidity);&#125;public class BaiduSite implements Observer &#123; // 温度，气压，湿度 private float temperature; private float pressure; private float humidity; // 更新天气情况：WeatherData 调用（推送模式） public void update(float temperature, float pressure, float humidity) &#123; this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); &#125; // 显示 public void display() &#123; System.out.println(\"===百度网站===\"); System.out.println(\"***百度网站 气温 : \" + temperature + \"***\"); System.out.println(\"***百度网站 气压: \" + pressure + \"***\"); System.out.println(\"***百度网站 湿度: \" + humidity + \"***\"); &#125;&#125;public class CurrentConditions implements Observer &#123; private float temperature; private float pressure; private float humidity; public void update(float temperature, float pressure, float humidity) &#123; this.temperature = temperature; this.pressure = pressure; this.humidity = humidity; display(); &#125; public void display() &#123; System.out.println(\"***Today Temperature: \" + temperature + \"***\"); System.out.println(\"***Today Pressure: \" + pressure + \"***\"); System.out.println(\"***Today Humidity: \" + humidity + \"***\"); &#125;&#125;// 接口, 让 WeatherData 来实现public interface Subject &#123; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObservers();&#125;/*** 核心类* 1. 包含最新的天气情况信息* 2. 含有观察者集合，使用 ArrayList 管理* 3. 当数据有更新时，就主动的调用 ArrayList, 通知所有的（接入方：观察者）就看到最新的信息*/public class WeatherData implements Subject &#123; private float temperatrue; private float pressure; private float humidity; // 观察者集合 private ArrayList&lt;Observer&gt; observers; // 加入新的第三方 public WeatherData() &#123; observers = new ArrayList&lt;Observer&gt;(); &#125; public float getTemperature() &#123; return temperatrue; &#125; public float getPressure() &#123; return pressure; &#125; public float getHumidity() &#123; return humidity; &#125; public void dataChange() &#123; // 调用接入方的 update notifyObservers(); &#125; // 当数据有更新时，就调用 setData public void setData(float temperature, float pressure, float humidity) &#123; this.temperatrue = temperature; this.pressure = pressure; this.humidity = humidity; // 调用 dataChange， 将最新的信息推送给接入方 currentConditions dataChange(); &#125; // 注册一个观察者 @Override public void registerObserver(Observer o) &#123; observers.add(o); &#125; // 移除一个观察者 @Override public void removeObserver(Observer o) &#123; if(observers.contains(o)) &#123; observers.remove(o); &#125; &#125; // 遍历所有的观察者，并通知 @Override public void notifyObservers() &#123; for(int i = 0; i &lt; observers.size(); i++) &#123; observers.get(i).update(this.temperatrue, this.pressure, this.humidity); &#125; &#125;&#125; 观察者模式设计后，会以集合的方式来管理用户(Observer)，包括注册，移除和通知。这样，我们增加观察者（这里可以理解成一个新的公告板）就不需要去修改核心类 WeatherData 不会修改代码，遵守了 OCP 原则。 中介模式 中介者模式（Mediator Pattern），用一个中介对象来封装一系列的对象交互。中介者使各个对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 比如 MVC 模式，C（Controller 控制器）是 M（Model 模型）和 V（View 视图）的中介者，在前后端交互时起到了中间人的作用。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155public class ClientTest &#123; public static void main(String[] args) &#123; // 创建一个中介者对象 Mediator mediator = new ConcreteMediator(); // 创建 Alarm 并且加入到 ConcreteMediator 对象的 HashMap Alarm alarm = new Alarm(mediator, \"alarm\"); // 创建了 CoffeeMachine 对象，并 且加入到 ConcreteMediator 对象的 HashMap CoffeeMachine coffeeMachine = new CoffeeMachine(mediator, \"coffeeMachine\"); // 创建 Curtains , 并且加入到 ConcreteMediator 对象的 HashMap Curtains curtains = new Curtains(mediator, \"curtains\"); TV tV = new TV(mediator, \"TV\"); // 让闹钟发出消息 alarm.SendAlarm(0); coffeeMachine.FinishCoffee(); alarm.SendAlarm(1); &#125;&#125;// 同事抽象类public abstract class Colleague &#123; // 所有的同事都知道中介 private Mediator mediator; public String name; public Colleague(Mediator mediator, String name) &#123; this.mediator = mediator; this.name = name; &#125; public Mediator GetMediator() &#123; return this.mediator; &#125; public abstract void SendMessage(int stateChange);&#125;// 具体的同事类public class Alarm extends Colleague &#123; // 构造器 public Alarm(Mediator mediator, String name) &#123; super(mediator, name); // 在创建 Alarm 同事对象时，将自己注册到 ConcreteMediator 对象中[集合] mediator.Register(name, this); &#125; public void SendAlarm(int stateChange) &#123; SendMessage(stateChange); &#125; @Override public void SendMessage(int stateChange) &#123; // 调用的中介者对象的 getMessage this.GetMediator().GetMessage(stateChange, this.name); &#125;&#125;public class CoffeeMachine extends Colleague &#123; public CoffeeMachine(Mediator mediator, String name) &#123; super(mediator, name); mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125; public void StartCoffee() &#123; System.out.println(\"It's time to startcoffee!\"); &#125; public void FinishCoffee() &#123; System.out.println(\"After 5 minutes!\"); System.out.println(\"Coffee is ok!\"); SendMessage(0); &#125;&#125;public class TV extends Colleague &#123; public TV(Mediator mediator, String name) &#123; super(mediator, name); mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125; public void StartTv() &#123; System.out.println(\"It's time to StartTv!\"); &#125; public void StopTv() &#123; System.out.println(\"StopTv!\"); &#125;&#125;public class Curtains extends Colleague &#123; public Curtains(Mediator mediator, String name) &#123; super(mediator, name); mediator.Register(name, this); &#125; @Override public void SendMessage(int stateChange) &#123; this.GetMediator().GetMessage(stateChange, this.name); &#125; public void UpCurtains() &#123; System.out.println(\"I am holding Up Curtains!\"); &#125;&#125;public abstract class Mediator &#123; // 将给中介者对象加入到集合中 public abstract void Register(String colleagueName, Colleague colleague); // 接收消息：由具体的同事对象发出 public abstract void GetMessage(int stateChange, String colleagueName); public abstract void SendMessage();&#125;// 具体的中介者类public class ConcreteMediator extends Mediator &#123; // 集合：放入所有的同事对象 private HashMap&lt;String, Colleague&gt; colleagueMap; private HashMap&lt;String, String&gt; interMap; public ConcreteMediator() &#123; colleagueMap = new HashMap&lt;String, Colleague&gt;(); interMap = new HashMap&lt;String, String&gt;(); &#125; @Override public void Register(String colleagueName, Colleague colleague) &#123; colleagueMap.put(colleagueName, colleague); if (colleague instanceof Alarm) &#123; // 限定了每种类型机器的数量只能有一个：最新注册的机器 interMap.put(\"Alarm\", colleagueName); &#125; else if (colleague instanceof CoffeeMachine) &#123; interMap.put(\"CoffeeMachine\", colleagueName); &#125; else if (colleague instanceof TV) &#123; interMap.put(\"TV\", colleagueName); &#125; else if (colleague instanceof Curtains) &#123; interMap.put(\"Curtains\", colleagueName); &#125; &#125; // 具体中介者的核心方法 // 1. 根据得到消息，完成对应任务 // 2. 中介者在这个方法，协调各个具体的同事对象，完成任务 @Override public void GetMessage(int stateChange, String colleagueName) &#123; //处理闹钟发出的消息 if (colleagueMap.get(colleagueName) instanceof Alarm) &#123; if (stateChange == 0) &#123; ((CoffeeMachine) (colleagueMap.get(interMap.get(\"CoffeeMachine\")))).StartCoffee(); ((TV) (colleagueMap.get(interMap.get(\"TV\")))).StartTv(); &#125; else if (stateChange == 1) &#123; ((TV) (colleagueMap.get(interMap.get(\"TV\")))).StopTv(); &#125; &#125; else if (colleagueMap.get(colleagueName) instanceof CoffeeMachine) &#123; ((Curtains) (colleagueMap.get(interMap.get(\"Curtains\")))).UpCurtains(); &#125; else if (colleagueMap.get(colleagueName) instanceof TV) &#123; // 如果 TV 发现消息 &#125; else if (colleagueMap.get(colleagueName) instanceof Curtains) &#123; // 如果 Curtain 发现消息&#125; @Override public void SendMessage() &#123; &#125; &#125;&#125; 备忘录模式 备忘录模式（Memento Pattern）在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class Client &#123; public static void main(String[] args) &#123; // 创建游戏角色 GameRole gameRole = new GameRole(); gameRole.setVit(100); gameRole.setDef(100); System.out.println(\"和 Boss 大战前的状态\"); gameRole.display(); // 把当前状态保存 caretaker：看守者 Caretaker caretaker = new Caretaker(); caretaker.setMemento(gameRole.createMemento()); System.out.println(\"和 Boss 大战后\"); gameRole.setDef(30); gameRole.setVit(30); gameRole.display(); System.out.println(\"大战后，使用备忘录对象恢复到战斗前\"); gameRole.recoverGameRoleFromMemento(caretaker.getMemento()); System.out.println(\"恢复后的状态\"); gameRole.display(); &#125;&#125;// 守护者对象, 保存游戏角色的状态public class Caretaker &#123; // 如果只保存一次状态 private Memento memento; // 对 GameRole 保存多次状态 // private ArrayList&lt;Memento&gt; mementos; // 对多个游戏角色保存多个状态 // private HashMap&lt;String, ArrayList&lt;Memento&gt;&gt; rolesMementos; public Memento getMemento() &#123; return memento; &#125; public void setMemento(Memento memento) &#123; this.memento = memento; &#125;&#125;public class Memento &#123; private int vit; private int def; public Memento(int vit, int def) &#123; super(); this.vit = vit; this.def = def; &#125; // Getter / Setter&#125;public class GameRole &#123; private int vit; private int def; // 创建 Memento：即根据当前的状态得到 Memento public Memento createMemento() &#123; return new Memento(vit, def); &#125; // 备忘录对象恢复 GameRole 的状态 public void recoverGameRoleFromMemento(Memento memento) &#123; this.vit = memento.getVit(); this.def = memento.getDef(); &#125; // 显示当前游戏角色的状态 public void display() &#123; System.out.println(\"游戏角色当前的攻击力：\" + this.vit + \" 防御力: \" + this.def); &#125; // Getter / Setter&#125; 解释器模式 给定一个语言（表达式），定义它的文法的一种表示，并定义一个解释器，使用该解释器来解释语言中的句子（表达式）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129public class ClientTest &#123; public static void main(String[] args) throws IOException &#123; String expStr = getExpStr(); // a+b HashMap&lt;String, Integer&gt; var = getValue(expStr); // var &#123;a=10, b=20&#125; Calculator calculator = new Calculator(expStr); System.out.println(\"运算结果：\" + expStr + \"=\" + calculator.run(var)); &#125; // 获得表达式 public static String getExpStr() throws IOException &#123; System.out.print(\"请输入表达式：\"); return (new BufferedReader(new InputStreamReader(System.in))).readLine(); &#125; // 获得值映射 public static HashMap&lt;String, Integer&gt; getValue(String expStr) throws IOException &#123; HashMap&lt;String, Integer&gt; map = new HashMap&lt;&gt;(); for (char ch : expStr.toCharArray()) &#123; if (ch != '+' &amp;&amp; ch != '-') &#123; if (!map.containsKey(String.valueOf(ch))) &#123; System.out.print(\"请输入\" + String.valueOf(ch) + \"的值：\"); String in = (new BufferedReader(new InputStreamReader(System.in))).readLine(); map.put(String.valueOf(ch), Integer.valueOf(in)); &#125; &#125; &#125; return map; &#125;&#125;public class Calculator &#123; // 定义表达式 private Expression expression; // 构造函数传参，并解析 public Calculator(String expStr) &#123; // expStr = a+b // 安排运算先后顺序 Stack&lt;Expression&gt; stack = new Stack&lt;&gt;(); // 表达式拆分成字符数组 char[] charArray = expStr.toCharArray();// [a, +, b] Expression left = null; Expression right = null; // 遍历我们的字符数组， 即遍历 [a, +, b] // 针对不同的情况，做处理 for (int i = 0; i &lt; charArray.length; i++) &#123; switch (charArray[i]) &#123; case '+': left = stack.pop(); // 从 stack 取出 left =&gt; \"a\" right = new VarExpression(String.valueOf(charArray[++i])); // 取出右表达式 \"b\" stack.push(new AddExpression(left, right)); // 然后根据得到 left 和 right 构建 AddExpresson 加入 stack break; case '-': left = stack.pop(); right = new VarExpression(String.valueOf(charArray[++i])); stack.push(new SubExpression(left, right)); break; default: // 如果是一个 Var 就创建要给 VarExpression 对象，并 push 到 stack stack.push(new VarExpression(String.valueOf(charArray[i]))); break; &#125; &#125; // 当遍历完整个 charArray 数组后，stack 就得到最后 Expression this.expression = stack.pop(); &#125; public int run(HashMap&lt;String, Integer&gt; var) &#123; // 最后将表达式 a+b 和 var = &#123;a=10,b=20&#125; // 然后传递给 expression 的 interpreter 进行解释执行 return this.expression.interpreter(var); &#125;&#125;// 抽象类表达式，通过 HashMap 键值对, 可以获取到变量的值public abstract class Expression &#123; // a + b - c // 解释公式和数值, key 就是公式，参数[a,b,c], value 就是就是具体值 // HashMap &#123;a=10, b=20&#125; public abstract int interpreter(HashMap&lt;String, Integer&gt; var);&#125;// 变量的解释器public class VarExpression extends Expression &#123; private String key; // key=a,key=b,key=c public VarExpression(String key) &#123; this.key = key; &#125; // &#123;a=10, b=20&#125; // interpreter 根据变量名称，返回对应值 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return var.get(this.key); &#125;&#125;// 抽象运算符号解析器 这里，每个运算符号，都只和自己左右两个数字有关系，// 但左右两个数字有可能也是一个解析的结果，无论何种类型，都是 Expression 类的实现类public class SymbolExpression extends Expression &#123; protected Expression left; protected Expression right; public SymbolExpression(Expression left, Expression right) &#123; this.left = left; this.right = right; &#125; // 因为 SymbolExpression 是让其子类来实现，因此 interpreter 是一个默认实现 @Override public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return 0; &#125;&#125;public class SubExpression extends SymbolExpression &#123; public SubExpression(Expression left, Expression right) &#123; super(left, right); &#125; // 求出 left 和 right 表达式相减后的结果 public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; return super.left.interpreter(var) - super.right.interpreter(var); &#125;&#125;public class AddExpression extends SymbolExpression &#123; public AddExpression(Expression left, Expression right) &#123; super(left, right); &#125; // &#123;a=10,b=20&#125; public int interpreter(HashMap&lt;String, Integer&gt; var) &#123; //super.left.interpreter(var) ： 返回 left 表达式对应的值 a = 10 //super.right.interpreter(var): 返回 right 表达式对应值 b = 20 return super.left.interpreter(var) + super.right.interpreter(var); &#125;&#125; 状态模式 主要用来解决对象在多种状态转换时，需要对外输出不同的行为的问题。状态和行为是相对应的，状态之间可以相互转换。当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181public class ClientTest &#123; public static void main(String[] args) &#123; // 创建活动对象，奖品有 1 个奖品 RaffleActivity activity = new RaffleActivity(1); // 我们连续抽 300 次奖 for (int i = 0; i &lt; 30; i++) &#123; System.out.println(\"---第\" + (i + 1) + \"次抽奖---\"); // 参加抽奖，第一步点击扣除积分 activity.debuctMoney(); // 第二步抽奖 activity.raffle(); &#125; &#125;&#125;// 抽奖活动// 传入不同的状态进行调用public class RaffleActivity &#123; // state 表示活动当前的状态，是变化 State state = null; // 奖品数量 int count = 0; // 四个属性，表示活动的四种状态 State noRafflleState = new NoRaffleState(this); State canRaffleState = new CanRaffleState(this); State dispenseState = new DispenseState(this); State dispensOutState = new DispenseOutState(this); //构造器 // 1.初始化当前的状态为 noRafflleState（即不能抽奖的状态） // 2.初始化奖品的数量 public RaffleActivity(int count) &#123; this.state = getNoRafflleState(); this.count = count; &#125; // 扣分, 调用当前状态的 deductMoney public void debuctMoney()&#123; state.deductMoney(); &#125; // 抽奖 public void raffle()&#123; // 如果当前的状态是抽奖成功 if(state.raffle())&#123; // 领取奖品 state.dispensePrize(); &#125; &#125; // Getter / Setter // 每领取一次奖品，奖品数量减一 public int getCount() &#123; int curCount = count; count--; return curCount; &#125;&#125;// 抽奖人状态抽象类public abstract class State &#123; // 扣除积分 - 50 public abstract void deductMoney(); // 是否抽中奖品 public abstract boolean raffle(); // 发放奖品 public abstract void dispensePrize();&#125;// 可以抽奖的状态：重写各步骤public class CanRaffleState extends State &#123; RaffleActivity activity; public CanRaffleState(RaffleActivity activity) &#123; this.activity = activity; &#125; // 已经扣除了积分，不能再扣 @Override public void deductMoney() &#123; System.out.println(\"已经扣取过了积分\"); &#125; // 可以抽奖, 抽完奖后，根据实际情况，改成新的状态 @Override public boolean raffle() &#123; System.out.println(\"正在抽奖，请稍等！\"); Random r = new Random(); int num = r.nextInt(10); // 10% 中奖机会 if(num == 0)&#123; // 改变活动状态为发放奖品 context activity.setState(activity.getDispenseState()); return true; &#125;else&#123; System.out.println(\"很遗憾没有抽中奖品！\"); // 改变状态为不能抽奖 activity.setState(activity.getNoRafflleState()); return false; &#125; &#125; // 不能发放奖品 @Override public void dispensePrize() &#123; System.out.println(\"没中奖，不能发放奖品\"); &#125;&#125;// 奖品发送完毕状态public class DispenseOutState extends State &#123; // 初始化时传入活动引用 RaffleActivity activity; public DispenseOutState(RaffleActivity activity) &#123; this.activity = activity; &#125; @Override public void deductMoney() &#123; System.out.println(\"奖品发送完了，请下次再参加\"); &#125; @Override public boolean raffle() &#123; System.out.println(\"奖品发送完了，请下次再参加\"); return false; &#125; @Override public void dispensePrize() &#123; System.out.println(\"奖品发送完了，请下次再参加\"); &#125;&#125;// 发送奖品状态public class DispenseState extends State &#123; // 初始化时传入活动引用，发放奖品后改变其状态 RaffleActivity activity; public DispenseState(RaffleActivity activity) &#123; this.activity = activity; &#125; @Override public void deductMoney() &#123; System.out.println(\"不能扣除积分\"); &#125; @Override public boolean raffle() &#123; System.out.println(\"不能抽奖\"); return false; &#125; // 发放奖品 @Override public void dispensePrize() &#123; if(activity.getCount() &gt; 0)&#123; System.out.println(\"恭喜中奖了\"); // 改变状态为不能抽奖 activity.setState(activity.getNoRafflleState()); &#125;else&#123; System.out.println(\"很遗憾，奖品发送完了\"); // 改变状态为奖品发送完毕, 后面我们就不可以抽奖 activity.setState(activity.getDispensOutState()); // System.out.println(\"抽奖活动结束\"); // System.exit(0); &#125; &#125;&#125;// 不能抽奖的状态public class NoRaffleState extends State &#123; // 初始化时传入活动引用，扣除积分后改变其状态 RaffleActivity activity; public NoRaffleState(RaffleActivity activity) &#123; this.activity = activity; &#125; // 当前状态可以扣积分，扣除后，将状态设置成可以抽奖状态 @Override public void deductMoney() &#123; System.out.println(\"扣除 50 积分成功，您可以抽奖了\"); activity.setState(activity.getCanRaffleState()); &#125; // 当前状态不能抽奖 @Override public boolean raffle() &#123; System.out.println(\"扣了积分才能抽奖喔！\"); return false; &#125; // 当前状态不能发奖品 @Override public void dispensePrize() &#123; System.out.println(\"不能发放奖品\"); &#125;&#125; 策略模式 分别封装行为接口，实现算法族，超类里放行为接口对象，在子类里具体设定行为对象。原则就是：分离变化部分，封装接口，基于接口编程各种功能。此模式让行为的变化独立于算法的使用者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public class Client &#123; public static void main(String[] args) &#123; WildDuck wildDuck = new WildDuck(); wildDuck.fly(); ToyDuck toyDuck = new ToyDuck(); toyDuck.fly(); PekingDuck pekingDuck = new PekingDuck(); pekingDuck.fly(); // 动态改变某个对象的行为, 北京鸭改为不能飞：改变策略 pekingDuck.setFlyBehavior(new NoFlyBehavior()); System.out.println(\"北京鸭的实际飞翔能力\"); pekingDuck.fly(); &#125;&#125;// 定义鸭的行为模式public abstract class Duck &#123; // 属性, 策略接口 FlyBehavior flyBehavior; // 其它属性 &lt;-&gt; 策略接口 QuackBehavior quackBehavior; public Duck() &#123; &#125; public abstract void display(); // 显示鸭子信息 public void quack() &#123; System.out.println(\"鸭子嘎嘎叫~~\"); &#125; public void swim() &#123; System.out.println(\"鸭子会游泳~~\"); &#125; public void fly() &#123; // 若改变策略 if(flyBehavior != null) &#123; flyBehavior.fly(); &#125; &#125; public void setFlyBehavior(FlyBehavior flyBehavior) &#123; this.flyBehavior = flyBehavior; &#125; public void setQuackBehavior(QuackBehavior quackBehavior) &#123; this.quackBehavior = quackBehavior; &#125;&#125;public class PekingDuck extends Duck &#123; // 假如北京鸭可以飞翔，但是飞翔技术一般 public PekingDuck() &#123; flyBehavior = new BadFlyBehavior(); &#125; @Override public void display() &#123; System.out.println(\"~~北京鸭~~~\"); &#125;&#125;public class ToyDuck extends Duck&#123; public ToyDuck() &#123; flyBehavior = new NoFlyBehavior(); &#125; @Override public void display() &#123; System.out.println(\"玩具鸭\"); &#125; // 需要重写父类的所有方法 public void quack() &#123; System.out.println(\"玩具鸭不能叫~~\"); &#125; public void swim() &#123; System.out.println(\"玩具鸭不会游泳~~\"); &#125;&#125;public class WildDuck extends Duck &#123; // 构造器，传入 FlyBehavor 的对象 public WildDuck() &#123; flyBehavior = new GoodFlyBehavior(); &#125; @Override public void display() &#123; System.out.println(\" 这是野鸭 \"); &#125;&#125;// 未实现策略public interface QuackBehavior &#123; void quack();//子类实现&#125;public interface FlyBehavior &#123; void fly(); // 子类具体实现&#125;public class GoodFlyBehavior implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\"飞翔技术高超~~\"); &#125;&#125;public class NoFlyBehavior implements FlyBehavior&#123; @Override public void fly() &#123; System.out.println(\"不会飞翔...\"); &#125;&#125;public class BadFlyBehavior implements FlyBehavior &#123; @Override public void fly() &#123; System.out.println(\" 飞翔技术一般 \"); &#125;&#125; 策略模式的核心思想是：多用组合/聚合 少用继承；用行为类组合，而不是行为的继承，更有弹性。 责任链模式 职责链模式（Chain of Responsibility Pattern）, 又叫 责任链模式，为请求创建了一个接收者对象的链。这种模式对请求的发送者和接收者进行解耦 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class Client &#123; public static void main(String[] args) &#123; // 创建一个请求 PurchaseRequest purchaseRequest = new PurchaseRequest(1, 31000, 1); // 创建相关的审批人 DepartmentApprover departmentApprover = new DepartmentApprover(\"张主任\"); CollegeApprover collegeApprover = new CollegeApprover(\"李院长\"); ViceSchoolMasterApprover viceSchoolMasterApprover = new ViceSchoolMasterApprover(\"王副校\"); SchoolMasterApprover schoolMasterApprover = new SchoolMasterApprover(\"佟校长\"); // 需要将各个审批级别的下一个设置好 (处理人构成环形) // 各处理者处理的范围（任务类型）不同 departmentApprover.setApprover(collegeApprover); collegeApprover.setApprover(viceSchoolMasterApprover); viceSchoolMasterApprover.setApprover(schoolMasterApprover); schoolMasterApprover.setApprover(departmentApprover); // 分发任务 departmentApprover.processRequest(purchaseRequest); viceSchoolMasterApprover.processRequest(purchaseRequest); &#125;&#125;public abstract class Approver &#123; Approver approver; // 下一个处理者 String name; // 名字 public Approver(String name) &#123; this.name = name; &#125; // 下一个处理者 public void setApprover(Approver approver) &#123; this.approver = approver; &#125; // 处理审批请求的方法，得到一个请求, 处理是子类完成，因此该方法做成抽象 public abstract void processRequest(PurchaseRequest purchaseRequest);&#125;public class CollegeApprover extends Approver &#123; public CollegeApprover(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; if(purchaseRequest.getPrice() &lt; 5000 &amp;&amp; purchaseRequest.getPrice() &lt;= 10000) &#123; System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); &#125;else &#123; approver.processRequest(purchaseRequest); &#125; &#125;&#125;public class DepartmentApprover extends Approver &#123; public DepartmentApprover(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; if(purchaseRequest.getPrice() &lt;= 5000) &#123; System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); &#125;else &#123; approver.processRequest(purchaseRequest); &#125; &#125;&#125;public class SchoolMasterApprover extends Approver &#123; public SchoolMasterApprover(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; if(purchaseRequest.getPrice() &gt; 30000) &#123; System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); &#125;else &#123; approver.processRequest(purchaseRequest); &#125; &#125;&#125;public class ViceSchoolMasterApprover extends Approver &#123; public ViceSchoolMasterApprover(String name) &#123; super(name); &#125; @Override public void processRequest(PurchaseRequest purchaseRequest) &#123; // TODO Auto-generated method stub if(purchaseRequest.getPrice() &lt; 10000 &amp;&amp; purchaseRequest.getPrice() &lt;= 30000) &#123; System.out.println(\" 请求编号 id= \" + purchaseRequest.getId() + \" 被 \" + this.name + \" 处理\"); &#125;else &#123; approver.processRequest(purchaseRequest); &#125; &#125;&#125;// 请求类public class PurchaseRequest &#123; private int type = 0; // 请求类型 private float price = 0.0f; // 请求金额 private int id = 0; // 构造器 public PurchaseRequest(int type, float price, int id) &#123; this.type = type; this.price = price; this.id = id; &#125; public int getType() &#123; return type; &#125; public float getPrice() &#123; return price; &#125; public int getId() &#123; return id; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://yoursite.com/tags/Design-Patterns/"}]},{"title":"结构型模式","slug":"Java/DesignPatterns/结构型模式","date":"2020-03-21T08:52:20.000Z","updated":"2020-04-19T06:26:56.690Z","comments":true,"path":"2020/03/21/Java/DesignPatterns/结构型模式/","link":"","permalink":"http://yoursite.com/2020/03/21/Java/DesignPatterns/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式之结构型模式。","text":"设计模式之结构型模式。 适配器模式 适配器模式（Adapter Pattern）将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作，其别名为包装器（Wrapper）。 种类：类 / 对象 / 接口适配器模式。 类适配器 123456789101112131415161718192021222324252627282930313233343536373839404142public class Client &#123; public static void main(String[] args) &#123; System.out.println(\" === 类适配器模式 ===\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter()); &#125;&#125;// 适配接口public interface IVoltage5V &#123; public int output5V();&#125;public class Phone &#123; // 充电 public void charging(IVoltage5V iVoltage5V) &#123; if(iVoltage5V.output5V() == 5) &#123; System.out.println(\"电压为 5V, 可以充电\"); &#125; else if (iVoltage5V.output5V() &gt; 5) &#123; System.out.println(\"电压大于 5V, 不能充电\"); &#125; &#125;&#125;// 被适配的类public class Voltage220V &#123; // 输出 220V 的电压 public int output220V() &#123; int src = 220; System.out.println(\"电压=\" + src + \"伏\"); return src; &#125;&#125;// 适配器，Java 单继承机制，所以目标类必须是一个接口public class VoltageAdapter extends Voltage220V implements IVoltage5V &#123; @Override public int output5V() &#123; // 获取到 220V 电压 int srcV = output220V(); int dstV = srcV / 44 ; // 转成 5v return dstV; &#125;&#125; 对象适配器 基本思路和类的适配器模式相同，只是将 Adapter 类作修改，不是继承 resource 类，而是持有其的实例，以解决兼容性的问题。 即根据合成复用原则，在系统中尽量使用关联关系（聚合）来替代继承关系。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Client &#123; public static void main(String[] args) &#123; System.out.println(\" === 对象适配器模式 ===\"); Phone phone = new Phone(); phone.charging(new VoltageAdapter(new Voltage220V())); &#125;&#125;public interface Voltage5V &#123; public int output5V();&#125;public class Phone &#123; public void charging(IVoltage5V iVoltage5V) &#123; if(iVoltage5V.output5V() == 5) &#123; System.out.println(\"电压为 5V, 可以充电\"); &#125; else if (iVoltage5V.output5V() &gt; 5) &#123; System.out.println(\"电压大于 5V, 不能充电\"); &#125; &#125;&#125;public class Voltage220V &#123; public int output220V() &#123; int src = 220; System.out.println(\"电压=\" + src + \"伏\"); return src; &#125;&#125;public class VoltageAdapter implements IVoltage5V &#123; private Voltage220V voltage220V; // 关联关系-聚合 // 通过构造器，传入一个 Voltage220V 实例 public VoltageAdapter(Voltage220V voltage220v) &#123; this.voltage220V = voltage220v; &#125; @Override public int output5V() &#123; int dst = 0; if(null != voltage220V) &#123; int src = voltage220V.output220V(); // 获取 220V 电压 System.out.println(\"使用对象适配器，进行适配\"); dst = src / 44; System.out.println(\"适配完成，输出的电压为=\" + dst); &#125; return dst; &#125;&#125; 对象适配器和类适配器其实算是同一种思想，只不过实现方式不同。根据合成复用原则，使用组合替代继承， 所以它解决了类适配器必须继承 resource 的局限性问题，也不再要求 destination 必须是接口。 接口适配器 核心思路：当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。该模式适用于一个接口不想使用其所有的方法的情况。 123456789101112131415161718192021222324252627282930public interface Interface &#123; public void m1(); public void m2(); public void m3(); public void m4();&#125;// 在 AbsAdapter 我们将 Interface 的方法进行默认实现public abstract class AbsAdapter implements Interface &#123; public void m1() &#123; &#125; public void m2() &#123; &#125; public void m3() &#123; &#125; public void m4() &#123; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; AbsAdapter absAdapter = new AbsAdapter() &#123; // 只需覆盖需要使用接口方法 @Override public void m1() &#123; System.out.println(\"使用了 m1 的方法\"); &#125; &#125;; absAdapter.m1(); &#125;&#125; Spring MVC SpringMvc 中的 HandlerAdapter, 就使用了适配器模式。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class DispatchServlet &#123; public static List&lt;HandlerAdapter&gt; handlerAdapters = new ArrayList&lt;HandlerAdapter&gt;(); public DispatchServlet() &#123; // 初始化各种适配器 handlerAdapters.add(new AnnotationHandlerAdapter()); handlerAdapters.add(new HttpHandlerAdapter()); handlerAdapters.add(new SimpleHandlerAdapter()); &#125; public void doDispatch() &#123; // 此处模拟 SpringMVC 从 request 取 handler 的对象 HttpController controller = new HttpController(); // 得到对应适配器 HandlerAdapter adapter = getHandler(controller); // 通过适配器执行对应的 controller 的对应方法 adapter.handle(controller); &#125; public HandlerAdapter getHandler(Controller controller) &#123; // 遍历：根据得到的 controller 即 handler, 返回对应适配器 for (HandlerAdapter adapter : this.handlerAdapters) &#123; // 判读此适配器是否支持此类型的 controller if (adapter.supports(controller)) &#123; return adapter; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; new DispatchServlet().doDispatch(); &#125;&#125;public interface Controller &#123;&#125;// 多种 Controller 类 class HttpController implements Controller &#123; public void doHttpHandler() &#123; System.out.println(\"http...\"); &#125;&#125;class SimpleController implements Controller &#123; public void doSimplerHandler() &#123; System.out.println(\"simple...\"); &#125;&#125;class AnnotationController implements Controller &#123; public void doAnnotationHandler() &#123; System.out.println(\"annotation...\"); &#125;&#125;public interface HandlerAdapter &#123; public boolean supports(Object handler); public void handle(Object handler);&#125;// 多种 Adapter 类class SimpleHandlerAdapter implements HandlerAdapter &#123; public void handle(Object handler) &#123; ((SimpleController) handler).doSimplerHandler(); &#125; public boolean supports(Object handler) &#123; return (handler instanceof SimpleController); &#125;&#125;class HttpHandlerAdapter implements HandlerAdapter &#123; public void handle(Object handler) &#123; ((HttpController) handler).doHttpHandler(); &#125; public boolean supports(Object handler) &#123; return (handler instanceof HttpController); &#125;&#125;class AnnotationHandlerAdapter implements HandlerAdapter &#123; public void handle(Object handler) &#123; ((AnnotationController) handler).doAnnotationHandler(); &#125; public boolean supports(Object handler) &#123; return (handler instanceof AnnotationController); &#125;&#125; 桥接模式 将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变； Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象（Abstraction）与行为实现（Implementation）分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116public class Client &#123; public static void main(String[] args) &#123; Phone phone1 = new FoldedPhone(new XiaoMi()); phone1.open(); phone1.call(); phone1.close(); System.out.println(\"=======\"); Phone phone2 = new FoldedPhone(new Vivo()); phone2.open(); phone2.call(); phone2.close(); System.out.println(\"=======\"); UpRightPhone phone3 = new UpRightPhone(new XiaoMi()); phone3.open(); phone3.call(); phone3.close(); System.out.println(\"=======\"); UpRightPhone phone4 = new UpRightPhone(new Vivo()); phone4.open(); phone4.call(); phone4.close(); &#125;&#125;// 手机这一角色的抽象public abstract class Phone &#123; // 组合品牌 private Brand brand; // 构造器 public Phone(Brand brand) &#123; super(); this.brand = brand; &#125; protected void open() &#123; this.brand.open(); &#125; protected void close() &#123; brand.close(); &#125; protected void call() &#123; brand.call(); &#125;&#125;public class FoldedPhone extends Phone &#123; public FoldedPhone(Brand brand) &#123; super(brand); &#125; public void open() &#123; super.open(); System.out.println(\" 折叠样式手机 \"); &#125; public void close() &#123; super.close(); System.out.println(\" 折叠样式手机 \"); &#125; public void call() &#123; super.call(); System.out.println(\" 折叠样式手机 \"); &#125;&#125;public class UpRightPhone extends Phone &#123; // 构造器 public UpRightPhone(Brand brand) &#123; super(brand); &#125; public void open() &#123; super.open(); System.out.println(\" 直立样式手机 \"); &#125; public void close() &#123; super.close(); System.out.println(\" 直立样式手机 \"); &#125; public void call() &#123; super.call(); System.out.println(\" 直立样式手机 \"); &#125;&#125;// 手机的行为public interface Brand &#123; void open(); void close(); void call();&#125;public class Vivo implements Brand &#123; @Overrid public void open() &#123; System.out.println(\" Vivo 手机开机 \"); &#125; @Override public void close() &#123; System.out.println(\" Vivo 手机关机 \"); &#125; @Override public void call() &#123; System.out.println(\" Vivo 手机打电话 \"); &#125;&#125;public class XiaoMi implements Brand &#123; @Override public void open() &#123; System.out.println(\" 小米手机开机 \"); &#125; @Override public void close() &#123; System.out.println(\" 小米手机关机 \"); &#125; @Override public void call() &#123; System.out.println(\" 小米手机打电话 \"); &#125;&#125; JDBC 这里没有进行抽象。 装饰者模式 动态的将新功能附加到对象上。在对象功能扩展方面，它比继承更有弹性，装饰者模式也体现了开闭原则 OCP。 装饰者可以包含被装饰者：一层一层就像包快递一样，比一样的物品包装的方式不同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100public abstract class Drink &#123; public String des; // 饮品的描述 private float price = 0.0f; // Getter / Setter // 规定子类都要有计算价格的方法 public abstract float cost();&#125;public class Coffee extends Drink &#123; @Override public float cost() &#123; return super.getPrice(); &#125;&#125;public class DeCaf extends Coffee &#123; public DeCaf() &#123; setDes(\" DeCaf \"); setPrice(1.0f); &#125;&#125;public class LongBlack extends Coffee &#123; public LongBlack() &#123; setDes(\" longblack \"); setPrice(5.0f); &#125;&#125;public class ShortBlack extends Coffee&#123; public ShortBlack() &#123; setDes(\" shortblack \"); setPrice(4.0f); &#125;&#125;public class Decorator extends Drink &#123; private Drink obj; public Decorator(Drink obj) &#123; // 组合 this.obj = obj; &#125; @Override public float cost() &#123; // getPrice 自己价格 return super.getPrice() + obj.cost(); // 递归列出所有价格 &#125; @Override public String getDes() &#123; // obj.getDes() 输出被装饰者的信息 return des + \" \" + getPrice() + \" &amp;&amp; \" + obj.getDes(); &#125;&#125;// 具体的 Decorator， 这里就是调味品public class Chocolate extends Decorator &#123; public Chocolate(Drink obj) &#123; super(obj); setDes(\" 巧克力 \"); setPrice(3.0f); // 调味品的价格 &#125;&#125;public class Milk extends Decorator &#123; public Milk(Drink obj) &#123; super(obj); setDes(\" 牛奶 \"); setPrice(2.0f); &#125;&#125;public class CoffeeBar &#123; public static void main(String[] args) &#123; // 装饰者模式下的订单：2 份巧克力 + 1 份牛奶的 LongBlack // 点一份 LongBlack Drink order = new LongBlack(); System.out.println(\"费用 = \" + order.cost()); System.out.println(\"描述 = \" + order.getDes()); // order 加入一份牛奶 order = new Milk(order); System.out.println(\"order 加入一份牛奶 费用 = \" + order.cost()); System.out.println(\"order 加入一份牛奶 描述 = \" + order.getDes()); // order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入一份巧克力 费用 = \" + order.cost()); System.out.println(\"order 加入一份牛奶 加入一份巧克力 描述 = \" + order.getDes()); // order 加入一份巧克力 order = new Chocolate(order); System.out.println(\"order 加入一份牛奶 加入 2 份巧克力 费用 = \" + order.cost()); System.out.println(\"order 加入一份牛奶 加入 2 份巧克力 描述 = \" + order.getDes()); System.out.println(\"=======\"); Drink order2 = new DeCaf(); System.out.println(\"order2 无因咖啡 费用 = \" + order2.cost()); System.out.println(\"order2 无因咖啡 描述 = \" + order2.getDes()); order2 = new Milk(order2); System.out.println(\"order2 无因咖啡 加入一份牛奶 费用 = \" + order2.cost()); System.out.println(\"order2 无因咖啡 加入一份牛奶 描述 = \" + order2.getDes()); &#125;&#125; JDK-FilterInputStream 装饰者 FilterInputSteam 的部分代码。 组合模式 组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示（整体-部分）层次关系。 组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136public class Client &#123; public static void main(String[] args) &#123; // 组合关系：系 &lt; 学院 &lt; 大学 OrganizationComponent university = new University(\"清华大学\", \" 中国顶级大学 \"); OrganizationComponent computerCollege = new College(\"计算机学院\", \" 计算机学院 \"); OrganizationComponent infoEngineercollege = new College(\"信息工程学院\", \" 信息工程学院 \"); // 将系加入到学院 computerCollege.add(new Department(\"软件工程\", \" 软件工程不错 \")); computerCollege.add(new Department(\"网络工程\", \" 网络工程不错 \")); computerCollege.add(new Department(\"计算机科学与技术\", \" 计算机科学与技术是老牌的专业 \")); infoEngineercollege.add(new Department(\"通信工程\", \" 通信工程不好学 \")); infoEngineercollege.add(new Department(\"信息工程\", \" 信息工程好学 \")); // 将学院加入到学校 university.add(computerCollege); university.add(infoEngineercollege); //university.print(); infoEngineercollege.print(); &#125;&#125;public abstract class OrganizationComponent &#123; private String name; // 名字 private String des; // 说明 protected void add(OrganizationComponent organizationComponent) &#123; // 默认实现 throw new UnsupportedOperationException(); &#125; protected void remove(OrganizationComponent organizationComponent) &#123; // 默认实现 throw new UnsupportedOperationException(); &#125; // 构造器 public OrganizationComponent(String name, String des) &#123; super(); this.name = name; this.des = des; &#125; // Getter / Setter // 子类都需要实现的抽象方法 protected abstract void print();&#125;// University 为非叶子节点, 可以管理 Collegepublic class University extends OrganizationComponent &#123; List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;(); // 构造器 public University(String name, String des) &#123; super(name, des); &#125; // 重写 add @Override protected void add(OrganizationComponent organizationComponent) &#123; organizationComponents.add(organizationComponent); &#125; // 重写 remove @Override protected void remove(OrganizationComponent organizationComponent) &#123; organizationComponents.remove(organizationComponent); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override public String getDes() &#123; return super.getDes(); &#125; @Override protected void print() &#123; System.out.println(\"---\" + getName() + \"---\"); //遍历 organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) &#123; organizationComponent.print(); &#125; &#125;&#125;public class College extends OrganizationComponent &#123; // 用于存放 Department 的 List List&lt;OrganizationComponent&gt; organizationComponents = new ArrayList&lt;OrganizationComponent&gt;(); // 构造器 public College(String name, String des) &#123; super(name, des); &#125; // 根据需求重写方法，不同层次的实现可能不同 @Override protected void add(OrganizationComponent organizationComponent) &#123; organizationComponents.add(organizationComponent); &#125; @Override protected void remove(OrganizationComponent organizationComponent) &#123; organizationComponents.remove(organizationComponent); &#125; @Override public String getName() &#123; return super.getName(); &#125; @Override public String getDes() &#123; return super.getDes(); &#125; // 输出学院 @Override protected void print() &#123; // TODO Auto-generated method stub System.out.println(\"---\" + getName() + \"---\"); //遍历 organizationComponents for (OrganizationComponent organizationComponent : organizationComponents) &#123; organizationComponent.print(); &#125; &#125;&#125;// 叶子节点public class Department extends OrganizationComponent &#123; // 无 List public Department(String name, String des) &#123; super(name, des); &#125; // 无需重写 add remove 方法 @Override public String getName() &#123; return super.getName(); &#125; @Override public String getDes() &#123; return super.getDes(); &#125; @Override protected void print() &#123; System.out.println(getName()); &#125;&#125; JDK-HashMap 外观模式 外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节。 享元模式 运用共享技术有效地支持大量细粒度的对象； 常用于系统底层开发，解决系统的性能问题。像数据库连接池，里面都是创建好的连接对象，在这些连接对象中有我们需要的则直接拿来用，避免重新创建，如果没有我们需要的，则创建一个；享元模式能够解决重复对象的内存浪费的问题，当系统中有大量相似对象，创建缓冲池，不需总是创建新对象，可以从缓冲池里拿。这样可以降低系统内存，同时提高效率；享元模式经典的应用场景就是池技术了，String 常量池、数据库连接池、缓冲池等等都是享元模式的应用，享元模式是池技术的重要实现方式。 享元模式提出了两个要求：细粒度和共享对象。这里就涉及到内部状态和外部状态了，即将对象的信息分为两个部分：内部状态和外部状态：(1) 内部状态指对象共享出来的信息，存储在享元对象内部且不会随环境的改变而改变；(2) 外部状态指对象得以依赖的一个标记，是随环境改变而改变的、不可共享的状态。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class Client &#123; public static void main(String[] args) &#123; // 创建一个工厂类 WebSiteFactory factory = new WebSiteFactory(); // 客户要一个以新闻形式发布的网站 WebSite webSite1 = factory.getWebSiteCategory(\"新闻\"); webSite1.use(new User(\"tom\")); // 客户要一个以博客形式发布的网站 WebSite webSite2 = factory.getWebSiteCategory(\"博客\"); webSite2.use(new User(\"jack\")); // 客户要一个以博客形式发布的网站 WebSite webSite3 = factory.getWebSiteCategory(\"博客\"); webSite3.use(new User(\"smith\")); // 客户要一个以博客形式发布的网站 WebSite webSite4 = factory.getWebSiteCategory(\"博客\"); webSite4.use(new User(\"king\")); System.out.println(\"网站的分类共=\" + factory.getWebSiteCount()); &#125;&#125;public abstract class WebSite &#123; public abstract void use(User user); // 抽象方法&#125;// 具体网站public class ConcreteWebSite extends WebSite &#123; // 共享的部分，内部状态 private String type = \"\"; // 网站发布的类型 // 构造器 public ConcreteWebSite(String type) &#123; this.type = type; &#125; @Override public void use(User user) &#123; System.out.println(\"网站的发布形式为:\" + type + \" 使用者是\" + user.getName()); &#125;&#125; // 使用者public class User &#123; private String name; public User(String name) &#123; super(); this.name = name; &#125; // Getter / Setter&#125;// 网站工厂类，根据需要返回一个相应的网站public class WebSiteFactory &#123; // 集合：相当于一个池 private HashMap&lt;String, ConcreteWebSite&gt; pool = new HashMap&lt;&gt;(); // 根据网站的类型，返回一个网站, 如果没有就创建一个网站，并放入到池中,并返回 public WebSite getWebSiteCategory(String type) &#123; if(!pool.containsKey(type)) &#123; // 无此类型则创建一个网站，并放入到池中 pool.put(type, new ConcreteWebSite(type)); &#125; return (WebSite)pool.get(type); &#125; // 获取网站分类的总数 public int getWebSiteCount() &#123; return pool.size(); &#125;&#125; JDK-Integer [127,-128]：此范围内直接从池返回 。 享元模式提高了系统的复杂度。需要分离出内部状态和外部状态，而外部状态具有固化特性，不应该随着内部状态的改变而改变，这是我们使用享元模式需要注意的地方； 使用享元模式时，注意划分内部状态和外部状态，并且需要有一个工厂类加以控制。 代理模式 代理模式：为一个对象提供一个替身，以控制对这个对象的访问。即通过代理对象访问目标对象。这样做的好处是可以在目标对象实现的基础上，增强额外的功能操作，即扩展目标对象的功能；被代理的对象可以是远程对象、创建开销大的对象或需要安全控制的对象；代理模式有不同的形式, 主要有三种：(1) 静态代理 (2) 动态代理 （JDK 代理、接口代理）(3) Cglib 代理 （可以在内存动态的创建对象，而不需要实现接口， 他是属于动态代理的范畴） 静态代理 静态代理在使用时，需要定义接口或者父类,被代理对象（即目标对象）与代理对象一起实现相同的接口或者是继承相同父类。 1234567891011121314151617181920212223242526272829303132333435363738public class Client &#123; public static void main(String[] args) &#123; // 创建目标对象：被代理对象 TeacherDaoImpl teacherDaoImpl = new TeacherDaoImpl(); // 创建代理对象, 同时将被代理对象传递给代理对象 TeacherDaoProxy teacherDaoProxy = new TeacherDaoProxy(teacherDaoImpl); // 通过代理对象，调用到被代理对象的方法 // 即：执行的是代理对象的方法，代理对象再去调用目标对象的方法 teacherDaoProxy.teach(); &#125;&#125;// 接口public interface TeacherDao &#123; void teach(); // 授课的方法&#125;public class TeacherDaoImpl implements TeacherDao &#123; @Override public void teach() &#123; System.out.println(\" 老师授课中 。。。。。\"); &#125;&#125;// 代理对象：静态代理public class TeacherDaoProxy implements TeacherDao&#123; private TeacherDao target; // 目标对象，通过接口来聚合 // 构造器 public TeacherDaoProxy(TeacherDao target) &#123; this.target = target; &#125; @Override public void teach() &#123; System.out.println(\"开始代理 完成某些操作...\"); // 目标方法前操作 target.teach(); // 目标方法 System.out.println(\"提交...\"); // 目标方法后操作 &#125;&#125; 动态代理 代理对象不需要实现接口，但是目标对象要实现接口，否则不能用动态代理。代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Client &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub // 创建目标对象 TeacherDao target = new TeacherDaoImpl(); // 给目标对象，创建代理对象, 可以转成 TeacherDao TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance(); // proxyInstance = class com.sun.proxy.$Proxy0 内存中动态生成了代理对象 System.out.println(\"proxyInstance=\" + proxyInstance.getClass()); // 通过代理对象，调用目标对象的方法 proxyInstance.teach(); proxyInstance.sayHello(\" tom \"); &#125;&#125;// 接口public interface teacherDao &#123; void teach(); // 授课方法 void sayHello(String name);&#125;public class ProxyFactory &#123; // 维护一个目标对象 , Object private Object target; // 构造器：对 target 进行初始化 public ProxyFactory(Object target) &#123; this.target = target; &#125; // 给目标对象 生成一个代理对象 public Object getProxyInstance() &#123; // ClassLoader loader ： 指定当前目标对象使用的类加载器, 获取加载器的方法固定 // Class&lt;?&gt;[] interfaces: 目标对象实现的接口类型，使用泛型方法确认类型 // InvocationHandler h : 事情处理，执行目标对象的方法时，会触发事情处理器方法, 会把当前执行 return Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"JDK 代理开始\"); //反射机制调用目标对象的方法 Object returnVal = method.invoke(target, args); System.out.println(\"JDK 代理提交\"); return returnVal; &#125; &#125;); &#125;&#125;public class TeacherDaoImpl implements TeacherDao &#123; @Override public void teach() &#123; System.out.println(\" 老师授课中... \"); &#125; @Override public void sayHello(String name) &#123; System.out.println(\"hello \" + name); &#125;&#125; Cglib 代理模式 静态代理和 JDK 代理模式都要求目标对象是实现一个接口,但是有时候目标对象只是一个单独的对象，并没有实现任何的接口，这个时候可使用目标对象子类来实现代理，这种模式就是 Cglib 代理。 Cglib 代理也叫作子类代理，它是在内存中构建一个子类对象从而实现对目标对象功能扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Client &#123; public static void main(String[] args) &#123; // 创建目标对象 TeacherDao target = new TeacherDao(); // 获取到代理对象，并且将目标对象传递给代理对象 TeacherDao proxyInstance = (TeacherDao)new ProxyFactory(target).getProxyInstance(); // 执行代理对象的方法，触发 intercept 方法，从而实现对目标对象的调用 String res = proxyInstance.teach(); System.out.println(\"res=\" + res); &#125;&#125;public class ProxyFactory implements MethodInterceptor &#123; // 维护一个目标对象 private Object target; // 构造器，传入一个被代理的对象 public ProxyFactory(Object target) &#123; this.target = target; &#125; // 返回一个代理对象: 是 target 对象的代理对象 public Object getProxyInstance() &#123; // 创建一个工具类 Enhancer enhancer = new Enhancer(); // 设置父类 enhancer.setSuperclass(target.getClass()); // 设置回调函数 enhancer.setCallback(this); // 创建子类对象，即代理对象 return enhancer.create(); &#125; // 重写 intercept 方法，会调用目标对象的方法 @Override public Object intercept(Object arg0, Method method, Object[] args, MethodProxy arg3) throws Throwable &#123; System.out.println(\"Cglib 代理模式开始\"); Object returnVal = method.invoke(target, args); System.out.println(\"Cglib 代理模式提交\"); return returnVal; &#125;&#125;public class TeacherDao &#123; public String teach() &#123; System.out.println(\" 老师授课中，cglib 代理不需要实现接口 \"); return \"hello\"; &#125;&#125; 常用变体 (1) 防火墙代理内网通过代理穿透防火墙，实现对公网的访问; (2) 缓存代理比如：当请求图片文件等资源时，先到缓存代理取，如果取到资源则 ok，如果取不到资源，再到公网或者数据库取，然后缓存； (3) 远程代理远程对象的本地代表，通过它可以把远程对象当本地对象来调用。远程代理通过网络和真正的远程对象沟通信息； (4) 同步代理：主要使用在多线程编程中，完成多线程间同步工作。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://yoursite.com/tags/Design-Patterns/"}]},{"title":"创建型模式","slug":"Java/DesignPatterns/创建型模式","date":"2020-03-21T07:56:29.000Z","updated":"2020-04-19T06:26:50.859Z","comments":true,"path":"2020/03/21/Java/DesignPatterns/创建型模式/","link":"","permalink":"http://yoursite.com/2020/03/21/Java/DesignPatterns/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式之创建型模式。","text":"设计模式之创建型模式。 单例模式饿汉式静态变量123456789101112//饿汉式：静态变量class Singleton &#123; // 构造器私有化, 外部不能 new private Singleton() &#123; &#125; // 本类内部创建对象实例 private final static Singleton instance = new Singleton(); // 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 静态代码块1234567891011121314// 饿汉式：静态代码块class Singleton &#123; private Singleton() &#123; &#125; // 本类内部创建对象实例 private static Singleton instance; static &#123; // 在静态代码块中，创建单例对象 instance = new Singleton(); &#125; // 提供一个公有的静态方法，返回实例对象 public static Singleton getInstance() &#123; return instance; &#125;&#125; 懒汉式同步方法12345678910111213// 懒汉式：线程安全，同步方法class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; // 提供一个静态的公有方法，加入同步处理的代码，解决线程安全问题 // 每一个线程获取实例时都要进到同步方法中进行判读，大大降低了效率 public static synchronized Singleton getInstance() &#123; if(instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125;&#125; 双重检查12345678910111213141516// 懒汉式：双重检查class Singleton &#123; private static Singleton instance; private Singleton() &#123;&#125; public static Singleton getInstance() &#123; if(instance == null) &#123; // 一次只有一个线程可进入此同步代码块中 synchronized (Singleton.class) &#123; if(instance == null) &#123; instance = new Singleton(); &#125; &#125; &#125; return instance; &#125;&#125; 静态内部类 静态内部类方式在 Singleton 类被装载时并不会立即实例化，而是在需要实例化时，调用 getInstance 方法，才会装载 SingletonInstance 类，从而完成 Singleton 的实例化。 类的静态属性只会在第一次加载类的时候初始化，所以在这里，JVM 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。 1234567891011121314// 懒汉式：静态内部类class Singleton &#123; private static volatile Singleton instance; // 构造器私有化 private Singleton() &#123;&#125; // 写一个静态内部类，该类中有一个静态属性 Singleton private static class SingletonInstance &#123; private static final Singleton INSTANCE = new Singleton(); &#125; // 提供一个静态的公有方法，直接返回 SingletonInstance.INSTANCE public static synchronized Singleton getInstance() &#123; return SingletonInstance.INSTANCE; &#125;&#125; 枚举12345678// 懒汉式：枚举enum Singleton &#123; INSTANCE; //属性 public void sayOK() &#123; System.out.println(\"ok~\"); &#125;&#125;// 不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象 总结单例模式保证了系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能； 当想实例化一个单例类的时候，必须要记住使用相应的获取对象的方法，而不是使用 new； 单例模式使用的场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗费资源过多（即：重量级对象），但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象（比如数据源、session 工厂等）。 工厂模式简单工厂 简单工厂模式是属于创建型模式，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。 简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为(代码)。 在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。 1234567891011121314151617181920212223242526272829303132333435363738// 此类为使用者，当提供方进行扩展时需要进行比较大的代码修改，违反 OCP 原则public OrderPizza() &#123; Pizza pizza = null; String orderType; // 订购披萨的类型 do &#123; orderType = getType(); if (orderType.equals(\"greek\")) &#123; pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); &#125; else if (orderType.equals(\"cheese\")) &#123; pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); &#125; else if (orderType.equals(\"pepper\")) &#123; pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); &#125; else &#123; break; &#125; // 输出 pizza 制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; while (true);&#125;// 写一个方法，可以获取客户希望订购的披萨种类private String getType() &#123; try &#123; BufferedReader strin = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"input pizza 种类:\"); String str = strin.readLine(); return str; &#125; catch (IOException e) &#123; e.printStackTrace(); return \"\"; &#125;&#125; 如果我们增加一个 Pizza 类，只要是订购 Pizza 的代码都需要修改。当然修改代码是可以接受，但是如果我们在其它的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza 的代码，往往有多处。 简单工厂模式的设计方案：定义一个可以实例化 Pizaa 对象的类，封装创建对象的代码。当所有的对象的实例化都由一个工厂进行负责时，新增一个 Pizza 类只用修改工厂类即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 简单工厂类public class SimpleFactory &#123; // 添加 orderType 返回对应的 Pizza 对象 public Pizza createPizza(String orderType) &#123; // 根据需求还可以是静态方法 Pizza pizza = null; System.out.println(\"简单工厂模式\"); if (orderType.equals(\"greek\")) &#123; pizza = new GreekPizza(); pizza.setName(\" 希腊披萨 \"); &#125; else if (orderType.equals(\"cheese\")) &#123; pizza = new CheesePizza(); pizza.setName(\" 奶酪披萨 \"); &#125; else if (orderType.equals(\"pepper\")) &#123; pizza = new PepperPizza(); pizza.setName(\"胡椒披萨\"); &#125; return pizza; &#125;&#125;// 使用者public OrderPizza() &#123; // 定义一个简单工厂对象 SimpleFactory simpleFactory; Pizza pizza = null; // 构造器 public OrderPizza(SimpleFactory simpleFactory) &#123; setFactory(simpleFactory); &#125; public void setFactory(SimpleFactory simpleFactory) &#123; String orderType = \"\"; // 用户输入的 this.simpleFactory = simpleFactory; // 设置简单工厂对象 do &#123; orderType = getType(); pizza = this.simpleFactory.createPizza(orderType); // 输出 pizza if(pizza != null) &#123; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; else &#123; System.out.println(\" 订购披萨失败 \"); break; &#125; &#125;while(true); &#125;&#125; 工厂方法 工厂方法模式：定义了一个创建对象的抽象方法，由子类决定要实例化的对象。工厂方法模式将对象的实例化推迟到子类。 简单工厂模式需要一个工厂进行操作，当更多的不同的需求时，可以通过创建多个简单工厂类进行实现；工厂方法模式直接把会变化的方法抽象到子工厂中去实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243public abstract class OrderPizza &#123; // 定义一个抽象方法，createPizza , 让各个工厂子类自己实现 abstract Pizza createPizza(String orderType); // 构造器 public OrderPizza() &#123; Pizza pizza = null; String orderType; // 订购披萨的类型 do &#123; orderType = getType(); pizza = createPizza(orderType); // 抽象方法，由工厂子类完成 // 输出 pizza 制作过程 pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; while (true); &#125;&#125;// 子工厂public class BJOrderPizza extends OrderPizza &#123; @Override Pizza createPizza(String orderType) &#123; Pizza pizza = null; if(orderType.equals(\"cheese\")) &#123; pizza = new BJCheesePizza(); &#125; else if (orderType.equals(\"pepper\")) &#123; pizza = new BJPepperPizza(); &#125; return pizza; &#125;&#125;public class LDOrderPizza extends OrderPizza &#123; Pizza createPizza(String orderType) &#123; Pizza pizza = null; if(orderType.equals(\"cheese\")) &#123; pizza = new LDCheesePizza(); &#125; else if (orderType.equals(\"pepper\")) &#123; pizza = new LDPepperPizza(); &#125; return pizza; &#125;&#125; 抽象工厂 抽象工厂模式：定义了一个 interface 用于创建相关或有依赖关系的对象簇，而无需指明具体的类。 抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。从设计层面看，抽象工厂模式就是对简单工厂模式的改进。（或者称为进一步的抽象）将工厂抽象成两层，AbsFactory（抽象工厂）和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类变成了工厂簇，更利于代码的维护和扩展。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 一个抽象工厂模式的抽象层：接口public interface AbsFactory &#123; // 让下面的工厂子类来具体实现 public Pizza createPizza(String orderType);&#125;public class BJFactory implements AbsFactory &#123; @Override public Pizza createPizza(String orderType) &#123; System.out.println(\"抽象工厂模式\"); Pizza pizza = null; if(orderType.equals(\"cheese\")) &#123; pizza = new BJCheesePizza(); &#125; else if (orderType.equals(\"pepper\"))&#123; pizza = new BJPepperPizza(); &#125; return pizza; &#125;&#125;public class LDFactory implements AbsFactory &#123; @Override public Pizza createPizza(String orderType) &#123; System.out.println(\"抽象工厂模式\"); Pizza pizza = null; if (orderType.equals(\"cheese\")) &#123; pizza = new LDCheesePizza(); &#125; else if (orderType.equals(\"pepper\")) &#123; pizza = new LDPepperPizza(); &#125; return pizza; &#125;&#125;public class OrderPizza &#123; AbsFactory factory; public OrderPizza(AbsFactory factory) &#123; setFactory(factory); &#125; private void setFactory(AbsFactory factory) &#123; Pizza pizza = null; String orderType = \"\"; this.factory = factory; do &#123; orderType = getType(); // factory 可能是北京的工厂子类，也可能是伦敦的工厂子类 pizza = factory.createPizza(orderType); if (pizza != null) &#123; pizza.prepare(); pizza.bake(); pizza.cut(); pizza.box(); &#125; else &#123; System.out.println(\"订购失败\"); break; &#125; &#125; while (true); &#125;&#125; 总结工厂模式的意义：将实例化对象的代码提取出来，放到一个类中统一管理和维护，达到和主项目的依赖关系的解耦。从而提高项目的扩展和维护性。 设计模式的依赖抽象原则： 创建对象实例时，不要直接 new 类, 而是把这个 new 类的动作放在一个工厂的方法中，并返回；不要让类继承具体类，而是继承抽象类或者是实现 interface；不要覆盖基类中已经实现的方法。 原型模式 原型模式（Prototype 模式）是指：用原型实例指定创建对象的种类，并且通过拷贝这些原型，创建新的对象； 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建的细节； 工作原理：通过将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实施创建，即 Object.clone() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Sheep implements Cloneable &#123; private String name; private int age; private String color; private String address = \"蒙古羊\"; public Sheep friend; // 克隆是会如何处理引用对象对象, 默认是浅拷贝 public Sheep(String name, int age, String color) &#123; super(); this.name = name; this.age = age; this.color = color; &#125; // Getter / Setter @Override public String toString() &#123; return \"Sheep [name=\" + name + \", age=\" + age + \", color=\" + color + \", address=\" + address + \"]\"; &#125; // 克隆该实例，使用默认的 clone 方法来完成 @Override protected Object clone() &#123; Sheep sheep = null; try &#123; sheep = (Sheep)super.clone(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; return sheep; &#125;&#125;public class Client &#123; public static void main(String[] args) &#123; System.out.println(\"原型模式完成对象的创建\"); Sheep sheep = new Sheep(\"tom\", 1, \"白色\"); sheep.friend = new Sheep(\"jack\", 2, \"黑色\"); Sheep sheep2 = (Sheep)sheep.clone(); //克隆 Sheep sheep3 = (Sheep)sheep.clone(); //克隆 Sheep sheep4 = (Sheep)sheep.clone(); //克隆 Sheep sheep5 = (Sheep)sheep.clone(); //克隆 System.out.println(\"sheep2 =\" + sheep2 + \"sheep2.friend=\" + sheep2.friend.hashCode()); System.out.println(\"sheep3 =\" + sheep3 + \"sheep3.friend=\" + sheep3.friend.hashCode()); System.out.println(\"sheep4 =\" + sheep4 + \"sheep4.friend=\" + sheep4.friend.hashCode()); System.out.println(\"sheep5 =\" + sheep5 + \"sheep5.friend=\" + sheep5.friend.hashCode()); &#125;&#125; 浅拷贝 对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象； 对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。 1Object.clone(); // 默认为浅拷贝 深拷贝 复制对象的所有基本数据类型的成员变量值； 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象（包括对象的引用类型）进行拷贝。 重写 clone 方法123456789101112131415161718192021222324252627282930313233public class DeepCloneableTarget implements Serializable, Cloneable &#123; private static final long serialVersionUID = 1L; private String cloneName; private String cloneClass; // 构造器 public DeepCloneableTarget(String cloneName, String cloneClass) &#123; this.cloneName = cloneName; this.cloneClass = cloneClass; &#125; // 因为该类的属性，都是 String , 因此我们这里使用默认的 clone 完成即可 @Override protected Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;public class DeepProtoType implements Serializable, Cloneable&#123; public String name; // String 属性 public DeepCloneableTarget deepCloneableTarget; // 引用类型 public DeepProtoType() &#123; super(); &#125; // 深拷贝：使用 clone 方法 @Override protected Object clone() throws CloneNotSupportedException &#123; Object deep = null; // 这里完成对基本数据类型（属性）和 String 的克隆 deep = super.clone(); // 对引用类型的属性，进行单独处理 DeepProtoType deepProtoType = (DeepProtoType)deep; deepProtoType.deepCloneableTarget = (DeepCloneableTarget)deepCloneableTarget.clone(); return deepProtoType; &#125;&#125; 对象序列化实现12345678910111213141516171819202122232425262728293031public Object deepClone() &#123; // 创建流对象 ByteArrayOutputStream bos = null; ObjectOutputStream oos = null; ByteArrayInputStream bis = null; ObjectInputStream ois = null; try &#123; // 序列化 bos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(bos); oos.writeObject(this); // 当前这个对象以对象流的方式输出 // 反序列化 bis = new ByteArrayInputStream(bos.toByteArray()); ois = new ObjectInputStream(bis); DeepProtoType copyObj = (DeepProtoType)ois.readObject(); return copyObj; &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; finally &#123; // 关闭流 try &#123; bos.close(); oos.close(); bis.close(); ois.close(); &#125; catch (Exception e) &#123; System.out.println(e.getMessage()); &#125; &#125;&#125; 总结创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率；不用重新初始化对象，而是动态地获得对象运行时的状态；如果原始对象发生变化（增加或者减少属性），其它克隆对象的也会发生相应的变化，无需修改代码； 在实现深克隆的时候可能需要比较复杂的代码；缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改其源代码，违背了 ocp 原则。 建造者模式 建造者模式（Builder Pattern）又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。 建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。 角色：Product（产品角色）： 一个具体的产品对象；Builder（抽象建造者）： 创建一个 Product 对象的各个部件指定的 接口/抽象类；ConcreteBuilder（具体建造者）： 实现接口，构建和装配各个部件；Director（指挥者）： 构建一个使用 Builder 接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用：（1）隔离了客户与对象的生产过程（2）负责控制产品对象的生产过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182public class Client &#123; public static void main(String[] args) &#123; // 盖普通房子 CommonHouse commonHouse = new CommonHouse(); // 准备创建房子的指挥者 HouseDirector houseDirector = new HouseDirector(commonHouse); // 完成盖房子，返回产品（普通房子） House house = houseDirector.constructHouse(); System.out.println(\"--------------------------\"); //盖高楼 HighBuilding highBuilding = new HighBuilding(); //重置建造者 houseDirector.setHouseBuilder(highBuilding); //完成盖房子，返回产品（高楼） houseDirector.constructHouse(); &#125;&#125;public class CommonHouse extends HouseBuilder &#123; @Override public void buildBasic() &#123; System.out.println(\" 普通房子打地基 5 米 \"); &#125; @Override public void buildWalls() &#123; System.out.println(\" 普通房子砌墙 10cm \"); &#125; @Override public void roofed() &#123; System.out.println(\" 普通房子屋顶 \"); &#125;&#125;public class HighBuilding extends HouseBuilder &#123; @Override public void buildBasic() &#123; System.out.println(\" 高楼的打地基 100 米 \"); &#125; @Override public void buildWalls() &#123; System.out.println(\" 高楼的砌墙 20cm \"); &#125; @Override public void roofed() &#123; System.out.println(\" 高楼的透明屋顶 \"); &#125;&#125;public class House &#123; private String baise; private String wall; private String roofed; // Getter / Setter&#125;// 抽象的建造者public abstract class HouseBuilder &#123; protected House house = new House(); // 将建造的流程写好, 抽象的方法 public abstract void buildBasic(); public abstract void buildWalls(); public abstract void roofed(); // 建造房子好， 将产品返回 public House buildHouse() &#123; return house; &#125;&#125;public class HouseDirector &#123; HouseBuilder houseBuilder = null; // 构造器传入 houseBuilder public HouseDirector(HouseBuilder houseBuilder) &#123; this.houseBuilder = houseBuilder; &#125; // 如何处理建造房子的流程，交给指挥者 public House constructHouse() &#123; houseBuilder.buildBasic(); houseBuilder.buildWalls(); houseBuilder.roofed(); return houseBuilder.buildHouse(); &#125;&#125; Factory VS. Builder抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。 建造者模式则是要求按照指定的蓝图建造产品，可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程它的主要目的是通过组装零配件而产生一个新品；建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://yoursite.com/tags/Design-Patterns/"}]},{"title":"设计模式","slug":"Java/DesignPatterns/设计模式","date":"2020-03-20T02:21:09.000Z","updated":"2020-03-21T07:58:21.606Z","comments":true,"path":"2020/03/20/Java/DesignPatterns/设计模式/","link":"","permalink":"http://yoursite.com/2020/03/20/Java/DesignPatterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"Java 设计模式。","text":"Java 设计模式。 七大原则 核心思想： 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起；针对接口编程，而不是针对实现编程；为了交互对象之间的松耦合设计而努力。 单一职责原则接口隔离原则依赖倒转（倒置）原则里氏替换原则开闭原则迪米特法则合成复用原则 单一职责 此原则是对于类来说的，即一个类应该只负责一项职责。 123456789101112131415class RoadVehicle &#123; public void run(String vehicle) &#123; System.out.println(vehicle + \"公路运行\"); &#125;&#125;class AirVehicle &#123; public void run(String vehicle) &#123; System.out.println(vehicle + \"天空运行\"); &#125;&#125;class WaterVehicle &#123; public void run(String vehicle) &#123; System.out.println(vehicle + \"水中运行\"); &#125;&#125; 在方法级别上遵守单一职责 12345678910class Vehicle &#123; public void runRoad(String vehicle) &#123; System.out.println(vehicle + \" 在公路上运行...\"); &#125; public void runAir(String vehicle) &#123; System.out.println(vehicle + \" 在天空上运行...\"); &#125; public void runWater(String vehicle) &#123; System.out.println(vehicle + \" 在水中行...\"); &#125; 降低类的复杂度，一个类只负责一项职责；提高类的可读性，可维护性；降低变更引起的风险；通常情况下，我们应当遵守单一职责原则，只有逻辑足够简单，才可以在代码级违反单一职责原则；只有类中方法数量足够少，可以在方法级别保持单一职责原则。 接口隔离 即一个类对另一个类的依赖应该建立在最小的接口上。 不符合接口隔离原则的设计： 123456789101112131415161718192021222324252627282930313233// 接口有 5 个抽象方法，则每个实现了此接口的类都需要实现这 5 个抽象方法interface Interface1 &#123; void operation1(); void operation2(); void operation3(); void operation4(); void operation5();&#125;// Class B、D 省略class A &#123; //A 类通过接口 Interface1 依赖(使用) B 类，但是只会用到 1,2,3 方法 public void depend1(Interface1 i) &#123; i.operation1(); &#125; public void depend2(Interface1 i) &#123; i.operation2(); &#125; public void depend3(Interface1 i) &#123; i.operation3(); &#125;&#125;class C &#123; //C 类通过接口 Interface1 依赖(使用) D 类，但是只会用到 1,4,5 方法 public void depend1(Interface1 i) &#123; i.operation1(); &#125; public void depend4(Interface1 i) &#123; i.operation4(); &#125; public void depend5(Interface1 i) &#123; i.operation5(); &#125;&#125; 类 A 通过接口 Interface1 依赖类 B，类 C 通过接口 Interface1 依赖类 D，如果接口 Interface1 对于类 A 和类 C来说不是最小接口，那么类 B 和类 D 必须去实现他们不需要的方法； 将接口 Interface1 拆分为独立的几个接口，类 A 和类 C 分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则 接口 Interface1 中出现的方法，根据实际情况拆分为三个。 符合接口隔离原则的设计： 1234567891011121314151617181920212223interface Interface1 &#123; void operation1();&#125;interface Interface2 &#123; void operation2(); void operation3();&#125;interface Interface3 &#123; void operation4(); void operation5();&#125;// 测试public static void main(String[] args) &#123; A a = new A(); a.depend1(new B()); // A 类通过接口去依赖 B 类 a.depend2(new B()); a.depend3(new B()); C c = new C(); c.depend1(new D()); // C 类通过接口去依赖(使用) D 类 c.depend4(new D()); c.depend5(new D());&#125; 依赖倒转 依赖倒转原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础的架构要稳定的多。在 java 中，抽象指的是接口或抽象类，细节就是具体的实现类，使用接口或抽象类的目的是制定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成： 高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象；依赖倒转（倒置）的中心思想是面向接口编程； 123456789101112131415161718192021222324252627282930public class DependecyInversion &#123; public static void main(String[] args) &#123; // 客户端无需改变 Person person = new Person(); person.receive(new Email()); person.receive(new WeiXin()); &#125;&#125;class Person &#123; // 这里我们是对接口的依赖，不需要考虑接口的具体实现 public void receive(IReceiver receiver) &#123; System.out.println(receiver.getInfo()); &#125;&#125;// 定义接口interface IReceiver &#123; public String getInfo();&#125;// 实现类进行是实现class Email implements IReceiver &#123; public String getInfo() &#123; return \"电子邮件信息: hello,world\"; &#125;&#125;// 实现类进行实现class WeiXin implements IReceiver &#123; public String getInfo() &#123; return \"微信信息: hello,ok\"; &#125;&#125; 依赖传递 接口传递；构造方法传递；Setter 方法传递。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 方式一：通过接口传递实现依赖interface IOpenAndClose &#123; public void open(ITV tv); // 抽象方法，接收接口实现以来传递&#125;interface ITV &#123; public void play();&#125;class OpenAndClose implements IOpenAndClose&#123; public void open(ITV tv)&#123; tv.play(); &#125;&#125;class ChangHong implements ITV &#123; @Override public void play() &#123; System.out.println(\"长虹电视机，打开\"); &#125;&#125;// 方式二：通过构造方法依赖interface IOpenAndClose &#123; public void open();&#125;interface ITV &#123; public void play();&#125;class OpenAndClose implements IOpenAndClose&#123; private ITV tv; // 成员 public OpenAndClose(ITV tv)&#123; // 构造器 this.tv = tv; &#125; public void open()&#123; this.tv.play(); &#125;&#125;// 方式三：通过 Setter 方法传递interface IOpenAndClose &#123; public void open(); public void setTv(ITV tv); // Setter 方法&#125;interface ITV &#123; public void play();&#125;class OpenAndClose implements IOpenAndClose &#123; private ITV tv; public void setTv(ITV tv) &#123; this.tv = tv; &#125; public void open() &#123; this.tv.play(); &#125;&#125; 里氏替换 继承在给程序设计带来便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能产生故障。 用于解决如何正确使用继承？ 👉 里氏替换原则 所有引用基类的地方必须能透明地使用其子类的对象；在子类中尽量不要重写父类的方法；继承实际上让两个类耦合性增强了，在适当的情况下可以通过聚合、组合、依赖来解决问题。 1234567891011121314151617181920212223242526272829public class Liskov &#123; public static void main(String[] args) &#123; A a = new A(); System.out.println(\"11-3=\" + a.func1(11, 3)); System.out.println(\"1-8=\" + a.func1(1, 8)); System.out.println(\"-----------------------\"); B b = new B(); System.out.println(\"11-3=\" + b.func1(11, 3)); // 这里本意是求出 11-3 System.out.println(\"1-8=\" + b.func1(1, 8)); // 1-8 System.out.println(\"11+3+9=\" + b.func2(11, 3)); &#125;&#125;class A &#123; // 返回两个数的差 public int func1(int num1, int num2) &#123; return num1 - num2; &#125;&#125;// B 类继承了 A 并且增加了一个新功能：完成两个数相加，然后和 9 求和class B extends A &#123; // 这里重写了 A 类的方法, 造成原有方法错误 public int func1(int a, int b) &#123; return a + b; &#125; public int func2(int a, int b) &#123; return func1(a, b) + 9; &#125;&#125; 改进方案：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合、组合等关系代替。 123456789101112131415class B extends Base &#123; // 如果 B 需要使用 A 类的方法，使用组合关系 private A a = new A(); // 此方法不再是重写方法 public int func1(int a, int b) &#123; return a + b; &#125; public int func2(int a, int b) &#123; return func1(a, b) + 9; &#125; // 使用 A 类的方法 public int func3(int a, int b) &#123; return this.a.func1(a, b); &#125;&#125; 开闭原则 类，模块和函数应该对扩展开放（对提供方），对修改关闭（对使用方）。用抽象构建框架，用实现扩展细节；当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Ocp &#123; public static void main(String[] args) &#123; GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); &#125;&#125;// 此写法当发生扩展时，比如添加可以绘制的图形类型，需要修改使用方// 这是一个用于绘图的类，此类为使用方class GraphicEditor &#123; // 接收 Shape 对象，然后根据 type，来绘制不同的图形 public void drawShape(Shape s) &#123; if (s.m_type == 1) drawRectangle(s); else if (s.m_type == 2) drawCircle(s); else if (s.m_type == 3) drawTriangle(s); &#125; // 绘制矩形 public void drawRectangle(Shape r) &#123; System.out.println(\" 绘制矩形 \"); &#125; // 绘制圆形 public void drawCircle(Shape r) &#123; System.out.println(\" 绘制圆形 \"); &#125; // 绘制三角形 public void drawTriangle(Shape r) &#123; System.out.println(\" 绘制三角形 \"); &#125;&#125;// Shape 类，基类class Shape &#123; int m_type;&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125;&#125; 违反了设计模式的 OCP 原则，即对扩展开放(提供方)，对修改关闭(使用方)。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码。 就单一职责而言，使用方类的职责就只有使用而已，至于如何去进行实现这些细节不应该在此类中出现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class Ocp &#123; public static void main(String[] args) &#123; GraphicEditor graphicEditor = new GraphicEditor(); graphicEditor.drawShape(new Rectangle()); graphicEditor.drawShape(new Circle()); graphicEditor.drawShape(new Triangle()); graphicEditor.drawShape(new OtherGraphic()); &#125;&#125;class GraphicEditor &#123; // 仅仅是使用 draw() 方法 public void drawShape(Shape s) &#123; s.draw(); &#125;&#125;abstract class Shape &#123; int m_type; public abstract void draw(); //抽象方法&#125;class Rectangle extends Shape &#123; Rectangle() &#123; super.m_type = 1; &#125; @Override public void draw() &#123; System.out.println(\" 绘制矩形 \"); &#125;&#125;class Circle extends Shape &#123; Circle() &#123; super.m_type = 2; &#125; @Override public void draw() &#123; System.out.println(\" 绘制圆形 \"); &#125;&#125;//新增画三角形class Triangle extends Shape &#123; Triangle() &#123; super.m_type = 3; &#125; @Override public void draw() &#123; System.out.println(\" 绘制三角形 \"); &#125;&#125;//新增一个图形class OtherGraphic extends Shape &#123; OtherGraphic() &#123; super.m_type = 4; &#125; @Override public void draw() &#123; System.out.println(\" 绘制其它图形 \"); &#125;&#125; 迪米特法则 一个对象应该对其他对象保持最少的了解；类与类关系越密切，耦合度越大。 迪米特法则(Demeter Principle)又叫最少知道原则，即一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类不管多么复杂，都尽量将逻辑封装在类的内部。对外除了提供的 public 方法，不对外泄露任何信息。 迪米特法则还有个更简单的定义：只与直接的朋友通信。直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖，关联，组合，聚合等。其中，我们称出现成员变量，方法参数，方法返回值中的类为直接的朋友，而出现在局部变量中的类不是直接的朋友。也就是说，陌生的类最好不要以局部变量的形式出现在类的内部。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public class Demeter &#123; public static void main(String[] args) &#123; // 创建了一个 SchoolManager 对象 SchoolManager schoolManager = new SchoolManager(); // 输出学院的员工 id 和学校总部的员工信息 schoolManager.printAllEmployee(new CollegeManager()); &#125;&#125;// 学校总部员工类class Employee &#123; private String id; public void setId(String id) &#123; this.id = id; &#125; public String getId() &#123; return id; &#125;&#125;// 学院的员工类class CollegeEmployee &#123; private String id; public void setId(String id) &#123; this.id = id; &#125; public String getId() &#123; return id; &#125;&#125;// 管理学院员工的管理类class CollegeManager &#123; // 返回学院的所有员工 public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; List&lt;CollegeEmployee&gt; list = new ArrayList&lt;CollegeEmployee&gt;(); for (int i = 0; i &lt; 10; i++) &#123; //这里我们增加了 10 个员工到 list CollegeEmployee emp = new CollegeEmployee(); emp.setId(\"学院员工 id= \" + i); list.add(emp); &#125; return list; &#125;&#125;// 学校管理类// 分析 SchoolManager 类的直接朋友类有哪些 Employee、CollegeManagerclass SchoolManager &#123; // 返回学校总部的员工 public List&lt;Employee&gt; getAllEmployee() &#123; List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;(); for (int i = 0; i &lt; 5; i++) &#123; // 这里我们增加了 5 个员工到 list Employee emp = new Employee(); emp.setId(\"学校总部员工 id= \" + i); list.add(emp); &#125; return list; &#125; // 该方法完成输出学校总部和学院员工信息(id) void printAllEmployee(CollegeManager sub) &#123; // 获取到学院员工 CollegeEmployee 不是直接朋友而是一个陌生类，这样违背了迪米特法则 List&lt;CollegeEmployee&gt; list1 = sub.getAllEmployee(); System.out.println(\"------------学院员工------------\"); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125; // 获取到学校总部员工 List&lt;Employee&gt; list2 = this.getAllEmployee(); System.out.println(\"------------学校总部员工------------\"); for (Employee e : list2) &#123; System.out.println(e.getId()); &#125; &#125;&#125; 简单来讲，SchoolManager 只关心自己的雇员 Employ，对于 CollegeManager 的雇员 CollegeEmployee，与它没有什么直接的关系（陌生类）。若需要 CollegeEmployee 的相关信息，CollegeManager 只需通过它的下级部门 CollegeManager 获取。 12345678910111213141516171819class CollegeManager &#123; public List&lt;CollegeEmployee&gt; getAllEmployee() &#123; List&lt;CollegeEmployee&gt; list = new ArrayList&lt;CollegeEmployee&gt;(); for (int i = 0; i &lt; 10; i++) &#123; CollegeEmployee emp = new CollegeEmployee(); emp.setId(\"学院员工 id= \" + i); list.add(emp); &#125; return list; &#125; // 学院的雇员由学院负责 public void printEmployee() &#123; List&lt;CollegeEmployee&gt; list1 = getAllEmployee(); System.out.println(\"------------学院员工------------\"); for (CollegeEmployee e : list1) &#123; System.out.println(e.getId()); &#125; &#125;&#125; 合成复用 原则是尽量使用合成/聚合的方式，而不是使用继承。 UML 类图 依赖（Dependency）：元素 A 的变化会影响元素 B，但反之不成立，那么 B 和 A 的关系是依赖关系，B 依赖 A；类属关系和实现关系在语义上讲也是依赖关系，但由于其有更特殊的用途，所以被单独描述。UML 中用带箭头的虚线表示 Dependency 关系，箭头指向被依赖元素。 泛化（Generalization）：通常所说的继承（B is kind of A）关系，UML 中用带空心箭头的实线线表示 Generalization 关系，箭头指向 A。 实现（Realize）：元素 A 定义一个约定，元素 B 实现这个约定，则 B 和 A 的关系是 Realize，B realize A。这个关系最常用于接口。UML 中用空心箭头和虚线表示 Realize 关系，箭头指向定义约定的元素。 关联（Association）：元素间的结构化关系，是一种弱关系，被关联的元素间通常可以被独立的考虑。UML 中用带箭头实线表示 Association 关系，箭头指向被依赖元素。 聚合（Aggregation）：关联关系的一种特例，表示部分和整体（All has a Part）的关系。UML 中用带空心菱形头的实线表示 Aggregation 关系，菱形头指向整体。 组合（Composition）：组合是聚合关系的变种，表示元素间更强的组合关系。如果是组合关系，如果整体被破坏则个体一定会被破坏，而聚合的个体则可能是被多个整体所共享的，不一定会随着某个整体的破坏而被破坏。UML 中用带实心菱形头的实线表示 Composition 关系，菱形头指向整体。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://yoursite.com/tags/Design-Patterns/"}]},{"title":"Python 爬虫","slug":"Python/Python 爬虫","date":"2020-03-16T07:09:15.000Z","updated":"2020-04-08T06:21:07.891Z","comments":true,"path":"2020/03/16/Python/Python 爬虫/","link":"","permalink":"http://yoursite.com/2020/03/16/Python/Python%20%E7%88%AC%E8%99%AB/","excerpt":"Python 爬虫相关的知识。","text":"Python 爬虫相关的知识。 Urllib 库12345import urllib2 request = urllib2.Request(\"http://www.baidu.com\")response = urllib2.urlopen(request)print response.read() Post &amp; Get123456789import urllibimport urllib2 values = &#123;\"username\":\"1016903103@qq.com\",\"password\":\"XXXX\"&#125;data = urllib.urlencode(values) url = \"https://passport.csdn.net/account/login?from=http://my.csdn.net/my/mycsdn\"request = urllib2.Request(url,data)response = urllib2.urlopen(request)print response.read() 123456789101112import urllibimport urllib2 values=&#123;&#125;values['username'] = \"1016903103@qq.com\"values['password']=\"XXXX\"data = urllib.urlencode(values) url = \"http://passport.csdn.net/account/login\"geturl = url + \"?\"+datarequest = urllib2.Request(geturl)response = urllib2.urlopen(request)print response.read() 构建消息头1234567891011import urllib import urllib2 url = 'http://www.server.com/login'user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)' values = &#123;'username' : 'cqc', 'password' : 'XXXX' &#125; headers = &#123; 'User-Agent' : user_agent &#125; data = urllib.urlencode(values) request = urllib2.Request(url, data, headers) response = urllib2.urlopen(request) page = response.read() Proxy 设置12345678910import urllib2enable_proxy = Trueproxy_handler = urllib2.ProxyHandler(&#123;\"http\" : 'http://some-proxy.com:8080'&#125;)null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)if enable_proxy: opener = urllib2.build_opener(proxy_handler)else: opener = urllib2.build_opener(null_proxy_handler)urllib2.install_opener(opener) 爬取 TED 文章1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: utf-8 -*import codecsimport bs4from bs4 import BeautifulSoupimport requestsimport re# 用户输入网址，例子：https://www.ted.com/talks/Xxx_Xxx_X...input_url = raw_input('Please Enter Article URL: ')url = input_url + '/transcript'# 获取文章标题url_str = url.split('/')title_ = url_str[4]title_str = title_.split('_')title = ''author = ''num = 0for str in title_str: num = num + 1 if(num &gt; 2): if(num == 3): str = str.capitalize() title = title + str + ' ' else: author = author + str.capitalize()print \"Title:\" + titleprint \"Author:\" + author# 获取文章html = requests.get(url).content soup = BeautifulSoup(html, 'html.parser', from_encoding='utf-8')divs = soup.find_all('div', class_=\"Grid__cell flx-s:1 p-r:4\")article = title + '\\n'rude_t = re.compile(r'\\t')rude_n = re.compile(r'\\n')for div in divs: for string in div.stripped_strings: string = rude_t.sub('', string) string = rude_n.sub(' ', string) article = article + string article = article + '\\n'article = article + '\\n'file = codecs.open(\"TED.txt\",\"a\",\"utf-8\")file.write(article)file.close()print \"Finish!\"","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Crawler","slug":"Crawler","permalink":"http://yoursite.com/tags/Crawler/"}]},{"title":"Python 基础","slug":"Python/Python 基础","date":"2020-03-16T06:00:32.000Z","updated":"2020-03-16T07:08:28.827Z","comments":true,"path":"2020/03/16/Python/Python 基础/","link":"","permalink":"http://yoursite.com/2020/03/16/Python/Python%20%E5%9F%BA%E7%A1%80/","excerpt":"Python 入门。","text":"Python 入门。 Python 基础输入和输出12name = raw_input('please enter your name: ') # 输入为字符串形式 int()print 'hello,', name 字符串转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\，如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义。 如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容。 12345678print '''line1... line2... line3'''## 输出结果# line1# line2# line3 占位符 占位符 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 12'Hi, %s, you have $%d.' % ('Michael', 1000000)# 'Hi, Michael, you have $1000000.' 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。 布尔值可以用and、or和not运算。 空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 变量变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头。 1234567891011a = 'ABC' # 在内存中创建了一个 ABC 的字符串；在内存中创建了一个名为 a 的变量，并把它指向 ABC 字符串b = aa = 'XYZ'print b # ABC 字符串&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; b = a.replace('a', 'A')&gt;&gt;&gt; b'Abc'&gt;&gt;&gt; a'abc' list 和 tuplePython 内置的一种数据类型是列表：list。list 是一种有序的集合，可以随时添加和删除其中的元素。 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3&gt;&gt;&gt; classmates[-1]'Tracy'&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam']&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme'] tuple 另一种有序列表叫元组：tuple。tuple 和 list 非常类似，但是 tuple 一旦初始化就不能修改。 1&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy') 错误用法 12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y']) # list 是可以变的 条件判断和循环12345678if &lt;条件判断1&gt;: &lt;执行1&gt;elif &lt;条件判断2&gt;: &lt;执行2&gt;elif &lt;条件判断3&gt;: &lt;执行3&gt;else: &lt;执行4&gt; 1234sum = 0for x in range(101): sum = sum + xprint sum 123456sum = 0n = 99while n &gt; 0: sum = sum + n n = n - 2print sum dict 和 setPython 内置了字典：dict 的支持，dict 全称 dictionary，在其他语言中也称为 map，使用键-值（key-value）存储，具有极快的查找速度。 dict 可以用在需要高速查找的很多地方，在 Python 代码中几乎无处不在，正确使用 dict 非常重要，需要牢记的第一条就是 dict 的 key 必须是不可变对象。 123456789101112&gt;&gt;&gt; d['Adam'] = 67&gt;&gt;&gt; d['Adam']67&gt;&gt;&gt; 'Thomas' in dFalse&gt;&gt;&gt; d.get('Thomas')&gt;&gt;&gt; d.get('Thomas', -1)-1# pop('key') set 和 dict 类似，也是一组 key 的集合，但不存储 value。由于 key 不能重复，所以，在 set 中，没有重复的 key。 1234567891011121314&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; sset([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; sset([1, 2, 3, 4])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; sset([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; sset([1, 2, 3]) 函数内置常用函数在交互式命令行通过help(abs)查看abs函数的帮助信息。 12345678910111213&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 数据类型转换 1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; unicode(100)u'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False 定义函数如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。 1234567def my_abs(x): if not isinstance(x, (int, float)): raise TypeError('bad operand type') if x &gt;= 0: return x else: return -x 12def nop(): pass # 作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个 pass，让代码能运行起来 1234567891011import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) # 返回值是一个tuple，tuple 可以省略括号，而多个变量可以同时接收一个 tuple，按位置赋给对应的值 函数的参数12345678910# 大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数def enroll(name, gender, age=6, city='Beijing'): print 'name:', name print 'gender:', gender print 'age:', age print 'city:', city # 只有与默认参数不符的学生才需要提供额外的信息enroll('Bob', 'M', 7)enroll('Adam', 'M', city='Tianjin') *args是可变参数，args 接收的是一个 tuple； **kw是关键字参数，kw 接收的是一个 dict。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Base","slug":"Base","permalink":"http://yoursite.com/tags/Base/"}]},{"title":"开发常用工具类","slug":"Software/开发常用工具类","date":"2020-03-12T07:31:13.000Z","updated":"2020-03-12T09:54:29.922Z","comments":true,"path":"2020/03/12/Software/开发常用工具类/","link":"","permalink":"http://yoursite.com/2020/03/12/Software/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"记录一下开发中用到的各种小工具类。","text":"记录一下开发中用到的各种小工具类。 加密类Md512345678910111213141516171819202122232425262728293031323334353637383940414243import java.security.MessageDigest;import org.apache.commons.lang3.StringUtils;public class Md5Util &#123; private Md5Util() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** * md5 加密通用工具类 * * @param encode 需加密的字符串 * @return md5 加密后的字符串（32位字符串） */ public static String md5(String encode) &#123; // 检验参数是否是 null 或者 \"\" 或者 \" \" 等 if (StringUtils.isBlank(encode)) &#123; return \"\"; &#125; char[] hexDigits = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; // 设置字符集 byte[] strTemp = encode.getBytes(StandardCharsets.UTF_8); // 生成一个 md5 加密计算摘要 MessageDigest mdTemp = MessageDigest.getInstance(\"MD5\"); // 计算 md5 函数 mdTemp.update(strTemp); // digest() 最后确定返回 md5 hash 值，返回值为 8 位字符串。因为 md5 hash 值是 16 位的 hex 值，实际上就是 8 位的字符 byte[] md = mdTemp.digest(); int j = md.length; char[] str = new char[j * 2]; int k = 0; for (byte byte0 : md) &#123; // 不带符号右移四位(不管 byte0 的类型 位移处补 0)，&amp; 十六进制的 f 即 高四位清空 取低四位的值，&gt;&gt;&gt; 优先级高于 &amp; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return \"\"; &#125; &#125;&#125;","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"}]},{"title":"用户管理系统","slug":"Welab/用户管理系统","date":"2020-03-07T08:44:21.000Z","updated":"2020-04-19T06:45:04.725Z","comments":true,"path":"2020/03/07/Welab/用户管理系统/","link":"","permalink":"http://yoursite.com/2020/03/07/Welab/%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","excerpt":"基于 Spring Boot 的用户管理系统。","text":"基于 Spring Boot 的用户管理系统。 准备工作功能模块分析： 数据库表分析： 数据库建表语句： 1234567891011CREATE TABLE `user_manage_demo` ( `user_id` bigint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '主键id，用户id', `username` varchar(50) NOT NULL COMMENT '用户名', `password` varchar(100) NOT NULL COMMENT '用户密码', `type` char(1) unsigned NOT NULL COMMENT '用户类型（1：管理员；0：普通用户）', `gmt_create` datetime NOT NULL COMMENT '记录创建时间', `gmt_modified` datetime NOT NULL COMMENT '记录修改时间', `is_delete` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '记录是否逻辑删除（0：未删除；1：已删除）', PRIMARY KEY (`user_id`), UNIQUE KEY `uk_name_type` (`username`,`type`) USING BTREE COMMENT '用户名称、类型唯一索引') ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8mb4 COMMENT='用户管理表'; 在数据库表中初始化一条管理员数据： 1234INSERT INTO `springboot_user`.`user` (`user_id`, `username`, `password`, `type`, `gmt_create`, `gmt_modified`, `is_delete`) VALUES (1, 'admin', '123456', \"1\", '2019-05-19 20:26:22', '2019-05-19 20:26:27', 0); 接口的设计 为了项目代码更加简洁，此项目添加了 Lombok 支持依赖并且 IDEA 添加了相应的 Lombok 插件，通过在类注释@Data为相应的类添加Getter/Setter，toString()，equals() 等方法。 123456&lt;!-- 添加 Lombok 的支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 将前端传输过来的的数据封装在对应的 DTO 类中，用于展示层与服务层之间的数据传输对象。（View 👉 Action 👉 Srvice） DTO：Data Transfer Object（数据传输对象）DTO 是一组需要跨进程或网络边界传输的聚合数据的简单容器。它不应该包含业务逻辑，并将其行为限制为诸如内部一致性检查和基本验证之类的活动。 将返回前端的数据封装在对应的 VO 类中。 VO：View Object（视图对象）VO 的作用是把某个指定页面（或组件）的所有数据封装起来。 DTO 类的编写在 DTO 类中添加 JSR303 校验。 JSR303 是一项标准，JSR-349 是其的升级版本，添加了一些新特性，他们规定一些校验规范即校验注解，如 @Null，@NotNull，@Pattern，在 javax.validation.constraints 包下，只提供规范不提供实现。 Hibernat Validation 是对这个规范的实践（不要将 Hibernate 和数据库 ORM 框架联系在一起），他提供了相应的实现，并增加了一些其他校验注解，如@Email，@Length，@Range等等，在 org.hibernate.validator.constraints 包下。 Spring 为了给开发者提供便捷，对 Hibernate Validation 进行了二次封装，显示校验 Validated Bean 时，你可以使用 Spring validation 或者 Hibernate validation，而 Spring Validation 另一个特性，便是其在 Spring MVC 模块中添加了自动校验，并将校验信息封装进了特定的类中。这无疑便捷了我们的 web 开发。 12345678910111213141516171819202122232425/*** DTO 类示例* @NotBlank 用于 String（会去掉空格）* @NotNull 用于 Integer* @Data 自动生成 Getter/Setter，toString()，equals() 等方法*/@Datapublic class LoginDTO implements Serializable &#123; private static final long serialVersionUID = 1L; /** 用户名 */ @NotBlank(message = \"用户名不能为空\") private String username; /** 用户密码 */ @NotBlank(message = \"用户密码不能为空\") private String password; /** 验证码 */ @NotBlank(message = \"验证码不能为空\") private String checkCode; /** 类型 */ @NotNull(message = \"用户类型不能为空\") private String type;&#125; VO 类的编写 12345678910111213141516171819/*** VO 类示例* 管理员用户列表页面的用户信息返回对象*/@Datapublic class ViewVO implements Serializable &#123; private static final long serialVersionUID = 1L; /** 用户标识 */ private Integer userId; /** 用户名 */ private String username; /** 用户类型 */ private String type; /** 用户创建时间 */ private Date gtmCreate;&#125; 静态常量类将项目中一些固定的字面量定义为不可变的静态常量public static final。 UrlConstant123456789101112131415161718192021222324/*** URL 静态常量类*/public final class UrlConstant &#123; /** 添加私有的构造函数，防止静态常量类构造其它的实例，然后改变静态常量的值 */ private UrlConstant() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** 跳转首页 URL */ public static final String INDEX = \"/index\"; /** 跳转注册 URL */ public static final String REGISTER = \"/register\"; /** 跳转登录 URL */ public static final String LOGIN = \"/login\"; /** 跳转查看用户列表 URL */ public static final String VIEW = \"/view\"; /** 跳转新增用户 URL */ public static final String USER = \"/user\"; /** 跳转修改用户信息 URL */ public static final String MODIFY = \"/modify\";&#125; UserTypeConstant12345678910111213141516171819202122232425262728293031/*** 用户类型静态常量类*/public final class UserTypeConstant &#123; /** 添加私有的构造函数，防止静态常量类构造其它的实例，然后改变静态常量的值 */ private UserTypeConstant() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** 管理员用户 */ public static final String ADMIN = 1; /** 普通用户 */ public static final String ORDINARY = 0; /** * 用户类型代码转描述 * * @param type 用户类型 * @return 用户类型中文描述 */ public static String typeToDesc(Sting type) &#123; if (UserTypeConstant.ADMIN.equals(type)) &#123; return \"管理员\"; &#125; else if (UserTypeConstant.ORDINARY.equals(type)) &#123; return \"普通用户\"; &#125; else &#123; return \"未知身份，请联系系统管理员\"; &#125; &#125; ImageCodeConstant123456789101112131415161718192021222324252627public final class ImageCodeConstant &#123; /** 添加私有的构造函数，防止静态常量类构造其它的实例，然后改变静态常量的值 */ private ImageCodeConstant() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** 验证码生成的时间 */ public static final String CODE_TIME = \"codeTime\"; /** 验证码过期时间，单位：分钟 */ public static final int CAPTCHA_EXPIRY_TIME = 5; /** 秒/毫秒换算 */ public static final int MILLISECOND_CONVERSION = 1000; /** 分钟/秒换算 */ public static final int MINUTE_CONVERSION = 60; /** 生成验证码的变量名称 */ public static final String SIMPLE_CAPTCHA = \"simpleCaptcha\"; /** 生成验证码的变量值 */ public static final String CAPTCHA_VALUE = \"captchaValue\"; /** 生成的验证码图形的变量名 */ public static final String IMAGE = \"image\"; /** 生成的图形验证码文件格式化的名称 */ public static final String JPEG = \"JPEG\"; /** 图片字符涉及的罗马字体名 */ public static final String TIMES_NEW_ROMAN = \"Times New Roman\";&#125; RespoonseConstant12345678910111213141516171819202122public final class ResponseConstant &#123; /** 添加私有的构造函数，防止静态常量类构造其它的实例，然后改变静态常量的值 */ private ResponseConstant() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** 处理成功时返回的 Code */ public static final String SUCCESS = \"200\"; /** 业务处理失败时返回的 Code */ public static final String FAIL = \"-1\"; /** 返回信息的 Key 常量值 */ public static final String RESPONSE_VO = \"responseVO\"; /** 返回状态码常量值 */ public static final String CODE = \"code\"; /** 返回状态信息常量值 */ public static final String MESSAGE = \"message\"&#125; UserConstant1234567891011121314public final class UserConstant &#123; /** 添加私有的构造函数，防止静态常量类构造其它的实例，然后改变静态常量的值 */ private UserConstant() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** Session 中的用户名常量的字段名称，多处使用统一在这里定义，避免 SonarLint 魔法值的告警 */ public static final String USERNAME = \"username\"; /** Session 中的用户类型常量的字段名称，多处使用统一在这里定义，避免 SonarLint 魔法值的告警 */ public static final String TYPE = \"type\"; /** Session 中的用户类型名称常量的字段名称，多处使用统一在这里定义，避免 SonarLint 魔法值的告警 */ public static final String TYPE_NAME = \"typeName\";&#125; 工具类MD5 密码加密1234567891011121314151617181920212223242526272829303132333435363738394041public class Md5Util &#123; private Md5Util() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** * md5 加密通用工具类 * * @param encode 需加密的字符串 * @return md5 加密后的字符串（32位字符串） */ public static String md5(String encode) &#123; // 检验参数是否是 null 或者 \"\" 或者 \" \" 等 if (StringUtils.isBlank(encode)) &#123; return \"\"; &#125; char[] hexDigits = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;; try &#123; // 设置字符集 byte[] strTemp = encode.getBytes(StandardCharsets.UTF_8); // 生成一个 md5 加密计算摘要 MessageDigest mdTemp = MessageDigest.getInstance(\"MD5\"); // 计算 md5 函数 mdTemp.update(strTemp); // digest() 最后确定返回 md5 hash 值，返回值为 8 位字符串。因为 md5 hash 值是 16 位的 hex 值，实际上就是 8 位的字符 byte[] md = mdTemp.digest(); int j = md.length; char[] str = new char[j * 2]; int k = 0; for (byte byte0 : md) &#123; // 不带符号右移四位(不管 byte0 的类型 位移处补 0)，&amp; 十六进制的 f 即 高四位清空 取低四位的值，&gt;&gt;&gt; 优先级高于 &amp; str[k++] = hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf]; str[k++] = hexDigits[byte0 &amp; 0xf]; &#125; return new String(str); &#125; catch (Exception e) &#123; return \"\"; &#125; &#125;&#125; 验证码生成123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public class ImageCodeUtil &#123; private ImageCodeUtil() &#123; throw new IllegalStateException(\"Utility class\"); &#125; /** 生成验证码图片的默认宽度 */ private static final int IMAGE_WIDTH = 60; /** 生成验证码图片的默认高度 */ private static final int IMAGE_HEIGHT = 20; /** 随机干扰线的条数，太稀疏或者太密织都达不到干扰的效果 */ private static final int RAND_COLOR = 168; /** 颜色数值的上限，三原色的范围都是 [0, 255] 范围 */ private static final int COLOR_MAX = 255; /** 可根据需要来修改，生成纯数字或者纯字母，或者默认这种混合的 */ private static char[] mapTable = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'&#125;; /** * 生成图形验证码 * * @param width 生成的图形验证码的宽度 * @param height 生成的图形验证码的高度 * @param verifySize 需要生成的验证码位数 * @return 验证码的图片对象及验证码的值 */ public static Map&lt;String, Object&gt; getImageCode(int width, int height, int verifySize) throws NoSuchAlgorithmException &#123; Map&lt;String, Object&gt; returnMap = new HashMap&lt;&gt;(6); // 确保验证码的宽度和高度不能小于或等于零 width = width &lt;= 0 ? IMAGE_WIDTH : width; height = height &lt;= 0 ? IMAGE_HEIGHT : height; // BufferedImage 是 Image 的一个子类，Image 和 BufferedImage // 主要作用就是将一副图片加载到内存中，BufferedImage 生成的图片在内存里有一个图像缓冲区 // 利用这个缓冲区我们可以很方便的操作这个图片，通常用来做图片修改操作如大小变换、图片变灰、设置图片透明或不透明等 BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); // 获取图形上下文 Graphics g = image.getGraphics(); // 生成随机类 Random random = SecureRandom.getInstanceStrong(); // 设定背景色 g.setColor(getRandColor(200, 250)); // 画长方形 g.fillRect(0, 0, width, height); // 设定字体 g.setFont(new Font(ImageCodeConstant.TIMES_NEW_ROMAN, Font.PLAIN, 18)); // 再次设置背景色，实测跟前一次设置背景色有叠加的效果，会让背景颜色看起来更复杂 g.setColor(getRandColor(160, 200)); // 随机产生 168 条干扰线，使图象中的认证码不易被其它程序探测到 for (int i = 0; i &lt; RAND_COLOR; i++) &#123; // nextInt(n) 会返回 [0, n) 之间的随机数 int x = random.nextInt(width); int y = random.nextInt(height); int xl = random.nextInt(12); int yl = random.nextInt(12); // x: 线段起点的横坐标；y: 线段起点的纵坐标；x + xl: 线段终点的横坐标；y + yl: 线段终点的纵坐标 g.drawLine(x, y, x + xl, y + yl); &#125; // 定义验证码的值 StringBuilder captchaValue = new StringBuilder(); // 4代表验证码位数，如果要生成更多位的认证码，则加大数值 for (int i = 0; i &lt; verifySize; ++i) &#123; captchaValue.append(mapTable[random.nextInt(mapTable.length)]); // 将认证码显示到图象中 g.setColor(new Color(20 + random.nextInt(110), 20 + random.nextInt(110), 20 + random.nextInt(110))); // 直接生成 String str = captchaValue.substring(i, i + 1); // 使用此图形上下文的当前字体和颜色绘制由指定 string 给定的文本 g.drawString(str, 13 * i + 6, 16); &#125; // 释放图形上下文资源 g.dispose(); // 组装图像结果及验证码值并返回 returnMap.put(ImageCodeConstant.IMAGE, image); returnMap.put(ImageCodeConstant.CAPTCHA_VALUE, captchaValue.toString()); return returnMap; &#125; /** 给定范围获得随机颜色 */ private static Color getRandColor(int fc, int bc) throws NoSuchAlgorithmException &#123; // 创建一个随机数生成对象的实例 Random random = SecureRandom.getInstanceStrong(); // 颜色值不能超过最大范围 fc = fc &gt; COLOR_MAX ? COLOR_MAX : fc; bc = bc &gt; COLOR_MAX ? COLOR_MAX : bc; // nextInt(n) 会返回 [0, n) 之间的随机数 int r = fc + random.nextInt(bc - fc); int g = fc + random.nextInt(bc - fc); int b = fc + random.nextInt(bc - fc); // 按随机生成的 r、g、b 值设置颜色并返回 return new Color(r, g, b); &#125;&#125; 实体类实体类的属性与数据库的字段相对应。 12345678910111213141516171819202122@Datapublic class UserMybatis &#123; private static final long serialVersionUID = 1L; /** 用户 id */ private Integer userId; /** 用户名 */ private String username; /** 用户密码 */ private String password; /** 用户类型 */ private String type; /** 记录创建时间 */ @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date gmtCreate; /** 记录修改时间 */ @DateTimeFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date gmtModified; /** 记录是否删除 */ private Boolean isDelete;&#125; 数据源配置数据源： 12345678# 数据源配置# serverTimezone=Asia/Shanghai 这种写法也可以# SSL 连接必须显示的进行配置是否使用，否则会报警告# 使用 MySQL80 服务 mysql-connector-java:8.0.19 版本的连接 Jar 包 DriverClass：com.mysql.cj.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/springboot_user?serverTimezone=GMT%2B8&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=falsespring.datasource.username=rootspring.datasource.password=123456spring.datasource.driverClassName=com.mysql.cj.jdbc.Driver 测试数据源是否配置成功： 12345678910111213@RunWith(SpringRunner.class)@SpringBootTestclass JavaSpringWingoApplicationTests &#123; // 测试 DataSource 是否被成功注入 @Autowired DataSource dataSource; @Test void testDataSource() &#123; System.out.println(dataSource.getClass()); // 输出结果 class com.zaxxer.hikari.HikariDataSource Spring Boot 2 的默认连接池 Hikari &#125;&#125; Druid 连接池1234567891011121314&lt;!-- 支持阿里 Druid 连接池 --&gt;&lt;!-- 方式一：使用 Spring Boot 提供的启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 方式二：此方式需要自行编写 Druid 配置类引入配置 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;!-- &lt;version&gt;1.1.16&lt;/version&gt; 此版本找不到依赖 --&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt; Druid 配置123456789101112131415161718192021222324252627282930313233343536373839404142## Druid连接池配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSource## Druid 连接池配置spring.datasource.type=com.alibaba.druid.pool.DruidDataSource# 初始化大小、最小、最大spring.datasource.initialSize=1spring.datasource.minIdle=3spring.datasource.maxActive=20# 获取连接等待超时时间spring.datasource.maxWait=60000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.timeBetweenEvictionRunsMillis=30000# 指定获取连接时连接校验的sql查询语句spring.datasource.validationQuery=select 'x'# 获取连接后，确实是否要进行连接空闲时间的检查spring.datasource.testWhileIdle=true# 获取连接检测spring.datasource.testOnBorrow=false# 归还连接检测spring.datasource.testOnReturn=false# 指定连接校验查询的超时时间spring.datasource.validationQueryTimeout=600000# 配置一个连接在池总最小生存的时间spring.datasource.minEvictableIdleTimeMillis=300000# 打开 PSCache，并且指定每个连接上 Cache 的大小spring.datasource.poolPreparedStatements=truespring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的 filter，去掉后监控界面 sql 无法统计，wall 用于防火墙，stat 用于监控统计spring.datasource.filters=stat,wall,slf4j# 通过 connectProperties 属性来打开 mergeSql 功能，慢 sql 记录等spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.logSlowSql=true;druid.stat.slowSqlMillis=5000## druid连接池监控 访问 URL：locahost:8080/druid # 需要账号密码才能访问控制台，默认为rootspring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123# 访问路径为/druid时，跳转到StatViewServletspring.datasource.druid.stat-view-servlet.url-pattern=/druid/*# 是否能够重置数据spring.datasource.druid.stat-view-servlet.reset-enable=false# 排除一些静态资源，以提高效率spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* 再次测试控制台输出的 DataSource 的类型为 com.alibaba.druid.pool.DruidDataSource。 整合 Mybatis123456&lt;!-- 支持 MyBatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 配置 Mapper123456## MyBatis 配置# 配置别名 parameterType 直接使用类名mybatis.typeAliasesPackage=com.wingo.user.entitymybatis.mapperLocations=classpath:mapping/*.xml# 打印 MyBatis 执行的 SQL 打印出来mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl Mybatis 编写数据库操作的方法对应的 XxxMapper.java 接口类，以及对应的 XxxMapper.xml 配置类，配置类用于编写具体的 SQL 语句以便 Mybatis 进行动态实现。 Mapper 接口类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 也可通过在 Spring Boot 运行类上添加 @MapperScan() 注解扫描@Mapper // 扫描此类为 Mybatis 的 mapper 类public interface UserMybatisMapper &#123; /** * 用户注册 / 添加用户：在数据库中添加用户信息 * * @param userMybatis 用户 * @return */ int insert(UserMybatis userMybatis); /** * 用户登录：通过用户名、用户密码和用户类型查询用户信息 * * @param username 用户名 * @param password 用户密码 * @param type 用户类型 * @return */ UserMybatis findUserMybatisByUsernameAndPasswordAndType(String username, String password, String type); /** * 管理员用户管理页面：通过用户类型和用户状态查询用户信息 * * @param type 用户类型 * @param isDelete 用户状态 * @return */ List&lt;UserMybatis&gt; findAllByTypeAndStatus(String type, Integer isDelete); /** * 用户修改密码：通过用户名和用户类修改用户密码 * * @param password 用户密码 * @param username 用户名 * @param type 用户类型 * @param gmtModified 用户修改时间 * @return */ int updatePasswordByUsernameAndType(String password, String username, String type, Date gmtModified); /** * 更新用户信息 * * @param userMybatis 用户 * @return */ int update(UserMybatis userMybatis); /** *管理员删除用户：通过用户标识更新用户状态 * * @param userId 用户标识 * @param gmtModified 用户修改时间 * @return */ int updateStatusByUserId(Integer userId, Date gmtModified); /** * 通过用户名和用户类型查找用户 * * @param username 用户名 * @param type 用户类型 * @return */ UserMybatis findUserMybatisByUsernameAndType(String username, String type);&#125; Mapper 配置实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"com.wingo.user.mapper.UserMybatisMapper\"&gt; &lt;!-- 编写字段与属性的映射关系 --&gt; &lt;resultMap id=\"BaseResultMap\" type=\"com.wingo.user.entity.UserMybatis\"&gt; &lt;result column=\"user_id\" jdbcType=\"INTEGER\" property=\"userId\" /&gt; &lt;result column=\"username\" jdbcType=\"VARCHAR\" property=\"username\" /&gt; &lt;result column=\"password\" jdbcType=\"VARCHAR\" property=\"password\" /&gt; &lt;result column=\"type\" jdbcType=\"CHAR\" property=\"type\" /&gt; &lt;result column=\"gmt_create\" jdbcType=\"TIMESTAMP\" property=\"gmtCreate\" /&gt; &lt;result column=\"gmt_modified\" jdbcType=\"TIMESTAMP\" property=\"gmtModified\" /&gt; &lt;result column=\"is_delete\" jdbcType=\"BIT\" property=\"isDelete\" /&gt; &lt;/resultMap&gt; &lt;insert id=\"insert\" parameterType=\"UserMybatis\" keyProperty=\"userId\" useGeneratedKeys=\"true\"&gt; INSERT INTO user (user_id, username, password,type, gmt_create, gmt_modified, is_delete) VALUES (#&#123;userId&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;type&#125;, #&#123;gmtCreate&#125;, #&#123;gmtModified&#125;, #&#123;isDelete&#125;) &lt;/insert&gt; &lt;select id=\"findUserMybatisByUsernameAndPasswordAndType\" resultMap=\"BaseResultMap\"&gt; SELECT user_id, username, password, type, gmt_create, gmt_modified, is_delete FROM user WHERE username = #&#123;username&#125; AND password = #&#123;password&#125; AND type = #&#123;type&#125; &lt;/select&gt; &lt;select id=\"findAllByTypeAndStatus\" resultMap=\"BaseResultMap\"&gt; SELECT user_id, username, password, type, gmt_create, gmt_modified, is_delete FROM user WHERE type = #&#123;type&#125; AND is_delete = #&#123;isDelete&#125; &lt;/select&gt; &lt;select id=\"findUserMybatisByUsernameAndType\" resultMap=\"BaseResultMap\"&gt; SELECT user_id, username, password, type, gmt_create, gmt_modified, is_delete FROM user WHERE username = #&#123;username&#125; AND type = #&#123;type&#125; &lt;/select&gt; &lt;update id=\"update\" parameterType=\"UserMybatis\"&gt; UPDATE user &lt;set&gt; &lt;if test=\"username != null\"&gt; username = #&#123;username&#125;, &lt;/if&gt; &lt;if test=\"password != null\"&gt; password = #&#123;password&#125;, &lt;/if&gt; &lt;if test=\"type != null\"&gt; type = #&#123;type&#125;, &lt;/if&gt; &lt;if test=\"gmtCreate != null\"&gt; gmt_create = #&#123;gmtCreate&#125;, &lt;/if&gt; &lt;if test=\"gmtModified != null\"&gt; gmt_modified = #&#123;gmtModified&#125;, &lt;/if&gt; &lt;if test=\"isDelete != null\"&gt; is_delete = #&#123;isDelete&#125; &lt;/if&gt; &lt;/set&gt; WHERE user_id = #&#123;userId&#125; &lt;/update&gt; &lt;update id=\"updatePasswordByUsernameAndType\"&gt; UPDATE user SET password = #&#123;password&#125;, gmt_modified = #&#123;gmtModified&#125; where username =#&#123;username&#125; and type = #&#123;type&#125; &lt;/update&gt; &lt;update id=\"updateStatusByUserId\"&gt; UPDATE user SET is_delete = true, gmt_modified = #&#123;gmtModified&#125; WHERE user_id = #&#123;userId&#125; &lt;/update&gt;&lt;/mapper&gt; 编写测试方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RunWith(SpringRunner.class)@SpringBootTestpublic class JavaSpringWingoApplicationTests &#123; @Autowired UserMybatisMapper userMybatisMapper; @Test @Rollback public void testInsert() &#123; Date date = new Date(); UserMybatis userMybatis = new UserMybatis(); userMybatis.setUsername(\"张三\"); userMybatis.setPassword(\"123456\"); userMybatis.setType(\"0\"); userMybatis.setGmtCreate(date); userMybatis.setGmtModified(date); userMybatis.setIsDelete(false); userMybatisMapper.insert(userMybatis); &#125; /** * UserMybatis userMybatis = userMybatisMapper. * findUserMybatisByUsernameAndPasswordAndType(\"张三\",\"123456\",\"0\"); * * List&lt;UserMybatis&gt; list = new ArrayList&lt;&gt;(); * list = userMybatisMapper.findAllByTypeAndStatus(\"0\",0); * Iterator&lt;UserMybatis&gt; iterable = list.iterator(); * while (iterable.hasNext())&#123; * UserMybatis userMybatis = iterable.next(); * System.out.println(userMybatis); * &#125; * * UserMybatis userMybatis = userMybatisMapper.findUserMybatisByUsernameAndType(\"张三\",\"0\"); * * UserMybatis userMybatis = new UserMybatis(); * userMybatis.setUserId(6); * userMybatis.setUsername(\"李四\"); * int result = userMybatisMapper.update(userMybatis); * * Date date = new Date(); * userMybatisMapper.updatePasswordByUsernameAndType(\"654321\",\"李四\",\"0\",date); * * Date date = new Date(); * userMybatisMapper.updateStatusByUserId(6,date); */&#125; 业务逻辑层Mybatis 版本编写项目场景功能的业务逻辑：接收前端传来的信息所封住的 DTO，然后调用 DAO 进行业务逻辑的编写。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173@Service(\"userServiceMybatisImpl\")public class UserServiceMybatisImpl implements UserService &#123; private final UserMybatisMapper userMybatisMapper; public UserServiceMybatisImpl(UserMybatisMapper userMybatisMapper) &#123; this.userMybatisMapper = userMybatisMapper; &#125; /** * 检查此用户是否已经存在 * * @param username 用户名 * @return */ private boolean checkUserDuplicate(String username)&#123; // 定义默认返回 false boolean isDuplicate = false; UserMybatis userMybatis = userMybatisMapper.findUserMybatisByUsernameAndType(username, UserTypeConstant.ORDINARY); // 若此用户存在，则返回 true if(userMybatis!=null)&#123; isDuplicate = true; &#125; return isDuplicate; &#125; private UserMybatis buildUserMybatis(String username, String password)&#123; Date data = new Date(); // 创建用户实体对象并进行赋值 UserMybatis userMybatis = new UserMybatis(); userMybatis.setUsername(username); userMybatis.setPassword(Md5Util.md5(password)); userMybatis.setType(UserTypeConstant.ORDINARY); userMybatis.setGmtCreate(data); userMybatis.setGmtModified(data); userMybatis.setIsDelete(false); return userMybatis; &#125; /** 用户注册 */ @Override @Transactional(rollbackFor = Exception.class) public ResponseVO register(RegisterDTO registerDTO) &#123; // 定义返回对象 ResponseVO responseVO = new ResponseVO(); // 检查此用户是否是否已经存在 if(checkUserDuplicate(registerDTO.getUsername()))&#123; // 组装错误返回对象 responseVO.fail(\"用户名重复，请重新注册！\"); // 返回错误代码及错误信息 return responseVO; &#125; // 创建用户实体对象并进行赋值 UserMybatis userMybatis = buildUserMybatis(registerDTO.getUsername(), registerDTO.getPassword()); // 保存数据到数据库 userMybatisMapper.insert(userMybatis); // 组装成功返回对象 responseVO.success(\"恭喜您，注册成功！请登录\"); return responseVO; &#125; /** 用户登录 */ @Override public ResponseVO login(LoginDTO loginDTO) &#123; ResponseVO responseVO = new ResponseVO(); UserMybatis userMybatis = userMybatisMapper.findUserMybatisByUsernameAndPasswordAndType (loginDTO.getUsername(), Md5Util.md5(loginDTO.getPassword()), loginDTO.getType()); if(userMybatis == null)&#123; responseVO.fail(\"登录失败，用户不存在、已删除或者用户名、密码或类型选择错误！\"); return responseVO; &#125; responseVO.success(\"登录成功！\"); // 构建返回的用户信息 UserVO userVO = new UserVO(); userVO.setUsername(loginDTO.getUsername()); userVO.setType(loginDTO.getType()); responseVO.setData(\"userVO\", userVO); return responseVO; &#125; /** 管理员添加用户 */ @Override @Transactional(rollbackFor = Exception.class) public ResponseVO add(AddDTO addDTO) &#123; // 定义返回对象 ResponseVO responseVO = new ResponseVO(); // 检查此用户是否是否已经存在 if(checkUserDuplicate(addDTO.getUsername()))&#123; // 组装错误返回对象 responseVO.fail(\"用户名重复，请重新添加！\"); // 返回错误代码及错误信息 return responseVO; &#125; // 创建用户实体对象并进行赋值 UserMybatis userMybatis = buildUserMybatis(addDTO.getUsername(), addDTO.getPassword()); // 保存数据到数据库 userMybatisMapper.insert(userMybatis); // 组装成功返回对象 responseVO.success(\"添加成功！\"); return responseVO; &#125; /** 管理员查看用户列表 */ @Override public ResponseVO view() &#123; ResponseVO responseVO = new ResponseVO(); // 定义返回的结果集对象，这种定义方式是对象形式的集合 List&lt;ViewVO&gt; userList = new ArrayList&lt;&gt;(); List&lt;UserMybatis&gt; userMybatisList = userMybatisMapper.findAllByTypeAndStatus(UserTypeConstant.ORDINARY, false); if(userMybatisList == null)&#123; responseVO.fail(\"请求用户列表失败！\"); return responseVO; &#125; for(UserMybatis userMybatis : userMybatisList)&#123; // 创建一个新对象来存储查询出的一条条记录 ViewVO viewVO = new ViewVO(); // 对对象进行赋值 viewVO.setUserId(userMybatis.getUserId()); viewVO.setUsername(userMybatis.getUsername()); viewVO.setType(userMybatis.getType()); viewVO.setGtmCreate(userMybatis.getGmtCreate()); // 将对象放入集合中 userList.add(viewVO); &#125; responseVO.success(\"请求用户列表成功！\"); responseVO.setData(\"viewVO\", userList); return responseVO; &#125; /** 用户修改密码 */ @Override @Transactional(rollbackFor = Exception.class) public ResponseVO modify(ModifyDTO modifyDTO) &#123; ResponseVO responseVO = new ResponseVO(); // 判断是否有新密码且新旧密码是否一致 if(modifyDTO.getNewPassword() != null &amp;&amp; modifyDTO.getConfirmNewPassword() != null &amp;&amp; !modifyDTO.getConfirmNewPassword().equals(modifyDTO.getNewPassword()))&#123; responseVO.fail(\"新密码和确认新密码不一致，请检查！\"); return responseVO; &#125; // 判断用户的原密码是否正确 UserMybatis userMybatis = userMybatisMapper.findUserMybatisByUsernameAndPasswordAndType( modifyDTO.getUsername(), Md5Util.md5(modifyDTO.getPassword()), modifyDTO.getType() ); if(userMybatis == null)&#123; responseVO.fail(\"用户原密码不正确，请检查！\"); return responseVO; &#125; Date date = new Date(); // 确认满足修改条件后对用户信息进行更新 userMybatis.setPassword(Md5Util.md5(modifyDTO.getNewPassword())); userMybatis.setGmtModified(date); userMybatisMapper.update(userMybatis); responseVO.success(\"密码修改成功！\"); return responseVO; &#125; /** 删除用户 */ @Override @Transactional(rollbackFor = Exception.class) public ResponseVO delete(DeleteDTO deleteDTO) &#123; ResponseVO responseVO = new ResponseVO(); Date date = new Date(); int deleteResult = userMybatisMapper.updateStatusByUserId(deleteDTO.getUerId(),date); if(deleteResult != 1)&#123; responseVO.fail(\"删除失败，没有更新到或者更新了多条记录！\"); return responseVO; &#125; responseVO.success(\"用户删除成功！\"); return responseVO; &#125;&#125; 测试用例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071@RunWith(SpringRunner.class)@SpringBootTestpublic class JavaSpringWingoApplicationTests &#123; @Resource(name = \"userServiceMybatisImpl\") UserService userService; /** Md5Util 输出 */ @Test public void testMd5()&#123; System.out.println(Md5Util.md5(\"e10adc3949ba59abbe56e057f20f883e\")); &#125; /** 测试注册接口 */ @Test @Rollback public void testRegister() &#123; // 构造注册的测试数据 RegisterDTO registerDTO = new RegisterDTO(); registerDTO.setUsername(\"Jay\"); registerDTO.setPassword(\"123456\"); // 处理业务 ResponseVO responseVO = userService.register(registerDTO); // 测试断言 assertEquals(ResponseConstant.SUCCESS, responseVO.get(\"code\")); &#125; /** 测试登录接口 */ @Test public void testLogin()&#123; LoginDTO loginDTO = new LoginDTO(); loginDTO.setUsername(\"Tom\"); loginDTO.setPassword(\"123456\"); loginDTO.setType(0); ResponseVO responseVO = userService.login(loginDTO); assertEquals(ResponseConstant.SUCCESS, responseVO.get(\"code\")); &#125; /** 测试添加接口 */ @Test @Rollback public void testAdd()&#123; AddDTO addDTO = new AddDTO(); addDTO.setUsername(\"Tim\"); addDTO.setPassword(\"123456\"); ResponseVO responseVO = userService.add(addDTO); assertEquals(ResponseConstant.SUCCESS, responseVO.get(\"code\")); &#125; /** 测试用户列表接口 */ @Test public void testView()&#123; ResponseVO responseVO = userService.view(); System.out.println(responseVO); assertEquals(ResponseConstant.SUCCESS, responseVO.get(\"code\")); &#125; /** 测试修改密码接口*/ @Test @Rollback public void testModify()&#123; ModifyDTO modifyDTO = new ModifyDTO(); modifyDTO.setUsername(\"Jay\"); modifyDTO.setType(0); modifyDTO.setPassword(\"123456\"); modifyDTO.setNewPassword(\"654321\"); modifyDTO.setConfirmNewPassword(\"654321\"); ResponseVO responseVO = userService.modify(modifyDTO); assertEquals(ResponseConstant.SUCCESS, responseVO.get(\"code\")); &#125;&#125; 控制层Swagger 整合用于浏览器请求测试。 也可采用 Spring Boot 提供的 swagger 的 stater，利用启动器的方式添加依赖，可以直在 Spring Boot 的配置文件中配置 swagger 的配置信息。 1234567891011&lt;!-- 添加 Swagger 的支持 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt; 配置类 1234567891011121314151617@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage(\"com.wingo.user.controller\")) .paths(PathSelectors.any()).build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder().title(\"Swagger RESTful APIs\") .description(\"Swagger API 服务\") .build(); &#125;&#125; 代码编写 Model model：Spring MVC 提供了一个Model用于暴露后端传递给页面的信息，通过addAttribute(K, V)方法添加数据，并且在前端的模板引擎页面通过${K}取得对应的V； HttpServletResponse httpServletResponse：encodeRedirectURL(Url)方法进行页面跳转，跳转的同时携带域中的信息； HttpSession httpSession：setAttribute(K, V)方法在 Session 域中添加信息。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201@Controller@Slf4jpublic class UserController &#123; /** 注入 UserService */ @Resource(name = \"userServiceMybatisImpl\") private UserService userService; /** 处理用户注册的请求 */ @ApiOperation(\"用户注册接口\") @PostMapping(value = \"/register\") public String register(Model model, @Valid @ModelAttribute(value = \"registerDTO\") RegisterDTO registerDTO, HttpServletResponse httpServletResponse) &#123; ResponseVO responseVO = userService.register(registerDTO); model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); if (ResponseConstant.SUCCESS.equals(responseVO.get(ResponseConstant.CODE))) &#123; // 注册成功，重定向到前端登录页面 login.html，并且携带数据过去 return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; // 注册失败，跳转到注册页面，并将失败的信息返回 return httpServletResponse.encodeRedirectURL(UrlConstant.REGISTER); &#125; /** * 生成图形验证码 * * @throws NoSuchAlgorithmException */ @ApiIgnore @GetMapping(value = \"/imageCode\") public String imageCode(HttpServletRequest request, HttpServletResponse response) throws IOException, NoSuchAlgorithmException &#123; OutputStream os = response.getOutputStream(); // 生成验证码 Map&lt;String, Object&gt; map = ImageCodeUtil.getImageCode(60, 20, 4); // 放入客户端的 Session 对象中 request.getSession().setAttribute(ImageCodeConstant.SIMPLE_CAPTCHA, map.get(ImageCodeConstant.CAPTCHA_VALUE).toString().toLowerCase()); // 设置验证码的生成时间，并放入客户端 Session 对象中 request.getSession().setAttribute(ImageCodeConstant.CODE_TIME, System.currentTimeMillis()); // 将生成的验证码图片写到图片输出流 try &#123; ImageIO.write((BufferedImage) map.get(ImageCodeConstant.IMAGE), ImageCodeConstant.JPEG, os); &#125; catch (IOException e) &#123; log.error(\"图形验证码生成异常\"); &#125; return null; &#125; /** 处理用户的登录请求 */ @ApiIgnore @PostMapping(value = \"/login\") public String login(Model model, @Valid @ModelAttribute(value = \"loginDTO\") LoginDTO loginDTO, HttpServletResponse httpServletResponse, HttpSession httpSession) &#123; ResponseVO responseVO = new ResponseVO(); // 取得用户填写的验证码 String checkCode = loginDTO.getCheckCode(); // 从 Session 中取得存入的验证码信息 Object sessionImageCode = httpSession.getAttribute(ImageCodeConstant.SIMPLE_CAPTCHA); // 获取验证码信息失败 if(sessionImageCode == null)&#123; responseVO.fail(\"请填写验证码\"); model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; String code = sessionImageCode.toString(); // 检测验证码 Date date = new Date(); Long codeTime = Long.valueOf(httpSession.getAttribute(ImageCodeConstant.CODE_TIME) + \"\"); // 验证码是否填写正确 if (StringUtils.isBlank(checkCode) || StringUtils.isBlank(code) || !(checkCode.equalsIgnoreCase(code))) &#123; responseVO.fail(\"验证码不一致\"); model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; // 验证码是否过期（有效期为 5 分钟） else if ((date.getTime() - codeTime) / ImageCodeConstant.MILLISECOND_CONVERSION / ImageCodeConstant.MINUTE_CONVERSION &gt; ImageCodeConstant.CAPTCHA_EXPIRY_TIME) &#123; responseVO.fail(\"验证码已过期\"); model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; // 处理用户登录业务 responseVO = userService.login(loginDTO); // 将结果放入 model 中，在模板中可以取到 model 中的值 // 这里就是交互的一个重要地方，我们可以在模板中通过这些属性值访问到数据 model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); // 设置登录 session，模版引擎使用 httpSession.setAttribute(UserConstant.USERNAME, loginDTO.getUsername()); httpSession.setAttribute(UserConstant.TYPE, loginDTO.getType()); // 将类型码转换为中文说明 httpSession.setAttribute(UserConstant.TYPE_NAME, UserTypeConstant.typeToDesc(loginDTO.getType())); // 组装结果返回 if (responseVO == null || !ResponseConstant.SUCCESS.equals(responseVO.get(ResponseConstant.CODE))) &#123; // 登录失败则跳转到前端登录页面 login.html return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; // 登录成功重定向到前端首页 index.html，并且携带数据过去 return httpServletResponse.encodeRedirectURL(UrlConstant.INDEX); &#125; /** 处理查看用户列表的请求 */ @ApiIgnore @GetMapping(value = \"/users\") public String users(Model model, HttpServletResponse httpServletResponse) &#123; // 处理用户列表查看业务 ResponseVO responseVO = userService.view(); model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); // 开始重定向前端用户列表也 view.html，携带数据过去了。 return httpServletResponse.encodeRedirectURL(UrlConstant.VIEW); &#125; /** 处理新增用户的请求 */ @ApiOperation(\"用户新增接口\") @PostMapping(value = \"/user\") public String user(Model model, @Valid @ModelAttribute(value = \"addDTO\") AddDTO addDTO, HttpServletResponse httpServletResponse) &#123; // 处理新增用户业务 ResponseVO responseVO = userService.add(addDTO); // 将处理结果写入到返回对象中 model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); // 用户添加失败，重定向到前端页面 user.html if (responseVO == null || !ResponseConstant.SUCCESS.equals(responseVO.get(ResponseConstant.CODE)))&#123; return httpServletResponse.encodeRedirectURL(UrlConstant.USER); &#125; // 处理成功 responseVO = userService.view(); model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); // 开始重定向，携带数据过去 return httpServletResponse.encodeRedirectURL(UrlConstant.VIEW); &#125; /** 删除用户 */ @ApiOperation(\"删除用户接口\") @GetMapping(value = \"/delete\") public String delete(Model model, @Valid @ModelAttribute(value = \"deleteDTO\") DeleteDTO deleteDTO, HttpServletResponse httpServletResponse) &#123; // 处理逻辑删除用户业务 ResponseVO responseVO = userService.delete(deleteDTO); // 删除失败返回错误信息 if(responseVO.get(ResponseConstant.CODE).equals(ResponseConstant.FAIL))&#123; model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); return httpServletResponse.encodeRedirectURL(UrlConstant.VIEW); &#125; // 删除成功后再查询用户列表数据，返回删除后的最新用户列表数据 responseVO = userService.view(); if (responseVO != null) &#123; model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); &#125; // 逻辑删除用户后，跳转到用户前端列表页 view.jsp return httpServletResponse.encodeRedirectURL(UrlConstant.VIEW); &#125; /** 处理用户信息修改的请求 */ @ApiIgnore @PostMapping(value = \"/modify\") public String toModify(Model model, @Valid @ModelAttribute(value = \"modifyDTO\") ModifyDTO modifyDTO, HttpServletResponse httpServletResponse, HttpSession httpSession) &#123; // 从 Session 中取得用户名字及类型 String strUsername = httpSession.getAttribute(UserConstant.USERNAME).toString(); String strType = httpSession.getAttribute(UserConstant.TYPE).toString(); modifyDTO.setUsername(strUsername); modifyDTO.setType(strType); // 处理用户信息修改业务 ResponseVO responseVO = userService.modify(modifyDTO); // 将结果放入 Model 中，在模板中可以取到 Model 中的值 model.addAttribute(ResponseConstant.RESPONSE_VO, responseVO); if (responseVO == null || !ResponseConstant.SUCCESS.equals(responseVO.get(ResponseConstant.CODE))) &#123; // 修改失败时，继续重定向到前端用户信息修改页面 modify.html return httpServletResponse.encodeRedirectURL(UrlConstant.MODIFY); &#125; // 密码修改成功，从 Session 中删除 user 属性，用户退出登录 httpSession.removeAttribute(UserConstant.USERNAME); httpSession.removeAttribute(UserConstant.TYPE); httpSession.removeAttribute(UserConstant.TYPE_NAME); // 开始重定向前端登录页面 login.html，并且携带数据过去 return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; /** 注销登录 */ @ApiIgnore @GetMapping(value = \"/loginOut\") public String loginOut(HttpSession httpSession, HttpServletResponse httpServletResponse) &#123; // 从 Session 中删除 user 属性，用户退出登录 httpSession.removeAttribute(UserConstant.USERNAME); httpSession.removeAttribute(UserConstant.TYPE); httpSession.removeAttribute(UserConstant.TYPE_NAME); // 开始重定向到前端页面 login.html return httpServletResponse.encodeRedirectURL(UrlConstant.LOGIN); &#125; /** 处理 Get:/index 请求 */ @ApiIgnore @GetMapping(value=\"/index\") public String index(HttpServletResponse httpServletResponse)&#123; // 重定向到前端页面 index.html return httpServletResponse.encodeRedirectURL(UrlConstant.INDEX); &#125; // 省略余下页面跳方法&#125; Thymeleaf引入依赖： 12345&lt;!-- 支持 Thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 配置 Thymeleaf： 1234567## Thymeleaf 配置spring.thymeleaf.prefix=classpath:/templatesspring.thymeleaf.suffix=.htmlspring.thymeleaf.mode=HTMLspring.thymeleaf.servlet.content-type=text/htmlspring.thymeleaf.cache=falsespring.thymeleaf.enabled=true login.html1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p th:if=\"$&#123;responseVO != null &amp;&amp; responseVO.get('message') != null&#125;\" th:text=\"$&#123;responseVO.get('message')&#125;\"&gt;&lt;/p&gt; &lt;form th:action=\"@&#123;/login&#125;\" th:object=\"$&#123;loginDTO&#125;\" method=\"post\"&gt; &lt;div style=\"height: 27px\"&gt; &lt;label for=\"username\"&gt;用户名: &lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" placeholder=\"用户名\" th:value=\"$&#123;registerDTO !=null &amp;&amp; registerDTO.username != null&#125; ? $&#123;registerDTO.username&#125; : ''\" /&gt; &lt;/div&gt; &lt;div style=\"height: 27px\"&gt; &lt;label for=\"password\"&gt;密码: &lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" placeholder=\"密码\"/&gt; &lt;/div&gt; &lt;div style=\"height: 27px\"&gt; &lt;label for=\"checkCode\" class=\"green\"&gt;验证码: &lt;/label&gt; &lt;input id=\"checkCode\" name=\"checkCode\" class=\"checkCode\" type=\"text\" placeholder=\"验证码\" /&gt; &lt;img style=\"cursor: pointer; margin-left: 3px;\" th:src=\"@&#123;/imageCode&#125;\" onclick=\"this.src=this.src + '?' + new Date().valueOf();\" id=\"validateImg\" alt=\"验证码\" class=\"codePic\" title=\"验证码。点击此处更新验证码。\" /&gt; &lt;/div&gt; &lt;div style=\"height: 27px\"&gt; &lt;label for=\"type\"&gt;用户类型: &lt;/label&gt; &lt;select id=\"type\" name=\"type\"&gt; &lt;option type=\"number\" value=\"0\" &gt;普通用户&lt;/option&gt; &lt;option type=\"number\" value=\"1\" &gt;管理员用户&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;input type=\"submit\" value=\"登录\"&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; index.html1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;登录后的首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h4&gt; 欢迎您：&lt;span style=\"color: red\" th:text=\"$&#123;session.username&#125;?$&#123;session.username&#125;:'（您未登录）'\"&gt;&lt;/span&gt;, 用户身份是：&lt;span style=\"color: red\" th:text=\"$&#123;session.typeName&#125;?$&#123;session.typeName&#125;:'（您未登录）'\" &gt;&lt;/span&gt; &lt;/h4&gt; &lt;th:block th:if=\"$&#123;session.username != null&#125;\"&gt; &lt;a th:href=\"@&#123;/users&#125;\" th:if=\"$&#123;session.typeName eq '管理员'&#125;\"&gt;查看用户列表&lt;/a&gt; &lt;a th:href=\"@&#123;/user&#125;\" th:if=\"$&#123;session.typeName eq '管理员'&#125; \"&gt;添加用户&lt;/a&gt; &lt;a th:href=\"@&#123;/modify&#125;\"&gt;修改密码&lt;/a&gt; &lt;a th:href=\"@&#123;/loginOut&#125;\"&gt;注销登录&lt;/a&gt; &lt;/th:block&gt;&lt;/body&gt;&lt;/html&gt; modify.html123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;修改密码&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:if=\"$&#123;responseVO != null &amp;&amp; responseVO.get('message') != null&#125;\" th:text=\"$&#123;responseVO.get('message')&#125;\"&gt;&lt;/p&gt; &lt;th:block th:if=\"$&#123;session.username != null&#125;\"&gt; &lt;form th:action=\"@&#123;/modify&#125;\" th:object=\"$&#123;modifyDTO&#125;\" method=\"post\"&gt; &lt;label for=\"password\"&gt;原密码:&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" /&gt; &lt;br /&gt; &lt;label for=\"newPassword\"&gt;新密码:&lt;/label&gt; &lt;input type=\"password\" name=\"newPassword\" id=\"newPassword\" /&gt; &lt;br /&gt; &lt;label for=\"confirmNewPassword\"&gt;确认新密码:&lt;/label&gt; &lt;input type=\"password\" name=\"confirmNewPassword\" id=\"confirmNewPassword\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"确认修改\"&gt; &lt;/form&gt; &lt;/th:block&gt;&lt;/body&gt;&lt;/html&gt; register.html12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:if=\"$&#123;responseVO != null &amp;&amp; responseVO.get('message') != null&#125;\" th:text=\"$&#123;responseVO.get('message')&#125;\"&gt;&lt;/p&gt; &lt;form th:action=\"@&#123;/register&#125;\" th:object=\"$&#123;registerDTO&#125;\" method=\"post\"&gt; &lt;label for=\"username\"&gt;用户名:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" /&gt; &lt;br /&gt; &lt;label for=\"password\"&gt;密码:&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"注册\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; user.html123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;添加用户&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p th:if=\"$&#123;responseVO != null &amp;&amp; responseVO.get('message') != null&#125;\" th:text=\"$&#123;responseVO.get('message')&#125;\"&gt;&lt;/p&gt; &lt;th:block th:if=\"$&#123;session.username != null &amp;&amp; session.typeName == '管理员'&#125;\"&gt; &lt;form th:action=\"@&#123;/user&#125;\" th:object=\"$&#123;addDTO&#125;\" method=\"post\"&gt; &lt;label for=\"username\"&gt;用户名:&lt;/label&gt; &lt;input type=\"text\" name=\"username\" id=\"username\" /&gt; &lt;br /&gt; &lt;label for=\"password\"&gt;密码:&lt;/label&gt; &lt;input type=\"password\" name=\"password\" id=\"password\" /&gt; &lt;br /&gt; &lt;input type=\"submit\" value=\"添加\"&gt; &lt;/form&gt; &lt;/th:block&gt;&lt;/body&gt;&lt;/html&gt; view.html123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;查看用户列表&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\"&gt; &lt;tr&gt; &lt;td&gt;ID&lt;/td&gt; &lt;td&gt;名字&lt;/td&gt; &lt;td&gt;用户类型&lt;/td&gt; &lt;td&gt;注册时间&lt;/td&gt; &lt;td&gt;操作类型&lt;/td&gt; &lt;/tr&gt; &lt;th:block th:if=\"$&#123;session.username != null &amp;&amp; session.typeName == '管理员'&#125;\"&gt; &lt;!-- 循环展示普通用户清单 --&gt; &lt;th:block th:if=\"$&#123;responseVO.get('data').viewVO != null&#125;\"&gt; &lt;tr th:each=\"ViewVO : $&#123;responseVO.get('data').viewVO&#125;\"&gt; &lt;td th:text=\"$&#123;ViewVO.userId&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;ViewVO.username&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;ViewVO.type&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(ViewVO.gmtCreate, 'yyyy-MM-dd')&#125;\"&gt;&lt;/td&gt; &lt;td&gt;&lt;a th:href=\"@&#123;/delete(uerId=$&#123;ViewVO.userId&#125;)&#125;\"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/th:block&gt; &lt;/th:block&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 过滤器对某些特定页面的访问需要有一定的前提条件：比如用户是否登录，用户是否拥有访问此页面的权限等。要实现这样的功能可以使用 Filter。 过滤器执行顺序：(1) 通过实例化 FilterRegistrationBean 类自定义 Filter，setOrder() 方法可以定义执行顺序。（小的优先）(2) 通过限定类名限定 Filter 的顺序。（默认初始化过滤器时进行了类名的排序） 123456789101112131415161718192021222324252627282930313233@Component@WebFilter(filterName = \"/Filter0Session\", urlPatterns = &#123;\"/index\", \"/add\", \"/modify\", \"/view\", \"/delete\", \"/loginOut\"&#125;)public class Filter0Session implements Filter &#123; private Filter0Session() &#123;&#125; /** 过滤器初始化方法，web 服务器根据配置创建 Filter 实例 */ @Override public void init(FilterConfig fConfig) throws ServletException &#123; // Do nothing. &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; HttpSession httpSession = httpServletRequest.getSession(false); if (httpSession != null &amp;&amp; httpSession.getAttribute(UserConstant.USERNAME) != null) &#123; // 用户已登录则放行 chain.doFilter(request, response); &#125; else &#123; // 检测到用户未登录则跳转重定向到登陆页面 httpServletResponse.sendRedirect(\"/login\"); &#125; &#125; /** 过滤器销毁方法，可以释放过滤器使用的资源 */ @Override public void destroy() &#123; // Do nothing. &#125;&#125; 12345678910111213141516171819202122232425262728293031323334@Component@WebFilter(filterName = \"/Filter1Admin\", urlPatterns = &#123;\"/add\", \"/view\", \"/delete\"&#125;)public class Filter1Admin implements Filter &#123; private Filter1Admin() &#123;&#125; @Override public void init(FilterConfig fConfig) throws ServletException &#123; // Do nothing. &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; HttpSession httpSession = httpServletRequest.getSession(false); // 检测用户是否登录，并且用户类型是否为管理员 if (httpSession != null &amp;&amp; httpSession.getAttribute(UserConstant.USERNAME) != null &amp;&amp; httpSession.getAttribute(UserConstant.TYPE) != null &amp;&amp; UserTypeConstant.ADMIN.equals(httpSession.getAttribute(UserConstant.TYPE))) &#123; chain.doFilter(request, response); &#125; else &#123; httpServletResponse.sendRedirect( \"/login\"); &#125; &#125; @Override public void destroy() &#123; // Do nothing. &#125;&#125; ！！！@ServletComponentScan(value = “com.wingo.user.filter”) 全局异常处理对于前端传输的数据，在 DTO 类中添加 JSR303 校验，在测试的时候发现此校验的抛出异常时，Spring Boot 会自动跳转到默认的 error 页面。原因在于项目中未对此校验索抛出的异常进行处理。先看看校验后所抛出的异常信息。 Spring Boot 默认的错误提示页面： 控制台抛出的异常BindException: org.springframework.validation.BeanPropertyBindingResult: 3 errors 可以在 controller 类中添加 try{ }catch{ } 异常处理块捕捉异常抛出，并进行处理（如返回 Json）。但这样代码很不美观，推荐使用的方式是用注解 @ControllerAdvice + @ExceptionHandler 全局处理 Controller 层异常。 编写全局处理类 12345678910111213141516171819202122232425262728@Slf4j@ControllerAdvice // 声明全局的异常处理类@ResponseBodypublic class GlobalExceptionHandler &#123; // 定义捕捉的异常 @ExceptionHandler(BindException.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public ResponseVO resolveMethodArgumentNotValidException(BindException exception) &#123; ResponseVO response = new ResponseVO(); // 定义字段及校验异常信息的 key / value 结构 Map&lt;String, String&gt; fieldAndMessage = new HashMap&lt;&gt;(16); StringBuilder sb = new StringBuilder(); // 组装字段及校验异常信息 for (FieldError fieldError : exception.getBindingResult().getFieldErrors()) &#123; fieldAndMessage.put(fieldError.getField(), fieldError.getDefaultMessage()); sb.append(fieldError.getField()).append(\":\").append(fieldError.getDefaultMessage()).append(\";\"); &#125; String strField = sb.toString(); // 组装异常信息：从自定义的异常信息枚举类中取得信息 response.setCode(ResponseCodeTypeEnum.PARAMETER_ERROR.getCode()); response.setMessage(ResponseCodeTypeEnum.PARAMETER_ERROR.getMessage()); // 方便调试：将异常统一打印出来 log.warn(\"BindException.class 异常信息: &#123;&#125;\", strField); // 返回 Json return response; &#125;&#125; 运行结果：此时已不显示默认的错误页面，而是显示由用户定义的 Json 字符串。 控制台输出：方便开发调试。 自定义 SQL 日志打印当开启 Mybatis 的默认日志打印，控制台的 SQL 默认打印样式： 自定义拦截器： [Mybatis 插件拦截器]([https://welab-wingo.cn/2020/03/29/Software/Mybatis/Mybatis%20%E6%8F%92%E4%BB%B6%E4%B9%8B%E6%8B%A6%E6%88%AA%E5%99%A8/](https://welab-wingo.cn/2020/03/29/Software/Mybatis/Mybatis 插件之拦截器/)) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170@Slf4j@Component@Intercepts(&#123;@Signature(type = Executor.class, method = \"update\", args = &#123;MappedStatement.class, Object.class&#125;), @Signature(type = Executor.class, method = \"query\", args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)&#125;)public class SqlInterceptor implements Interceptor &#123; private Properties properties; @Override public Object intercept(Invocation invocation) throws Throwable &#123; // MappedStatement 维护了一条 mapper.xml 文件里面 select 、update、delete、insert 节点的封装 MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[0]; Object parameter = null; if (invocation.getArgs().length &gt; 1) &#123; parameter = invocation.getArgs()[1]; &#125; // String sqlId = mappedStatement.getId(); // 获取动态生成的 SQL 语句以及相应的参数信息对象 BoundSql boundSql = mappedStatement.getBoundSql(parameter); // MyBatis 所有的配置信息都维持在 Configuration 对象之中，包括 id、Statement 类型、SQL 类型、mapper 的 xml 文件的绝对地址、是否使用缓存等配置 Configuration configuration = mappedStatement.getConfiguration(); Object returnValue = null; long start = System.currentTimeMillis(); // 继续执行原目标方法 returnValue = invocation.proceed(); // 获取实体类 Class&lt;?&gt; parameterType = getParameterType(mappedStatement); /** 判断实体类上是否包含 @SqlPrint 注解，不包含的话直接返回 */ if (!hasSqlPrintAnnotation(parameterType)) &#123; return returnValue; &#125; long end = System.currentTimeMillis(); long time = (end - start); /** 当 SQL 执行大于 1 毫秒时打印 SQL，所以也可以用于慢 SQL 的打印及监控 */ if (time &gt; 1) &#123; String sql = getSql(configuration, boundSql, sqlId, time); log.info(sql); &#125; // 返回执行后的结果 return returnValue; &#125; /** * 作用：包装目标对象，包装的意思就是为目标对象创建一个代理对象 */ @Override public Object plugin(Object target) &#123; /** 判断下需要拦截的目标对象类型，需要拦截时才拦截，否则直接返回本身，减少被代理的次数 */ if (target instanceof Executor) &#123; // 借助 Plugin 的 wrap 方法来使用当前的拦截器包装我们的目标对象，返回的就是为当前 target 创建的动态代理 // 使用 JDK 的动态代理，给 target 对象创建一个 delegate 代理对象，以此来实现方法拦截和增强功能，它会回调 intercept() 方法。 return Plugin.wrap(target, this); &#125; else &#123; // 无需拦截则直接返回目标对象本身 return target; &#125; &#125; /** * 将插件注册时的 property 属性设置进来 */ @Override public void setProperties(Properties properties) &#123; this.properties = properties; &#125; /** * 组装需要打印的信息，包括 SQL 语句、特殊标记、SQL 执行时间等 * * @param configuration MyBatis 所有的配置信息都维持在 Configuration 对象之中 * @param boundSql 表示动态生成的 SQL 语句以及相应的参数信息对象 * @param sqlId 拦截的执行 SQL 的id（可以理解为方法） * @param time SQL 执行时间 * @return */ private static String getSql(Configuration configuration, BoundSql boundSql, String sqlId, long time) &#123; String sql = showSql(configuration, boundSql); StringBuilder str = new StringBuilder(100); // 拦截的执行 SQL 的id（可以理解为方法），例如：com.gorge4j.user.mapper.UserManageDemoMyBatisMapper.update str.append(sqlId); str.append(\" : \"); // 具体执行的 SQL 语句 str.append(sql); str.append(\" &gt;&gt;&gt;&gt;&gt;&gt; \"); // SQL 执行的时间 str.append(\"SQL执行耗时: \"); str.append(time); str.append(\"ms\"); return str.toString(); &#125; /** 按类型格式化 SQL 里的参数 */ private static String getFormatParameterValue(Object obj) &#123; String value = null; if (obj instanceof String) &#123; value = \"'\" + obj.toString() + \"'\"; &#125; else if (obj instanceof Date) &#123; DateFormat formatter = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, Locale.CHINA); value = \"'\" + formatter.format(new Date()) + \"'\"; &#125; else &#123; if (obj != null) &#123; value = obj.toString(); &#125; else &#123; value = \"\"; &#125; &#125; return value; &#125; /** 组装需要打印的 SQL */ private static String showSql(Configuration configuration, BoundSql boundSql) &#123; // 取得参数的对象，实际上就是一个多个参数的 map 结构 // 示例：parameterObject:MapperMethod&#123;password=123456,name=xxxxxx,type=O,param3=O,param1=xxxxxx,param2=123456&#125; Object parameterObject = boundSql.getParameterObject(); // 查询 SQL 中的参数 List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings(); // 将 SQL 中一个或多个回车换行符号替换成一个空格 String sql = boundSql.getSql().replaceAll(\"[\\\\s]+\", \" \"); if (!parameterMappings.isEmpty() &amp;&amp; parameterObject != null) &#123; // Mybatis 在启动时就会通过 TypeHandlerRegistry 进行注册，即建立 JdbcType, JavaType, TypeHandler 三者之间的关系。 // 因此，这意味着在 Mybatis 启动时我们也需要通过 TypeHandlerRegistry 将我们的所有的枚举类型（JavaType）与自定义的枚举 // TypeHandler（EnumTypeHandler）建立联系 TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry(); // 自定义 TypeHandler 时会走这个逻辑，建立 JavaType 和 JdbcType 之间的联系 if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123; // 替换 SQL 中的占位符 “?” 为具体的参数，replaceFirst 作为是替换匹配到的第一个占位符 “?” sql = sql.replaceFirst(\"\\\\?\", getFormatParameterValue(parameterObject)); &#125; // 没有自定义的 TypeHandler，走通用逻辑 else &#123; // 拿到 target（拦截对象）的元数据 MetaObject metaObject = configuration.newMetaObject(parameterObject); // 参数是按顺序存储的，下面逻辑按顺序来替换 for (ParameterMapping parameterMapping : parameterMappings) &#123; // 获取参数的名称 String propertyName = parameterMapping.getProperty(); // 如果元数据对象中存在该参数，则替换相应的占位符 “?” if (metaObject.hasGetter(propertyName)) &#123; Object obj = metaObject.getValue(propertyName); sql = sql.replaceFirst(\"\\\\?\", getFormatParameterValue(obj)); &#125; // 如果有额外的参数，走下面的逻辑 else if (boundSql.hasAdditionalParameter(propertyName)) &#123; Object obj = boundSql.getAdditionalParameter(propertyName); sql = sql.replaceFirst(\"\\\\?\", getFormatParameterValue(obj)); &#125; &#125; &#125; &#125; // 返回组装好的 SQL return sql; &#125; /** 获取实体对象类：class com.gorge4j.user.entity.UserManageDemoMyBatis */ private Class&lt;?&gt; getParameterType(MappedStatement statement) &#123; if (statement.getParameterMap() == null || statement.getParameterMap().getType() == null) &#123; return null; &#125; return statement.getParameterMap().getType(); &#125; /** 判断实体类上是否包含自定义的 SQl 打印的注解 @SqlPrint */ private static boolean hasSqlPrintAnnotation(Class&lt;?&gt; classType) &#123; return classType == null ? Boolean.FALSE : classType.isAnnotationPresent(SqlPrint.class); &#125;&#125; 注意：需要在实体类上添加自定义注解 @SqlPrint 自定义注解类： 12345@Retention(RUNTIME)@Target(TYPE)public @interface SqlPrint &#123;&#125; 自定义的 SQL 日志打印样式： 跨域 跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对 JavaScript 实施的安全策略。 123456789101112131415161718192021222324@Configurationpublic class CorsConfig extends WebMvcConfigurationSupport &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(\"/**\") .allowedOrigins(\"*\") .allowCredentials(true) .allowedHeaders(\"*\") .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\", \"OPTIONS\") .maxAge(3600); &#125; // 配置 Swagger 的资源映射 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) &#123; registry.addResourceHandler(\"swagger-ui.html\") .addResourceLocations(\"classpath:/META-INF/resources/\"); registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\"); &#125;&#125; 注意12345/** * @see EnableWebMvc 用了此注解默认配置的 MVC 失效，需要用户重新配置 * @see WebMvcConfigurer */public class WebMvcConfigurationSupport ... 自定义校验 除了使用默认提供的 Validator，用户还可以提供具有自定义校验规则的 Validator。 注解类123456789@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = UsernameValidator.class) // 引入校验规则类进行校验public @interface Username &#123; // 错误提示消息 @Username(message = \"\") String message() default \"&#123;com.wingo.user.annotaion.Username.message&#125;\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 12345678@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)@Constraint(validatedBy = PasswordValidator.class)public @interface Password &#123; String message() default \"&#123;com.wingo.user.annotaion.Password.message&#125;\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 校验类123456789101112131415public class UsernameValidator implements ConstraintValidator&lt;Username, String&gt; &#123; @Override public void initialize(Username constraintAnnotation) &#123; // do nothing &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if (StringUtils.isBlank(value)) &#123; return false; &#125; return Pattern.matches(RegexConstant.REGEX_USERNAME, value); &#125;&#125; 123456789101112131415public class PasswordValidator implements ConstraintValidator&lt;Password, String&gt; &#123; @Override public void initialize(Password constraintAnnotation) &#123; // do nothing &#125; @Override public boolean isValid(String value, ConstraintValidatorContext context) &#123; if (StringUtils.isBlank(value)) &#123; return false; &#125; // 正则匹配 return Pattern.matches(RegexConstant.REGEX_PASS, value); &#125;&#125; 请求响应打印 切面：方法前打印请求信息参数；方法后打印响应信息。 1234567891011121314151617181920212223242526272829303132333435363738394041@Slf4j@Component@Aspectpublic class ReqAndRespLogAspect &#123; /** * 请求参数的日志打印 * * @param joinPoint 切点 */ @Before(\"within(com.wingo.user.controller.*)\") public void before(JoinPoint joinPoint) &#123; // 获取传入目标方法的参数对象 Object[] args = joinPoint.getArgs(); // 获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的Class等信息 MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); // 获取方法对象 Method method = methodSignature.getMethod(); // 分割组装参数 String strArgs = StringUtils.join(args, \",\"); log.info(\"&#123;&#125;.&#123;&#125; - 请求参数: &#123;&#125;\", method.getDeclaringClass().getName(), method.getName(), strArgs); &#125; /** * 响应结果的日志打印 * * @param joinPoint 切点 * @param res 响应结果对象 */ @AfterReturning(value = \"within(com.wingo.user.controller.*)\", returning = \"res\") public void after(JoinPoint joinPoint, Object res) &#123; // 获取封装了署名信息的对象,在该对象中可以获取到目标方法名,所属类的 Class 等信息 MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); // 获取方法对象 Method method = methodSignature.getMethod(); // 将返回对象转换成 Json 字符串，项目的返回如果不是 Json 的数据格式，那么返回参数就只有 URL // String strRes = JSONUtils.toJSONString(res); String strRes = res.toString(); log.info(\"&#123;&#125;.&#123;&#125; - 返回结果: &#123;&#125;\", method.getDeclaringClass().getName(), method.getName(), strRes); &#125;&#125;","categories":[{"name":"Welab","slug":"Welab","permalink":"http://yoursite.com/categories/Welab/"}],"tags":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/tags/Project/"}]},{"title":"CET6 写作真题","slug":"English/CET6 写作真题","date":"2020-03-06T14:08:13.000Z","updated":"2020-03-06T15:07:48.630Z","comments":true,"path":"2020/03/06/English/CET6 写作真题/","link":"","permalink":"http://yoursite.com/2020/03/06/English/CET6%20%E5%86%99%E4%BD%9C%E7%9C%9F%E9%A2%98/","excerpt":"CET6 写作真题。","text":"CET6 写作真题。 2019/12(一) 拥有社会责任感的重要性 以 “社会问题” 的普遍性引出社会责任感的缺失； 分别从企业和个人角度阐述社会责任感的重要性； 总结观点，发出呼吁。 Problems such as the violation of privacy and environment pollution are becoming increasingly prevalent in modern society. To some extent, they can be ascribed to a distinct lack of a sense of social responsibility aomong enterprises and individuals, which is of crucial importance in building a better world. When seeking profits, socially responsible corporations never forget to make positive contributions to pur society. Take Alibaba, a leading tech company in China. The Ant Forest green initiative it launched in 2016 has so far inspired up to 500 million Alipay users to adopt low-carbon lifestyles and resulted in over 100 million trees planted in China’s most barren regions. At the individual level, a sense of social responsibility motivates us college students to acquire as much knowledge as possible and put it into practice. It also prevents us from engaging in unethical behaviors such as campus violence and academic misconduct that cause negative social impact. To sum up, a healthy society requires all its members to take on their respective responsibility. Everyone, therefore, should develop a sense of social responsibility, especially we college students who will be a pillar of society in the furure. 作文模板：对于社会 / 社区 / 家庭的责任 Every one of us is a member of our society / acommunity/a certain family. This means that we all have a responsibility to make a contribution towards a better/healthier [ ], as we enjoy the benefits from this social role. There is no denying that a sense of responsibility has always been highly valued. It is primarily because it serves to maintain and even strengthen social / family ties / bonds, which help generate cohesion within our [ ]. It will in turn enable us to make a joint / united effort to [ ]. Furthermore, such a sense of responsibility forms an integral part of goodcharacter. It is a constant reminder for us of how essential it is to give, for example to dedicate ourselves to [ ]. so that we won’t end up being selfish. In general, having a sense of [ ] responsibility matters as much to the entire [ ] as to ourselves. It is thus necessary for us to develop this quality.","categories":[{"name":"English","slug":"English","permalink":"http://yoursite.com/categories/English/"}],"tags":[{"name":"CET6","slug":"CET6","permalink":"http://yoursite.com/tags/CET6/"}]},{"title":"Spring Boot 数据访问","slug":"Spring Boot/Spring Boot 数据访问","date":"2020-03-05T07:42:42.000Z","updated":"2020-04-19T06:44:02.622Z","comments":true,"path":"2020/03/05/Spring Boot/Spring Boot 数据访问/","link":"","permalink":"http://yoursite.com/2020/03/05/Spring%20Boot/Spring%20Boot%20%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/","excerpt":"Spring Boot 数据访问的相关知识。","text":"Spring Boot 数据访问的相关知识。 JDBC123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt; 1234567spring: datasource: username: root password: 123456 url: jdbc:mysql://localhosthost:3306/jdbc driver-class-name: com.mysql.jdbc.Driver # Spring Boot 2.1.x 默认使用了 MySQL 8.0：com.mysql.cj.jdbc.Driver Sping Boot 默认使用 org.apache.tomcat.jdbc.pool.DataSource 作为数据源，相关配置都在 DataSourceProperties 里面。 默认建表配置规则 1schema-*.sql 指定建表文件 sql 文件的文件名 1234spring: datasource: schema: - classpath:user.sql Sping Boot 自动配置了 JdbcTemplate 操作数据库 JdbcTempale创建一个 User 表： 1234CREATE TABLE `User` ( `name` varchar(100) COLLATE utf8mb4_general_ci NOT NULL, `age` int NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci 编写实体对象： 12345678@Data // Getter / Setter@NoArgsConstructor // 无参构造器public class User &#123; private String name; private Integer age;&#125; 数据访问对象接口： 123456789101112131415161718public interface UserService &#123; // 新增一个用户 int create(String name, Integer age); // 根据 name 查询用户 List&lt;User&gt; getByName(String name); // 根据 name 删除用户 int deleteByName(String name); // 获取用户总量 int getAllUsers(); // 删除所有用户 int deleteAllUsers();&#125; 数据访问操作的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private JdbcTemplate jdbcTemplate; UserServiceImpl(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Override public int create(String name, Integer age) &#123; return jdbcTemplate.update(\"insert into USER(NAME, AGE) values(?, ?)\", name, age); &#125; @Override public List&lt;User&gt; getByName(String name) &#123; List&lt;User&gt; users = jdbcTemplate.query (\"select NAME, AGE from USER where NAME = ?\", (resultSet, i) -&gt; &#123; User user = new User(); user.setName(resultSet.getString(\"NAME\")); user.setAge(resultSet.getInt(\"AGE\")); return user; &#125;, name); return users; &#125; @Override public int deleteByName(String name) &#123; return jdbcTemplate.update(\"delete from USER where NAME = ?\", name); &#125; @Override public int getAllUsers() &#123; return jdbcTemplate.queryForObject(\"select count(1) from USER\", Integer.class); &#125; @Override public int deleteAllUsers() &#123; return jdbcTemplate.update(\"delete from USER\"); &#125;&#125; 整合 Druid 数据源123456789101112131415161718&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- mysql驱动 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!-- 启动器中默认的版本较高 --&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!--数据库连接池--&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.20&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445spring.datasource.username=rootspring.datasource.password=123456spring.datasource.url=jdbc:mysql://localhost:3306/i-auth?useSSL=false# 可以不配置 Druid 可以根据 url 自动识别数据库驱动# spring.datasource.driver-class-name=com.mysql.jdbc.Driver# 初始化连接数spring.datasource.druid.initial-size=5# 最小连接数spring.datasource.druid.min-idle=10# 最大连接数spring.datasource.druid.max-active=10# 获取连接最长等待时间 单位毫秒spring.datasource.druid.max-wait=10000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.druid.timeBetweenEvictionRunsMillis=30000# 指定获取连接时连接校验的sql查询语句spring.datasource.druid.validationQuery=select 'x'# 获取连接后，确实是否要进行连接空闲时间的检查spring.datasource.druid.testWhileIdle=true# 获取连接检测spring.datasource.druid.testOnBorrow=false# 归还连接检测spring.datasource.druid.testOnReturn=false# 指定连接校验查询的超时时间spring.datasource.druid.validationQueryTimeout=600000# 配置一个连接在池总最小生存的时间spring.datasource.druid.minEvictableIdleTimeMillis=300000# 打开 PSCache，并且指定每个连接上 Cache 的大小spring.datasource.druid.poolPreparedStatements=truespring.datasource.druid.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filter，去掉后监控界面sql无法统计，'wall'用于防火墙spring.datasource.druid.filters=stat,wall,slf4j# 通过connectProperties属性来打开mergeSql功能，慢sql记录等spring.datasource.druid.connectionProperties=druid.stat.mergeSql=true;druid.stat.logSlowSql=true;druid.stat.slowSqlMillis=5000## druid连接池监控# 需要账号密码才能访问控制台，默认为rootspring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123# 访问路径为/druid时，跳转到StatViewServletspring.datasource.druid.stat-view-servlet.url-pattern=/druid/*# 是否能够重置数据spring.datasource.druid.stat-view-servlet.reset-enable=false# 排除一些静态资源，以提高效率spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/* 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 导入 Druid 数据源@Configurationpublic class DruidConfig &#123; // 一个自定义的 DataSource 组件 @ConfigurationProperties(prefix = \"spring.datasource\") @Bean public DataSource druid()&#123; return new DruidDataSource(); &#125; // 配置 Druid 的监控 // 配置一个管理后台的 Servlet @Bean public ServletRegistrationBean statViewServlet()&#123; ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), \"/druid/*\"); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"loginUsername\",\"admin\"); initParams.put(\"loginPassword\",\"123456\"); initParams.put(\"allow\",\"\"); // 默认就是允许所有访问 initParams.put(\"deny\",\"192.168.15.21\"); bean.setInitParameters(initParams); return bean; &#125; // 配置一个 Web 监控的 Filter @Bean public FilterRegistrationBean webStatFilter()&#123; FilterRegistrationBean bean = new FilterRegistrationBean(); bean.setFilter(new WebStatFilter()); Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;(); initParams.put(\"exclusions\",\"*.js,*.css,/druid/*\"); bean.setInitParameters(initParams); bean.setUrlPatterns(Arrays.asList(\"/*\")); return bean; &#125;&#125; 整合 MyBatis可直接使用插件：Mybatis-Plus 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt; 注解版 1234567891011121314151617// 指定这是一个操作数据库的 Mapper@Mapperpublic interface DepartmentMapper &#123; @Select(\"select * from department where id=#&#123;id&#125;\") public Department getDeptById(Integer id); @Delete(\"delete from department where id=#&#123;id&#125;\") public int deleteDeptById(Integer id); @Options(useGeneratedKeys = true,keyProperty = \"id\") @Insert(\"insert into department(departmentName) values(#&#123;departmentName&#125;)\") public int insertDept(Department department); @Update(\"update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;\") public int updateDept(Department department);&#125; 123456789// 使用 MapperScan 批量扫描所有的 Mapper 接口，或在 Mapper 类使用 Mapper@MapperScan(value = \"com.wingo.springboot.mapper\")@SpringBootApplicationpublic class SpringBootDataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootDataMybatisApplication.class, args); &#125;&#125; 自定义 MyBatis 配置规则：驼峰命名法。 1234567891011121314@Configuration public class MyBatisConfig &#123; @Bean public ConfigurationCustomizer configurationCustomizer()&#123; return new ConfigurationCustomizer()&#123; @Override public void customize(Configuration configuration) &#123; configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; &#125; &#125; 配置文件版 12345mybatis: # 指定全局配置文件的位置 config-location: classpath:mybatis/mybatis-config.xml # 指定 Sql 映射文件的位置 mapper-locations: classpath:mybatis/mapper/*.xml 整合 SpringData JPA 编写一个实体类 Bean 和数据表进行映射，并且配置好映射关系： 1234567891011121314// 使用 JPA 注解配置映射关系@Entity // 告诉 JPA 这是一个实体类（和数据表映射的类）@Table(name = \"tbl_user\") // @Table 来指定和哪个数据表对应，如果省略默认表名就是 userpublic class User &#123; @Id // 这是一个主键 @GeneratedValue(strategy = GenerationType.IDENTITY) // 自增主键 private Integer id; @Column(name = \"last_name\",length = 50) // 这是和数据表对应的一个列 private String lastName; @Column // 省略默认列名就是属性名 private String email;&#125; 编写一个 Dao 接口来操作实体类对应的数据表： 123// 继承 JpaRepository 来完成对数据库的操作，传参：实体类型 主键类型public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;&#125; JpaProperties 基本配置 1234567spring: jpa: hibernate: # 更新或者创建数据表结构 ddl-auto: update # 控制台显示SQL show-sql: true","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"},{"name":"Druid","slug":"Druid","permalink":"http://yoursite.com/tags/Druid/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"Docker的使用","slug":"Software/Docker 的使用","date":"2020-03-04T09:40:46.000Z","updated":"2020-04-19T06:34:56.379Z","comments":true,"path":"2020/03/04/Software/Docker 的使用/","link":"","permalink":"http://yoursite.com/2020/03/04/Software/Docker%20%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"Docker 是一个开源的应用容器引擎，是一个轻量级容器技术。Docker 支持将软件编译成一个镜像，然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像，运行中的这个镜像称为容器，容器启动是非常快速的。","text":"Docker 是一个开源的应用容器引擎，是一个轻量级容器技术。Docker 支持将软件编译成一个镜像，然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像，运行中的这个镜像称为容器，容器启动是非常快速的。 环境搭建CentOS 7 下载：阿里云镜像 VMware 创建虚拟机运行 CentOS 7 光盘映像文件。 选择 &gt; SYSTEM &gt; INSTALLATION DESTINATION，进入磁盘分区界面； 选择 &gt; I will configure partitioning &gt; Done &gt; partitioning scheme &gt; Standard Partition &gt; + &gt;： 挂载点：swap，期望容量：4096；挂载点：/，期望容量：留空。选择 &gt; SOFTWARE &gt; Minimal Install。Begin Install &gt; 设置密码 &gt; Reboot &gt; 初始化完成。 网络配置 CentOS 7.x 默认安装好之后是没有自动开启网络连接的，需要自行配置。 ！！！注意！！！VMWare 网络选择桥接模式。 1234cat /etc/sysconfig/network-scripts/ifcfg-ens33 # 默认的网络配置文件mv ifcfg-ens33 ifcfg-eth0 # 修改习惯性命名ip address # 查看 MACvi /etc/sysconfig/network-scripts/ifcfg-eth0 # 修改配置 注意：默认网关一致；DHCP 动态分配改为 STATIC 静态模式；静态 IP 地址填写与主机相同的网段内；MAC 地址随机分配，不可重复，复制主机的时候记得修改。一下是需要修改的配置： 修改主机名：hostnamectl set-hostname geeklp --static Docker 安装1yum -y install docker 核心概念Docker 主机 Host：安装了 Docker 程序的机器（Docker 直接安装在操作系统之上）； Docker 客户端 Client：连接 Docker 主机进行操作； Docker 仓库 Registry：用来保存各种打包好的软件镜像； Docker 镜像 Images：软件打包好的镜像,放在 Docker 仓库中； Docker 容器 Container：镜像启动后的实例称为一个容器；容器是独立运行的一个或一组应用。 Docker 使用 虚拟机记得设置桥接网络并选择对应的网卡接入网线。 1234# 设置好网络以后使用命令重启虚拟机的网络service network restart# 查看 Linux 的 IP 地址ip addr Linux 环境下 Docker 的安装： 12345678910111213# 检查内核版本，Docker 要求内核版本必须是 3.10 及以上uname -sr# 安装 Dockeryum install docker# 输入 y 确认安装# 启动 Dockersystemctl start docker# 查看版本docker -v# 开机启动 Dockersystemctl enable docker# 停止 Dockersystemctl stop docker Docker 常用命令操作 操作 命令 说明 检索 docker search [name] 我们经常去 docker hub 上检索镜像的详细信息，如镜像的 tag 拉取 docker pull [name]:tag :tag 是可选的，tag 表示标签，多为软件的版本，默认是 latest 列表 docker images 查看所有本地镜像 删除 docker rm image-id 删除指定的本地镜像 123456789101112131415161718192021222324252627# 搜索镜像docker search tomcat# 拉取镜像docker pull tomcat# 根据镜像启动容器，没有做映射无法正常访问docker run --name mytomcat -d tomcat:latest# 查看运行中的容器docker ps # 停止运行中的容器docker stop cantainerId# 查看所有的容器，运行中和已经退出的docker ps -a# 启动容器docker start cantainerId# 删除一个容器docker rm cantainerId# 启动一个做了端口映射的 tomcatdocker run -d -p 8888:8080 tomcat# -d：后台运行# -p: 将主机的端口映射到容器的一个端口 主机端口:容器内部的端口# 查看防火墙状态service firewalld status# 关闭防火墙service firewalld stop# 查看容器的日志docker logs container-name/container-id# 具体镜像的启动操作可以参考每一个镜像的文档 安装 MySQL 示例1234567891011# 安装并启动 MySQL 镜像docker pull mysqldocker run --name mysql01 -d mysqldocker ps -a# 发现容器异常退出了，查看错误日志docker logs containerId# 发现是因为没有指定账号密码# 正确启动并指定端口映射docker run -p 3306:3306 --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 -d mysql# docker run --name mysql03 -v [自定义 MySQL 配置文件的目录]:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag# docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci 安装 Redis 示例Docker Hub 查询 Redis 源。 123docker pull redisdocker images # 查看镜像名称docker run -d -p 6379:6379 --name myredis [镜像名称] # redis 客户端测试连接","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"}]},{"title":"Spring Boot Web 开发","slug":"Spring Boot/Spring Boot Web 开发","date":"2020-03-03T06:08:47.000Z","updated":"2020-04-19T06:44:17.329Z","comments":true,"path":"2020/03/03/Spring Boot/Spring Boot Web 开发/","link":"","permalink":"http://yoursite.com/2020/03/03/Spring%20Boot/Spring%20Boot%20Web%20%E5%BC%80%E5%8F%91/","excerpt":"Spring Boot Web 方面的开发介绍。","text":"Spring Boot Web 方面的开发介绍。 自动配置原理： xxxAutoConfiguration：帮我们给容器中自动配置组件； xxxProperties：配置类封装配置文件的内容。 静态资源映射以 JAR 包的方引入静态资源： 123456&lt;!-- 引入 jquery-webjar 在访问的时候只需要写 webjars 下面资源的名称即可 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1&lt;/version&gt;&lt;/dependency&gt; 访问 jquery.js：localhost:8080/webjars/jquery/3.3.1/jquery.js 访问当前项目的任何资源，都去静态资源文件夹找映射。 12345&quot;classpath:&#x2F;META-INF&#x2F;resources&#x2F;&quot;, &quot;classpath:&#x2F;resources&#x2F;&quot;,&quot;classpath:&#x2F;static&#x2F;&quot;, &quot;classpath:&#x2F;public&#x2F;&quot; &quot;&#x2F;&quot;：当前项目的根路径 Thymeleaf 模板引擎123456789101112&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!-- 默认是 2.1.6 版本 --&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!-- 切换 Thymeleaf 版本 --&gt;&lt;properties&gt; &lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt; &lt;!-- 布局功能的支持程序 Thymeleaf3 主程序 Layout2 以上版本 --&gt; &lt;!-- Thymeleaf2 layout1--&gt; &lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;&lt;/properties&gt; 自动配置Spriing Boot 对于 Thymeleaf 的自动配置 12345678910# Enable template cachingspring thymeleaf cache=true# Template encodingspring thymeleaf encoding=UTF-8# Template mode to be applied to templates. See also StandardTemplateModeHandlersspring thymeleaf mode=HTML5# Prefix that gets prepended to view names when building a URLspring thymeleaf prefix=classpath: /templates/# Suffix that gets appended to view names when building a URLspring thymeleaf suffix=.html 12345678910111213@ConfigurationProperties(prefix = \"spring.thymeleaf\")public class ThymeleafProperties &#123; private static final Charset DEFAULT_ENCODING = Charset.forName(\"UTF-8\"); private static final MimeType DEFAULT_CONTENT_TYPE = MimeType.valueOf(\"text/html\"); public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; // ...&#125; 从自动配置类中可以看出只要我们把 HTML 页面放在classpath:/templates/目录下 Thymeleaf 就能自动渲染。 Thymeleaf 的使用123456789101112&lt;!DOCTYPE html&gt;&lt;!-- 导入 Thymeleaf 的名称空间 --&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- th:text 设置 div 里面的文本内容 --&gt; &lt;div th:text=\"$&#123;hello&#125;\"&gt;这是显示欢迎信息&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 常用标签 常用表达式 123456789101112131415161718192021行内写法：[[]] -&gt; th:text 会转义特殊字符[()] -&gt; th:utext 不会转义特殊字符内置工具类：#execInfo : information about the template being processed.#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;…&#125; syntax.#uris : methods for escaping parts of URLs&#x2F;URIs#conversions : methods for executing the configured conversion service (if any).#dates : methods for java.util.Date objects: formatting, component extraction, etc.#calendars : analogous to #dates , but for java.util.Calendar objects.#numbers : methods for formatting numeric objects.#strings : methods for String objects: contains, startsWith, prepending&#x2F;appending, etc.#objects : methods for objects in general.#bools : methods for boolean evaluation.#arrays : methods for arrays.#lists : methods for lists.#sets : methods for sets.#maps : methods for maps.#aggregates : methods for creating aggregates on arrays or collections.#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration). Spring MVC 自动配置Sping Boot 对 Spring MVC 的默认配置：WebMvcAutoConfiguration 12345678910//使用 WebMvcConfigurerAdapter 可以来扩展 SpringMVC 的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; // 浏览器发送 /wingo 请求来到 success registry.addViewController(\"/wigno\").setViewName(\"success\"); &#125;&#125; 不能标注@EnableWebMvc，标注后 Spring MVC 的默认自动装配将不会进行，即开发者全面接管 Spring MVC Restful CRUD默认访问首页： 1234567891011121314151617// 使用 WebMvcConfigurerAdapter 可以来扩展 Spring MVC 的功能@Configurationpublic class MyMvcConfig extends WebMvcConfigurerAdapter &#123; // 所有的 WebMvcConfigurerAdapter 组件都会一起起作用 @Bean // 将组件注册在容器 public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; &#125;; return adapter; &#125;&#125; 国际化IDEA 会自动识别国际化目录。 IDEA 进行优化后的便于编辑的视图：（点击左下角的 Resource Bundle） Spring Boot 中的消息自动配置： 12345678public class MessageSourceAutoConfiguration &#123; // ... // 默认配置为 spring.messages.basename=messages 即国际化资源默认放在类路径下的 messages.properties String basename = context.getEnvironment().getProperty(\"spring.messages.basename\", \"messages\"); //... &#125; 12# 自定义国际化文件的位置spring.message.basename=i18n.login 页面获取国际化的信息： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"&gt; &lt;meta name=\"description\" content=\"\"&gt; &lt;meta name=\"author\" content=\"\"&gt; &lt;title&gt;Signin Template for Bootstrap&lt;/title&gt; &lt;!-- webjars 形式的静态资源映射 --&gt; &lt;!-- Bootstrap core CSS --&gt; &lt;link href=\"asserts/css/bootstrap.min.css\" th:href=\"@&#123;/webjars/bootstrap/4.0.0/css/bootstrap.css&#125;\" rel=\"stylesheet\"&gt; &lt;!-- Custom styles for this template --&gt; &lt;link href=\"asserts/css/signin.css\" th:href=\"@&#123;/asserts/css/signin.css&#125;\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body class=\"text-center\"&gt; &lt;form class=\"form-signin\" action=\"dashboard.html\"&gt; &lt;img class=\"mb-4\" th:src=\"@&#123;/asserts/img/bootstrap-solid.svg&#125;\" src=\"asserts/img/bootstrap-solid.svg\" alt=\"\" width=\"72\" height=\"72\"&gt; &lt;!-- Thymeleaf 用 #&#123;&#125; 表达式取出国际化信息 --&gt; &lt;h1 class=\"h3 mb-3 font-weight-normal\" th:text=\"#&#123;login.tip&#125;\"&gt;Please sign in&lt;/h1&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.username&#125;\"&gt;Username&lt;/label&gt; &lt;input type=\"text\" class=\"form-control\" placeholder=\"Username\" th:placeholder=\"#&#123;login.username&#125;\" required=\"\" autofocus=\"\"&gt; &lt;label class=\"sr-only\" th:text=\"#&#123;login.password&#125;\"&gt;Password&lt;/label&gt; &lt;input type=\"password\" class=\"form-control\" placeholder=\"Password\" th:placeholder=\"#&#123;login.password&#125;\" required=\"\"&gt; &lt;div class=\"checkbox mb-3\"&gt; &lt;label&gt; &lt;input type=\"checkbox\" value=\"remember-me\"/&gt; [[#&#123;login.remember&#125;]] &lt;/label&gt; &lt;/div&gt; &lt;button class=\"btn btn-lg btn-primary btn-block\" type=\"submit\" th:text=\"#&#123;login.btn&#125;\"&gt;Sign in&lt;/button&gt; &lt;p class=\"mt-5 mb-3 text-muted\"&gt;© 2017-2018&lt;/p&gt; &lt;a class=\"btn btn-sm\"&gt;中文&lt;/a&gt; &lt;a class=\"btn btn-sm\"&gt;English&lt;/a&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 根据浏览器请求中所携带的国际化 Locale 信息进行语言的转换。 123456789101112131415@Bean@ConditionalOnMissingBean@ConditionalOnProperty( prefix = \"spring.mvc\", name = &#123;\"locale\"&#125;)public LocaleResolver localeResolver() &#123; if (this.mvcProperties.getLocaleResolver() == org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties.LocaleResolver.FIXED) &#123; return new FixedLocaleResolver(this.mvcProperties.getLocale()); &#125; else &#123; AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver(); localeResolver.setDefaultLocale(this.mvcProperties.getLocale()); return localeResolver; &#125;&#125; 可以在切换语言的的链接上携带区域信息，进行语言切换。 12345678910111213141516171819202122public class MyLocaleResolver implements LocaleResolver &#123; @Override public Locale resolveLocale(HttpServletRequest request) &#123; String myLocale = request.getParameter(\"locale\"); Locale locale = Locale.getDefault(); if(!StringUtils.isEmpty(myLocale))&#123; String[] split = myLocate.split(\"_\"); //国家 语言 locale = new Locale(split[0],split[1]); &#125; return locale; &#125; @Override public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) &#123;&#125; @Bean public LocaleResolver localeResolver()&#123; return new MyLocaleResolver(); &#125;&#125; 用户登录12# 禁用缓存spring.thymeleaf.cache&#x3D;false 修改了页面后 Ctrl + F9 进行重新编译 123&lt;!-- 登录错误消息显示 --&gt;&lt;!-- 使用 Thymeleaf 内置工具类 #Srting, 取传递变量的值 $&#123;&#125; 表达式--&gt;&lt;p style=\"color: red\" th:text=\"$&#123;msg&#125;\" th:if=\"$&#123;not #strings.isEmpty(msg)&#125;\"&gt;&lt;/p&gt; 拦截器拦截器的编写： 12345678910111213141516171819public class LoginHandlerInterceptor implements HandlerInterceptor &#123; // 目标方法执行之前 @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; // 用户登录后在 Session 中保存用户标志 Object user = request.getSession().getAttribute(\"loginUser\"); if(user == null)&#123; // 未登陆，返回登陆页面 request.setAttribute(\"msg\",\"没有权限请先登陆\"); request.getRequestDispatcher(\"/index.html\").forward(request,response); return false; &#125;else&#123; // 已登陆，放行请求 return true; &#125; &#125; // 省略其它不需要编写的抽象方法&#125; 注册拦截器 123456789101112131415161718192021// 所有的 WebMvcConfigurerAdapter 组件都会一起起作用@Bean // 将组件注册在容器public WebMvcConfigurerAdapter webMvcConfigurerAdapter()&#123; WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() &#123; @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(\"/\").setViewName(\"login\"); registry.addViewController(\"/index.html\").setViewName(\"login\"); &#125; // 注册拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; // super.addInterceptors(registry); // 静态资源 *.css , *.js SpringBoot 已经做好了映射 // 除了访问登录页面的 URL 其余的 URL 全部进行拦截认证 registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(\"/**\") .excludePathPatterns(\"/index.html\",\"/\",\"/user/login\"); &#125; &#125;; return adapter;&#125; 员工列表 普通CRUD（URI 来区分操作） RestfulCRUD 查询 getEmp emp—GET 添加 addEmp?xxx emp—POST 修改 updateEmp?id=xxx&amp;xxx=xx emp/{id}—PUT 删除 deleteEmp?id=1 emp/{id}—DELETE 本次实验的请求架构： 实验功能 请求URI 请求方式 查询所有员工 emps GET 查询某个员工（来到修改页面） emp/{id} GET 来到添加页面 emp GET 添加员工 emp POST 来到修改页面（查出员工进行信息回显） emp/{id} GET 修改员工 emp PUT 删除员工 emp/{id} DELETE 员工列表，Thymeleaf 公共页面元素抽取。 123456789101112131415161718192021222324252627282930&lt;!-- common/footer.html 抽取公共片段 --&gt;&lt;footer th:fragment=\"copy\"&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;!-- 引入公共片段 --&gt;&lt;div th:insert=\"footer::copy\"&gt;&lt;/div&gt;&lt;div th:replace=\"footer::copy\"&gt;&lt;/div&gt;&lt;div th:include=\"footer::copy\"&gt;&lt;/div&gt;&lt;!-- ~&#123;templatename::selector&#125;：模板名::选择器~&#123;templatename::fragmentname&#125;:模板名::片段名insert 的公共片段在 div 标签中，如果使用 th:insert 等属性进行引入，可以不用写 ~&#123;&#125;；；行内写法可以加上：[[~&#123;&#125;]] [(~&#123;&#125;)]--&gt;&lt;!-- 效果 --&gt;&lt;div&gt; &lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery &lt;/footer&gt;&lt;/div&gt;&lt;footer&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/footer&gt;&lt;div&gt; &amp;copy; 2011 The Good Thymes Virtual Grocery&lt;/div&gt; 引入片段时传递参数： 12345678&lt;!--引入侧边栏并传入参数；此处用的 id 选择器来引入片段 --&gt;&lt;div th:replace=\"commons/bar::#sidebar(activeUri='emps')\"&gt;&lt;/div&gt;&lt;!-- 应用场景：点击侧边栏的选项，被点击的选项样式发生改变，变为高亮 --&gt;&lt;!-- 解决方式：页面引用时所传递的参数进行样式的修改，生成的侧边栏样式根据传入的参数改变样式 --&gt;&lt;a class=\"nav-link active\" th:class=\"$&#123;activeUri=='main.html'?'nav-link active':'nav-link'&#125;\" href=\"#\" th:href=\"@&#123;/main.html&#125;\"&gt; 添加及修改123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!-- 需要区分是员工修改还是添加 --&gt;&lt;form th:action=\"@&#123;/emp&#125;\" method=\"post\"&gt;&lt;!-- 发送 put 请求修改员工数据--&gt; &lt;!-- Spring MVC 中配置 HiddenHttpMethodFilter；（SpringBoot自动配置好的） 页面创建一个post表单； 创建一个 input 项，name=\"_method\"；value 就是我们指定的请求方式。 --&gt; &lt;!-- 若 emp 携带信息，则此表单提交的是 put 请求 --&gt; &lt;input type=\"hidden\" name=\"_method\" value=\"put\" th:if=\"$&#123;emp!=null&#125;\"/&gt; &lt;!-- 修改需要携带员工 id 用于保存修改 --&gt; &lt;input type=\"hidden\" name=\"id\" th:if=\"$&#123;emp!=null&#125;\" th:value=\"$&#123;emp.id&#125;\"&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;LastName&lt;/label&gt; &lt;input name=\"lastName\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.lastName&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Email&lt;/label&gt; &lt;input name=\"email\" type=\"email\" class=\"form-control\" placeholder=\"zhangsan@atguigu.com\" th:value=\"$&#123;emp!=null&#125;?$&#123;emp.email&#125;\"&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Gender&lt;/label&gt;&lt;br/&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"1\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==1&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;男&lt;/label&gt; &lt;/div&gt; &lt;div class=\"form-check form-check-inline\"&gt; &lt;input class=\"form-check-input\" type=\"radio\" name=\"gender\" value=\"0\" th:checked=\"$&#123;emp!=null&#125;?$&#123;emp.gender==0&#125;\"&gt; &lt;label class=\"form-check-label\"&gt;女&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;department&lt;/label&gt; &lt;!--提交的是部门的id--&gt; &lt;select class=\"form-control\" name=\"department.id\"&gt; &lt;option th:selected=\"$&#123;emp!=null&#125;?$&#123;dept.id == emp.department.id&#125;\" th:value=\"$&#123;dept.id&#125;\" th:each=\"dept:$&#123;depts&#125;\" th:text=\"$&#123;dept.departmentName&#125;\"&gt;1&lt;/option&gt; &lt;/select&gt; &lt;/div&gt; &lt;div class=\"form-group\"&gt; &lt;label&gt;Birth&lt;/label&gt; &lt;!-- #dates 工具类进行时间格式化 --&gt; &lt;input name=\"birth\" type=\"text\" class=\"form-control\" placeholder=\"zhangsan\" th:value=\"$&#123;emp!=null&#125;?$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt; &lt;/div&gt; &lt;button type=\"submit\" class=\"btn btn-primary\" th:text=\"$&#123;emp!=null&#125;?'修改':'添加'\"&gt;添加&lt;/button&gt;&lt;/form&gt; 删除12345678910111213141516171819202122&lt;tr th:each=\"emp:$&#123;emps&#125;\"&gt; &lt;td th:text=\"$&#123;emp.id&#125;\"&gt;&lt;/td&gt; &lt;td&gt;[[$&#123;emp.lastName&#125;]]&lt;/td&gt; &lt;td th:text=\"$&#123;emp.email&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.gender&#125;==0?'女':'男'\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;emp.department.departmentName&#125;\"&gt;&lt;/td&gt; &lt;td th:text=\"$&#123;#dates.format(emp.birth, 'yyyy-MM-dd HH:mm')&#125;\"&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=\"btn btn-sm btn-primary\" th:href=\"@&#123;/emp/&#125;+$&#123;emp.id&#125;\"&gt;编辑&lt;/a&gt; &lt;!-- th:attr 标签自定义属性及值 --&gt; &lt;button th:attr=\"del_uri=@&#123;/emp/&#125;+$&#123;emp.id&#125;\" class=\"btn btn-sm btn-danger deleteBtn\"&gt;删除&lt;/button&gt; &lt;/td&gt;&lt;/tr&gt;&lt;script&gt; $(\".deleteBtn\").click(function()&#123; // 删除当前员工 $(\"#deleteEmpForm\").attr(\"action\",$(this).attr(\"del_uri\")).submit(); return false; &#125;);&lt;/script&gt; 错误处理机制Spring Boot 默认的错误处理机制。 默认效果：对于浏览器，Spring Boot 返回一个默认的错误页面；对于其它客户端，默认响应一个 Json 数据。 1234567891011// 帮我们在页面共享信息@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;String, Object&gt;(); errorAttributes.put(\"timestamp\", new Date()); addStatus(errorAttributes, requestAttributes); addErrorDetails(errorAttributes, requestAttributes, includeStackTrace); addPath(errorAttributes, requestAttributes); return errorAttributes;&#125; 1234567891011121314151617181920212223242526// 处理默认 /error 请求@Controller@RequestMapping(\"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;\") // 默认为错误页面路径 /errorpublic class BasicErrorController extends AbstractErrorController &#123; @RequestMapping(produces = \"text/html\") // 产生 HTML 类型的数据；浏览器发送的请求来到这个方法处理 public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123; HttpStatus status = getStatus(request); Map&lt;String, Object&gt; model = Collections.unmodifiableMap(getErrorAttributes( request, isIncludeStackTrace(request, MediaType.TEXT_HTML))); response.setStatus(status.value()); // 去哪个页面作为错误页面，包含页面地址和页面内容 ModelAndView modelAndView = resolveErrorView(request, response, status, model); return (modelAndView == null ? new ModelAndView(\"error\", model) : modelAndView); &#125; @RequestMapping @ResponseBody // 产生 Json 数据，其他客户端来到这个方法处理 public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123; Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL)); HttpStatus status = getStatus(request); return new ResponseEntity&lt;Map&lt;String, Object&gt;&gt;(body, status); &#125; 1234567891011121314151617181920212223@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123; ModelAndView modelAndView = resolve(String.valueOf(status), model); if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123; modelAndView = resolve(SERIES_VIEWS.get(status.series()), model); &#125; return modelAndView;&#125;private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123; // 默认 Spring Boot 可以去找到一个页面 error/404 String errorViewName = \"error/\" + viewName; // 模板引擎可以解析这个页面地址就用模板引擎解析 TemplateAvailabilityProvider provider = this.templateAvailabilityProviders .getProvider(errorViewName, this.applicationContext); if (provider != null) &#123; // 模板引擎可用的情况下返回到 errorViewName 指定的视图地址 return new ModelAndView(errorViewName, model); &#125; //模板引擎不可用，就在静态资源文件夹下找 errorViewName 对应的页面 error/404.html return resolveResource(errorViewName, model);&#125; 一但系统出现 4xx 或者 5xx 之类的错误，ErrorPageCustomizer 就会生效（定制错误的响应规则），就会来到 /error 请求，就会被BasicErrorController处理。 错误页面的定制有模板引擎的情况下：error/状态码（将错误页面命名为 错误状态码 .html 放在模板引擎文件夹里面的 error 文件夹下）发生此状态码的错误就会来到对应的页面。 可以使用 4xx 和 5xx 作为错误页面的文件名来匹配这种类型的所有错误，精确优先。（优先寻找精确的 [状态码].html） 1234567页面能获取的信息： timestamp：时间戳 status：状态码 error：错误提示 exception：异常对象 message：异常消息 errors：JSR303 数据校验的错误都在这里 没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找，以上都没有错误页面，就是默认来到SpringBoot默认的错误提示页面。 12345678910111213141516// 自定义异常处理 &amp; 返回定制 Json 数据@ControllerAdvicepublic class MyExceptionHandler &#123; @ResponseBody @ExceptionHandler(UserNotExistException.class) public Map&lt;String,Object&gt; handleException(Exception e)&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); // 传入我们自己的错误状态码 4xx 5xx，否则就不会进入定制错误页面的解析流程 request.setAttribute(\"javax.servlet.error.status_code\",500); map.put(\"code\",\"user.notexist\"); map.put(\"message\",e.getMessage()); // 用于错误信息的读取 request.setAttribute(\"userNotExist\",map); return \"forward:/error\"; &#125;&#125; 12345678910111213141516// 给容器中加入我们自己定义的 ErrorAttributes@Componentpublic class MyErrorAttributes extends DefaultErrorAttributes &#123; @Override public Map&lt;String, Object&gt; getErrorAttributes(RequestAttributes requestAttributes, boolean includeStackTrace) &#123; // 这个 map 就是页面和 Json 能获取的所有字段 Map&lt;String, Object&gt; map = super.getErrorAttributes(requestAttributes, includeStackTrace); map.put(\"company\", \"Welab\"); // 异常处理器携带的数据 Map&lt;String, Object&gt; map userNotExist = (Map&lt;String, Object&gt;)requestAttributes.getAttribute(\"userNotExist\",0); map.put(\"userNotExist\", userNotExist) return map; &#125;&#125; 嵌入式 Servlet 容器由于 Spring Boot 默认是以 Jar 包的方式启动嵌入式的 Servlet 容器来启动 Spring Boot 的 web 应用，没有 web.xml 文件。 Spring Boot 修改和 server 有关的配置： 123456# 方式一：propertiesserver.port=8081server.context-path=/crudserver.tomcat.uri-encoding=UTF-8# 通用的 Servlet 容器设置 server.xxx# Tomcat 的设置 server.tomcat.xxx 1234567891011// 编写嵌入式的 Servlet 容器的定制器来修改 Servlet 容器的配置@Bean //一定要将这个定制器加入到容器中public EmbeddedServletContainerCustomizer embeddedServletContainerCustomizer()&#123; return new EmbeddedServletContainerCustomizer() &#123; //定制嵌入式的Servlet容器相关的规则 @Override public void customize(ConfigurableEmbeddedServletContainer container) &#123; container.setPort(8083); &#125; &#125;;&#125; Servlet 三大组件的注册123456@Beanpublic ServletRegistrationBean myServlet()&#123; ServletRegistrationBean registrationBean = new ServletRegistrationBean( new MyServlet(),\"/myServlet\"); return registrationBean;&#125; 1234567@Beanpublic FilterRegistrationBean myFilter()&#123; FilterRegistrationBean registrationBean = new FilterRegistrationBean(); registrationBean.setFilter(new MyFilter()); registrationBean.setUrlPatterns(Arrays.asList(\"/hello\",\"/myServlet\")); return registrationBean;&#125; 123456@Beanpublic ServletListenerRegistrationBean myListener()&#123; ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener()); return registrationBean;&#125; 替换 Servlet 容器 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 引入 web 模块默认就是使用嵌入式的 Tomcat 作为 Servlet 容器 --&gt;&lt;/dependency&gt; 123456789101112131415161718&lt;!-- 引入web模块 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他的Servlet容器--&gt;&lt;dependency&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;!-- spring-boot-starter-undertow --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;&lt;/dependency&gt; 外置 Servlet 容器！！！创建的必须是一个 war 项目（利用 IDEA 创建好目录结构） 123456&lt;!-- 将嵌入式的 Tomcat 指定为 provided --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 必须要编写一个 SpringBootServletInitializer 的子类，并调用 configure() 方法。 123456789public class ServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123; // 传入 SpringBoot 应用的主程序 return application.sources(SpringBootMyApplication.class); &#125;&#125; REST 架构风格","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"}]},{"title":"Spring Boot 日志","slug":"Spring Boot/Spring Boot 日志框架","date":"2020-03-02T02:27:24.000Z","updated":"2020-04-19T06:43:49.668Z","comments":true,"path":"2020/03/02/Spring Boot/Spring Boot 日志框架/","link":"","permalink":"http://yoursite.com/2020/03/02/Spring%20Boot/Spring%20Boot%20%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/","excerpt":"Spring Boot 日志框架的使用。","text":"Spring Boot 日志框架的使用。 日志框架市面上常见的日志框架： 日志门面 （日志的抽象层） 日志实现 JCL: Jakarta Commons Logging;SLF4j: Simple Logging Facade for Java;Jboss-Logging Log4JJUL: java.util.logging;Log4J2 Logback Spring Boot 选用 SLF4J 和 Logback Q：Spring Boot 整合了很多框架，若整合的框架默认使用的日志框架与 Spring Boot 默认使用的日志框架不一样时，要怎么做？ A：排除整合框架的默认日志框架，用中间包来替代原有的日志框架。 SLF4J在开发的中，日志记录方法的调用不应该来直接调用日志的实现类，而是调用日志抽象层里面的方法。 12345678910// 给系统里面导入 SLF4J 的 JAR 和 Logback 的实现 JARimport org.slf4j.Logger;import org.slf4j.LoggerFactory;public class HelloWorld &#123; public static void main(String[] args) &#123; Logger logger = LoggerFactory.getLogger(HelloWorld.class); logger.info(\"Hello World\"); &#125;&#125; SLF4J 做为不同的日志实现框架的门面的配置结构： 统一日志记录： 将系统中其他日志框架先排除出去； 用中间包来替换原有的日志框架； 导入 SLF4J 的其他的实现。 Spring Boot 日志关系1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;&lt;/dependency&gt; Spring Boot 内配置的排除 Spring 的 Commons-Logging： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 日志的使用日志的级别： 12345678// 由低到高 trace &lt; debug &lt; info &lt; warn &lt; error// 可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效logger.trace(\"这是trace日志...\");logger.debug(\"这是debug日志...\");// SpringBoot 默认给我们使用的是 info 级别（root 级别）logger.info(\"这是info日志...\");logger.warn(\"这是warn日志...\");logger.error(\"这是error日志...\"); 日志输出格式： 1234567日志输出格式： %d表示日期时间; %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %thread表示线程名; %-5level：级别从左显示5个字符宽度; %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割; %msg：日志消息; %n是换行符。 Spring Boot 修改日志的默认设置 1234567891011121314logging.level.com.wingo=trace # 指定某个包路径下的日志输出等级# logging.path=# 不指定路径在当前项目下生成 springboot.log 日志# 可以指定完整的路径；# logging.file=G:/springboot.log# 在当前磁盘的根路径下创建 spring 文件夹和里面的 log 文件夹；使用 spring.log 作为默认文件# logging.path=/spring/log# 在控制台输出的日志的格式logging.pattern.console=%d&#123;yyyy-MM-dd&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n# 指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd&#125; === [%thread] === %-5level === %logger&#123;50&#125; ==== %msg%n 指定配置 给类路径下放上每个日志框架自己的配置文件即可，SpringBoot 就不使用他默认配置的了。 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy Log4J2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties logback.xml：直接就被日志框架识别了； logback-spring.xml：日志框架就不直接加载日志的配置项，由 SpringBoot 解析日志配置，可以使用 SpringBoot 的高级 Profile 功能。 SpringBoot 的高级 Profile 功能： 123&lt;springProfile name=\"staging\"&gt; &lt;!-- configuration to be enabled when the \"staging\" profile is active --&gt;&lt;/springProfile&gt; 配置文件12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration&gt; &lt;!-- 先定义所有的 appender --&gt; &lt;appenders&gt; &lt;!-- 输出控制台的配置 --&gt; &lt;console name=\"Console target=SYSTEM_OUT\"&gt; &lt;!-- 输出日志的格式 --&gt; &lt;patternlayout pattern=\"[%p] &gt;&gt;&gt; %m%n\"/&gt; &lt;/console&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;!-- 定义各种包下的日志的输出级别 --&gt; &lt;root level=\"DEBUG\"&gt; &lt;!-- 输出到控制台 --&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;/root&gt; &lt;logger name=\"org.springframework\" level=\"ERROR\"/&gt; &lt;logger name=\"com.baomidou\" level=\"ERROR\"/&gt; &lt;logger name=\"org.hibernate\" level=\"ERROR\"/&gt; &lt;logger name=\"com. alibaba druid\" level=\"ERROR\"/&gt; &lt;/loggers&gt;&lt;/configuration&gt; 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration scan=\"true\" scanPeriod=\"60 seconds\" debug=\"false\"&gt; &lt;contextName&gt;logback&lt;/contextName&gt; &lt;property name=\"log.path\" value=\"C:\\Users\\wingo\\Documents\\Recent\\log\" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;!-- &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt;--&gt; &lt;encoder&gt; &lt;pattern&gt;[%p] &gt;&gt;&gt; %m%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name=\"file\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/logback.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;%d&#123;HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;root level=\"info\"&gt; &lt;appender-ref ref=\"console\" /&gt; &lt;appender-ref ref=\"file\" /&gt; &lt;/root&gt; &lt;!-- logback为java中的包 --&gt; &lt;logger name=\"com.wingo.controller\"/&gt; &lt;!--logback.LogbackDemo：类的全路径 --&gt; &lt;logger name=\"com.wingo.controller.LearnController\" level=\"WARN\" additivity=\"false\"&gt; &lt;appender-ref ref=\"console\"/&gt; &lt;/logger&gt;&lt;/configuration&gt;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"}]},{"title":"Spring Boot 入门配置","slug":"Spring Boot/Spring Boot 入门配置","date":"2020-02-29T02:48:07.000Z","updated":"2020-04-19T06:43:54.554Z","comments":true,"path":"2020/02/29/Spring Boot/Spring Boot 入门配置/","link":"","permalink":"http://yoursite.com/2020/02/29/Spring%20Boot/Spring%20Boot%20%E5%85%A5%E9%97%A8%E9%85%8D%E7%BD%AE/","excerpt":"Spring Boot 2.x 的 Hello World 以及配置详解。","text":"Spring Boot 2.x 的 Hello World 以及配置详解。 背景：J2EE 笨重的开发、繁多的配置、底下的开发效率吧、复杂的部署流程、第三方技术集成难度大。 解决：Spring 全家桶 👉 Spring Boot J2EE 一站式解决方案 👉 Spring Cloud 分布式整体解决方案 Spring Boot 简介 简化 Spring 应用开发的一个框架； 整合 Spring 技术栈的一个大集合； J2EE 一站式解决方案。 微服务：一种架构风格，即一个应用应该是一组小型服务，这些小服务之间可以通过 HTTP 的方式进行通信，每一个功能元素最终都是一个可独立替换和独立升级的软件单元。 Spring Boot HelloWorld 功能：浏览器发送 hello 请求，服务器接受请求并处理，响应 Hello World 字符串 项目生成项目生成地址：Spring Initiizr 填写项目的基本信息后点击 Generate 下载生成的项目。 将项目解压到相应目录，打开 IDEA 导入项目。（File 👉 New 👉 Project from Existing Sources） 选择以 Maven 项目的方式导入。 设置 JDK ，点击 Environment settings 配置 Maven。 项目导入成功后的项目目录。 resources文件夹中目录结构 static：保存所有的静态资源； js css images 等； templates：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）； application.properties：Spring Boot 应用的配置文件；可以修改一些默认设置； 代码编写在 pom.xml 中加入 Spring Boot 的相关依赖。 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!-- 功能场景抽取成 Starter 来导入相关依赖 --&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 启动 Spring Boot 应用的主程序 1234567891011/** * @author wingo */@SpringBootApplicationpublic class JavaSpringbootWingoApplication &#123; public static void main(String[] args) &#123; run(JavaSpringbootWingoApplication.class, args); &#125;&#125; 编写相关的 Controller 123456789@Controllerpublic class HelloController &#123; @ResponseBody @RequestMapping(\"/hello\") public String hello()&#123; return \"Hello World!\"; &#125;&#125; 运行测试控制台打印中可看到 Tomcat 在其默认端口 8080 被开启。 访问：localhost:8080/hello 访问成功，此 Spring Boot 项目可正常运行。 简化部署123456789&lt;!-- 这个插件可以将应用打包成一个可执行的jar包，在 cmd 直接用 java -jar 命令执行 --&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; Hello World 探究项目依赖spring-boot-starter-Xxx：启动器 Spring Boot 场景启动器，用于自动导入了场景运行所依赖的组件。 123456&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!-- Starter 启动器的父项目 --&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;&lt;/parent&gt; 点击进入 spring-boot-starter-parent，它的父项目是 spring-boot-dependencies。 1234567&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;!-- 定义了各种依赖的版本号 --&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;&lt;/parent&gt; 主程序类（入口类）Spring Boot 用@SpringBootApplication来标注一个主程序类，说明这是一个 Spring Boot 应用。 123456@SpringBootConfiguration // 这是一个 Spring Boot 配置类@EnableAutoConfiguration // 开启自动配置功能@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123;&#125; Spring Boot 在启动的时候从类路径下的 META-INF/spring.factories 中获取 EnableAutoConfiguration 指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作。 按住 Ctrl 点击一个自动装配类： 发现有大量的@Conditional派生类，必须是在@Conditional指定的条件成立的情况下，才给容器中添加组件，配置里面的所有内容才生效。 可以通过 debug=true 属性让控制台打印自动配置报告。 Spring Boot 配置文件 application.properties application.yml YAML以数据为中心。 123server: port: 8081 path: /hello 基本语法： k:(空格)v 表示一对键值对（大小写敏感）； 以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的。 字符串字符串默认不用加上单引号或者双引号： 单引号：会转义特殊字符，特殊字符最终只是一个普通的字符串数据； 双引号：不会转义字符串里面的特殊字符，特殊字符会作为本身想表示的意思。 对象、Map： 123456friends: lastName: Wen age: 23# 行内写法friends: &#123;lastName: Wen,age: 23&#125; 数组、List、Set： 123456pets: - cat - dog # 行内写法friends: [cat,dog] 配置文件值的注入配置文件： 123456789101112person: lastName: hello age: 18 boss: false birth: 2017/12/12 maps: &#123;k1: v1,k2: 12&#125; lists: - lisi - zhaoliu dog: name: 小狗 age: 12 Java Bean 将配置文件中配置的每一个属性的值，映射到这个组件中。 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 @ConfigurationProperties告诉 SpringBoot 将本类中的所有属性和配置文件中相关的配置进行绑定； prefix = &quot;person&quot;配置文件中哪个下面的所有属性进行一一映射。 123456789101112131415161718192021/** * 将配置文件中配置的每一个属性的值，映射到这个组件中 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定； * prefix = \"person\"：配置文件中哪个下面的所有属性进行一一映射 * * 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能； * */@Component@ConfigurationProperties(prefix = \"person\")public class Person &#123; private String lastName; private Integer age; private Boolean boss; private Date birth; private Map&lt;String,Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog;&#125; 导入配置文件处理器，这样编写配置时会有提示。 123456&lt;!-- 导入配置文件处理器，配置文件进行绑定就会有提示 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; properties 配置文件在 IDEA 中默认 UTF-8 可能会乱码，勾选 Setting - File Encodings - Transparent native-to-ascii conversion。 @Value获取值和@ConfigurationProperties获取值比较 @ConfigurationProperties @Value 功能 批量注入配置文件中的属性 一个个指定 松散绑定（松散语法） 支持 不支持 SpEL 不支持 支持 JSR303数据校验 支持 不支持 复杂类型封装 支持 不支持 配置文件 yml 还是 properties 它们都能获取到值： 只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value； 专门编写了一个 JavaBean 来和配置文件进行映射，我们就直接使用@ConfigurationProperties； 配置文件注入校验数据。 12345678//...@Validated // 开启校验public class Person &#123; //... @Email // 必须为邮件格式 private String lastName; //...&#125; 配置文件的加载@PropertySource：加载指定的配置文件。 1@PropertySource(value = &#123;\"classpath:person.properties\"&#125;) @ImportResource：让 Spring 的配置文件生效，加载进来。Spring Boot 里面没有 Spring 的配置文件，我们自己编写的配置文件，也不能自动识别。 1@ImportResource(locations = &#123;\"classpath:beans.xml\"&#125;) Spring Boot 推荐使用全注解的方式。 12345678910@Configuration // 指明当前类是一个 Spring 配置类public class MyAppConfig &#123; //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名 @Bean public HelloService helloService()&#123; System.out.println(\"配置类 @Bean 给容器中添加组件了...\"); return new HelloService(); &#125;&#125; 配置文件占位符随机数： 12$&#123;random.value&#125;、$&#123;random.int&#125;、$&#123;random.long&#125;$&#123;random.int(10)&#125;、$&#123;random.int[1024,65536]&#125; 占位符获取之前配置过的值，可用:指定默认值 123456789person.last-name=张三$&#123;random.uuid&#125;person.age=$&#123;random.int&#125;person.birth=2017/12/15person.boss=falseperson.maps.k1=v1person.maps.k2=14person.lists=a,b,cperson.dog.name=$&#123;person.hello:hello&#125;_dog // 指定默认值person.dog.age=15 Profile多 Profile 文件：我们在主配置文件编写的时候，文件名可以是 application-{profile}.properties / yml，默认使用 application.properties 的配置。 Yaml 支持多文档块的方式： 12345678910111213141516171819server: port: 8081spring: profiles: active: prod # 指定激活哪个环境--- # 文档块分隔符server: port: 8083spring: profiles: dev # 属于 dev 环境---server: port: 8084spring: profiles: prod # 属于 prod 环境 激活指定的 Profile 在配置文件中指定spring.profiles.active=dev 命令行运行java -jar [项目 JAR 包] --spring.profiles.active=dev; 虚拟机参数-Dspring.profiles.active=dev 配置文件加载位置springboot 启动会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件 file:./config/ file:./ classpath:/config/ classpath:/ 优先级由高到底，高优先级的配置会覆盖低优先级的配置；SpringBoot 会从这四个位置加载全部配置文件形成互补配置。 项目打包好后，若要改变配置文件，可以使用命令行参数的形式 java -jar [项目 JAR 包] --spring.config.location=D:/application.properties 或者直接使用 --配置项=值的方式改变某一项配置 java -jar [项目 JAR 包] --server.port=8087 --server.context-path=/abc 优先级：外部 &gt; 内部、带 profile &gt; 不带 profile 启动原理解析","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"}]},{"title":"Netty 常用配置","slug":"Netty/Netty 常用配置","date":"2020-02-27T08:35:34.000Z","updated":"2020-02-27T13:28:37.178Z","comments":true,"path":"2020/02/27/Netty/Netty 常用配置/","link":"","permalink":"http://yoursite.com/2020/02/27/Netty/Netty%20%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/","excerpt":"在使用 Netty 的过程中会对 serverBootStrap 的 option 和 childOption 进行自定义的一些配置，具体就是使用ChannelOption 里面声明的常量进行配置，在此介绍一下这些常量。 Netty 的常用配置介绍","text":"在使用 Netty 的过程中会对 serverBootStrap 的 option 和 childOption 进行自定义的一些配置，具体就是使用ChannelOption 里面声明的常量进行配置，在此介绍一下这些常量。 Netty 的常用配置介绍 ChannelOption 服务端： option() 用于设置 ServerChannel 的选项，负责监听和接收连接； childOption()：用于设置 SocketChannel，负责处理 I/O 操作。 客户端： 没有 childOption()。 ChannelOption.SO_BACKLOG SO_BACKLOG 对应的是 TCP/IP 协议 listen() 函数中的 backlog 参数，函数 listen(int socketfd, int backlog) 用来初始化服务端可连接队列，服务端处理客户端链接是顺序处理的，所以同一时间只能处理一个链接，多客户端请求过来时，服务端会将未处理的请求放入请求队列，backlogb就是制定了队列的大小。 ChannelOption.SO_REUSEADDR SO_REUSEADDR 对应的是 Socket 选项中 SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，例如，某个服务占用了 TCP 的 8080 端口，其他服务再对这个端口进行监听就会报错，SO_REUSEADDR 这个参数就是用来解决这个问题的，该参数允许服务公用一个端口，这个在服务器程序中比较常用，例如某个进程非正常退出，对一个端口的占用可能不会立即释放，这时候如果不设置这个参数，其他进程就不能立即使用这个端口。 ChannelOption.SO_KEEPALIVE SO_KEEPALIVE 这个参数对应 Socket 中的 SO_KEEPALIVE，当设置这个参数为 true 后，TCP 连接会测试这个连接的状态，如果该连接长时间没有数据交流，TCP 会自动发送一个活动探测数据报文，来检测链接是否存活。 ChannelOption.TCP_NODELAY TCP_NODELAY 对应于 socket 选项中的 TCP_NODELAY，该参数的使用和 Nagle 算法有关，Nagle 算法是将小的数据包组装为更大的帧进行发送，而不会来一个数据包发送一次，目的是为了提高每次发送的效率，因此在数据包没有组成足够大的帧时，就会延迟该数据包的发送，虽然提高了网络负载却造成了延时，TCP_NODELAY 参数设置为 true，就可以禁用 Nagle 算法，即使用小数据包即时传输。与 TCP_NODELAY 对应的就是 TCP_CORK，该选项会等到发送的数据量最大的时候，一次性发送，适合进行文件传输。 ChannelOption.SO_SNDBUF 和 ChannelOption.SO_RCVBUF SO_SNDBUF 和 SO_RCVBUF 对应 Socket 中的 SO_SNDBUF 和 SO_RCVBUF 参数，即设置发送缓冲区和接收缓冲区的大小，发送缓冲区用于保存发送数据，直到发送成功，接收缓冲区用于保存网络协议站内收到的数据，直到程序读取成功。 CodecHttp 服务HttpServerCodec 将二进制报文转为 HTTP 文本报文。 HttpObjectAggregator(512*1024) 合并分批次过来的 HTTP 报文，合并后 Handler 拿到的将是一个完整的 HTTP 报文。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Chatroom 服务器","slug":"Chatroom/Chatroom 服务器","date":"2020-02-27T06:59:19.000Z","updated":"2020-03-02T06:50:21.855Z","comments":true,"path":"2020/02/27/Chatroom/Chatroom 服务器/","link":"","permalink":"http://yoursite.com/2020/02/27/Chatroom/Chatroom%20%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"Chatroom 中 Tomcat 服务器以及 WebSocket 服务器的整合。","text":"Chatroom 中 Tomcat 服务器以及 WebSocket 服务器的整合。 pom.xml 123456789101112131415161718192021222324&lt;!-- netty4 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;4.1.2.Final&lt;/version&gt;&lt;/dependency&gt;&lt;build&gt; &lt;finalName&gt;WebSocket&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.6.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;optimize&gt;true&lt;/optimize&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 自定义 WebSocket 服务器服务器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class WebSocketServer implements Runnable &#123; private final Logger logger = LoggerFactory.getLogger(WebSocketServer.class); @Autowired private EventLoopGroup bossGroup; @Autowired private EventLoopGroup workerGroup; @Autowired private ServerBootstrap serverBootstrap; // port 和 childChannelHandler 用 Xml 的方式配置，需要 getter/setter 方法 private int port; private ChannelHandler childChannelHandler; private ChannelFuture serverChannelFuture; public WebSocketServer() &#123; &#125; @Override public void run() &#123; build(); &#125; // 启动Netty Websocket服务器 public void build() &#123; try &#123; long begin = System.currentTimeMillis(); serverBootstrap.group(bossGroup, workerGroup) // boss 负责客户端的 TCP 连接请求 worker 负责与客户端之前的读写操作 .channel(NioServerSocketChannel.class) // 配置客户端的 channel 类型 .option(ChannelOption.SO_BACKLOG, 1024) // 设置请求队列的长度 .option(ChannelOption.TCP_NODELAY, true) // 降低延迟 .childOption(ChannelOption.SO_KEEPALIVE, true) // 两小时无活动检测心跳 .childOption(ChannelOption.RCVBUF_ALLOCATOR, new FixedRecvByteBufAllocator(592048)) // 配置固定长度接收缓存区分配器 .childHandler(childChannelHandler); // 绑定 I/O 事件的处理类，WebSocketChildChannelHandler 中定义 long end = System.currentTimeMillis(); logger.info(\"Netty Websocket服务器启动完成，耗时 \" + (end - begin) + \" ms，已绑定端口 \" + port + \" 阻塞式等候客户端连接\"); serverChannelFuture = serverBootstrap.bind(port).sync(); &#125; catch (Exception e) &#123; logger.info(e.getMessage()); bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); e.printStackTrace(); &#125; &#125; // 关闭 WebSocket 服务器 public void close()&#123; serverChannelFuture.channel().close(); Future&lt;?&gt; bossGroupFuture = bossGroup.shutdownGracefully(); Future&lt;?&gt; workerGroupFuture = workerGroup.shutdownGracefully(); try &#123; bossGroupFuture.await(); workerGroupFuture.await(); &#125; catch (InterruptedException ignore) &#123; ignore.printStackTrace(); &#125; &#125; public ChannelHandler getChildChannelHandler() &#123; return childChannelHandler; &#125; public void setChildChannelHandler(ChannelHandler childChannelHandler) &#123; this.childChannelHandler = childChannelHandler; &#125; public int getPort() &#123; return port; &#125; public void setPort(int port) &#123; this.port = port; &#125;&#125; 数据处理类 1234567891011121314151617181920@Componentpublic class WebSocketChildChannelHandler extends ChannelInitializer&lt;SocketChannel&gt;&#123; @Resource(name = \"webSocketServerHandler\") private ChannelHandler webSocketServerHandler; @Resource(name = \"httpRequestHandler\") private ChannelHandler httpRequestHandler; // 初始化通道，装载上所需要的处理器 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(\"http-codec\", new HttpServerCodec()); // HTTP编码解码器 ch.pipeline().addLast(\"aggregator\", new HttpObjectAggregator(65536)); // 合并分批次过来的 HTTP 报文，合并后 Handler拿到的将是一个完整的 HTTP 报文 ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler()); // 方便大文件传输，不过实质上都是短的文本数据 ch.pipeline().addLast(\"http-handler\", httpRequestHandler); // 绑定自定义的 Http 请求处理器 ch.pipeline().addLast(\"websocket-handler\",webSocketServerHandler); // 绑定自定义的 WebSocket 请求处理器 &#125;&#125; 自定义 Http 请求处理类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Component@Sharablepublic class HttpRequestHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception &#123; if (msg instanceof FullHttpRequest) &#123; // 处理 Http 请求 handleHttpRequest(ctx, (FullHttpRequest) msg); &#125; else if (msg instanceof WebSocketFrame) &#123; // retain() 增加 ByteBuf 的引用计数，fireChannelRead 通知需要继续调用链表后面的 channelRead ctx.fireChannelRead(((WebSocketFrame) msg).retain()); &#125; &#125; // 处理 Http 请求，主要是完成 HTTP 协议到 Websocket 协议的升级 private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) &#123; if (!req.decoderResult().isSuccess()) &#123; sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; &#125; // 构造握手工厂 WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory( \"ws:/\" + ctx.channel() + \"/websocket\", null, false); // 创建握手处理类 WebSocketServerHandshaker handshaker = wsFactory.newHandshaker(req); // 将此连接保存到一个全局 Map 中，用户退出登陆时要移除此处理类 Constant.webSocketHandshakerMap.put(ctx.channel().id().asLongText(), handshaker); if (handshaker == null) &#123; WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel()); &#125; else &#123; // 构造握手响应消息返回给客户端 // 将 WebSocket 相关的编码和解码类动态添加到 ChannelPipeline 中用于 WebSocket 消息的编解码 handshaker.handshake(ctx.channel(), req); &#125; &#125; private void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, DefaultFullHttpResponse res) &#123; // 返回应答给客户端 if (res.status().code() != 200) &#123; ByteBuf buf = Unpooled.copiedBuffer(res.status().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); buf.release(); &#125; // 如果是非Keep-Alive，关闭连接 boolean keepAlive = HttpUtil.isKeepAlive(req); ChannelFuture f = ctx.channel().writeAndFlush(res); if (!keepAlive) &#123; f.addListener(ChannelFutureListener.CLOSE); &#125; &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 自定义 WebSocket 请求处理类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697@Component@Sharablepublic class WebSocketServerHandler extends SimpleChannelInboundHandler&lt;WebSocketFrame&gt; &#123; private static final Logger LOGGER = LoggerFactory.getLogger(WebSocketServerHandler.class); @Autowired private ChatService chatService; // 对 WebSocket 的请求消息进行处理 @Override protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame msg) throws Exception &#123; handlerWebSocketFrame(ctx, msg); &#125; private void handlerWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception &#123; // 关闭请求 if (frame instanceof CloseWebSocketFrame) &#123; WebSocketServerHandshaker handshaker = Constant.webSocketHandshakerMap.get(ctx.channel().id().asLongText()); if (handshaker == null) &#123; sendErrorMessage(ctx, \"不存在的客户端连接！\"); &#125; else &#123; handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); &#125; return; &#125; // ping请求 if (frame instanceof PingWebSocketFrame) &#123; ctx.channel().write(new PongWebSocketFrame(frame.content().retain())); return; &#125; // 只支持文本格式，不支持二进制消息 if (!(frame instanceof TextWebSocketFrame)) &#123; sendErrorMessage(ctx, \"仅支持文本(Text)格式，不支持二进制消息\"); &#125; // 客服端发送过来的消息 String request = ((TextWebSocketFrame)frame).text(); LOGGER.info(\"服务端收到新信息：\" + request); JSONObject param = null; try &#123; param = JSONObject.parseObject(request); &#125; catch (Exception e) &#123; sendErrorMessage(ctx, \"JSON字符串转换出错！\"); e.printStackTrace(); &#125; if (param == null) &#123; sendErrorMessage(ctx, \"参数为空！\"); return; &#125; String type = (String) param.get(\"type\"); switch (type) &#123; case \"REGISTER\": chatService.register(param, ctx); break; case \"SINGLE_SENDING\": chatService.singleSend(param, ctx); break; case \"GROUP_SENDING\": chatService.groupSend(param, ctx); break; case \"FILE_MSG_SINGLE_SENDING\": chatService.FileMsgSingleSend(param, ctx); break; case \"FILE_MSG_GROUP_SENDING\": chatService.FileMsgGroupSend(param, ctx); break; default: chatService.typeError(ctx); break; &#125; &#125; // 客户端断开连接 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123; chatService.remove(ctx); &#125; // 出现异常关闭通道 @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125; private void sendErrorMessage(ChannelHandlerContext ctx, String errorMsg) &#123; String responseJson = new ResponseJson() .error(errorMsg) .toString(); ctx.channel().writeAndFlush(new TextWebSocketFrame(responseJson)); &#125;&#125; 整合 WebSocket 服务器先来看看项目的服务器构成。 Tomcat 是一个免费的开放源代码的 Servlet 容器 回顾一下 Servlet 的生命周期。 要把 Netty WebSocket 服务器整合到 Tomcat 服务器中，那么就需要在 Servlet 初始化之前告诉其所需要进行的操作。写一个@PostConstruct注解方法开启一个独立线程用于启动 Netty WebSocket 服务器；并且写一个@PreDestory注解方法在 Servlet 完全关闭之前关闭 WebSocket 服务器。 1234567891011121314151617181920212223242526@Component@Scope(\"singleton\")public class AppContext &#123; private final Logger logger = LoggerFactory.getLogger(AppContext.class); @Autowired private WebSocketServer webSocketServer; private Thread nettyThread; @PostConstruct public void init() &#123; nettyThread = new Thread(webSocketServer); logger.info(\"开启独立线程，启动 Netty WebSocket 服务器...\"); nettyThread.start(); &#125; @PreDestroy public void close() &#123; logger.info(\"正在释放Netty Websocket相关连接...\"); webSocketServer.close(); logger.info(\"正在关闭Netty Websocket服务器线程...\"); nettyThread.stop(); logger.info(\"系统成功关闭！\"); &#125;&#125; 在执行这个方法之前，Tomcat 已经加载完配置文件，这里的 WebSocket 服务器是通过@AutoWired装载进来的，也就是说 WebSocket 需要在 Spring 容器中注册成为一个 Bean。 ApplicationContext-netty.xml 1234567891011121314&lt;!-- 扫描关于 Netty Websocket 的包 --&gt;&lt;context:component-scan base-package=\"com.wingo.web.websocket\"/&gt;&lt;!-- 把 Netty 的一些类服务器注册到 Spring，方便处理和扩展 --&gt;&lt;!-- 用于处理客户端连接请求 --&gt;&lt;bean id=\"bossGroup\" class=\"io.netty.channel.nio.NioEventLoopGroup\"/&gt;&lt;!-- 用于处理客户端 I/O 操作 --&gt;&lt;bean id=\"workerGroup\" class=\"io.netty.channel.nio.NioEventLoopGroup\"/&gt;&lt;!-- 服务器启动引导类 --&gt;&lt;bean id=\"serverBootstrap\" class=\"io.netty.bootstrap.ServerBootstrap\" scope=\"prototype\"/&gt;&lt;!-- 自定义的Netty Websocket服务器 --&gt;&lt;bean id=\"webSocketServer\" class=\"com.wingo.web.websocket.WebSocketServer\"&gt; &lt;property name=\"port\" value=\"3333\"/&gt; &lt;property name=\"childChannelHandler\" ref=\"webSocketChildChannelHandler\" /&gt;&lt;/bean&gt;","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"}],"tags":[{"name":"Chatroom","slug":"Chatroom","permalink":"http://yoursite.com/tags/Chatroom/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Netty Websocket","slug":"Netty-Websocket","permalink":"http://yoursite.com/tags/Netty-Websocket/"}]},{"title":"CET6 阅读真题","slug":"English/CET6 阅读真题","date":"2020-02-25T08:00:45.000Z","updated":"2020-03-06T14:10:47.317Z","comments":true,"path":"2020/02/25/English/CET6 阅读真题/","link":"","permalink":"http://yoursite.com/2020/02/25/English/CET6%20%E9%98%85%E8%AF%BB%E7%9C%9F%E9%A2%98/","excerpt":"CET6 阅读真题。","text":"CET6 阅读真题。 201912 (一)When considering risk factors associated with serious chronic diseases we often think about health indicators such as cholesterol, blood pressure and body weight. But poor diet and physical inactivity also each increase the risk of heart disease and have a role to play in the development of some cancers. Perhaps worse, the detrimental effects of an unhealthy diet and insufficient exercise are not limited to your body. Recent research has also shown that indulging in a high-fat and high-sugar diet may have negative effects on your brain, causing learning and memory deficits. chronic disease 慢性病 health indicator 健康指标 cholesterol 胆固醇 physical inactivity 缺乏运动 detrimental effect 有害影响 insufficient exercise 缺乏运动 indulge in 沉溺于 memory deficit 记忆衰退 Studies have found obesity is associated with impairments in cognitive functioning, as assessed by a range of learning and memory tests, such as the ability to remember a list of words presented some minutes or hours earlier. There is also a growing body of evidence that diet — induced cognitive impairments can emerge repidly — within weeks or even days. For example, one study found healthy adults assigned to a high-fat diet for five days showed impaired attention, memory, and mood compared with a low-fat diet control group. Another study also found eating a high-fat and high-sugar breakfast each day for as little as four days resulted in problems with learning and memorry similar to those observed in overweight and obese individuals. obesity 肥胖 impairment 损害 cognitive functioning 认知功能 a growing body of… 越来越多的… assign to 指定到 impaired attention 注意力受损 as little as 少至 obses individuals 肥胖个体 Body weight was not hugely different between the groups eating a healthy diet and those on high and sugar diets. So this shows negative consequences of poor dietary intake can occur even when body weight has not changed conspicuously. Thus, body weight is not always the best indicator of health and a thin person still needs to eat well and exercise regularly. dietary 与饮食有关的 conspicuously 显著地 Increased Screen Time and Wellbeing Decline in YouthHave young people never had it so good? Or do they face more challenges than any previous generation? Our current era in the West is one of high wealth. This means minors enjoy material benefits and legal protections that would have been the envy of those living in the past. But There is an increasing suspicion that all is not well for our youth. And one of the most popular explanations, among some experts and the popular media, is that excessive “screen time” is to blame. (This refers to all the attention young people devote to their phones, tablets and laptops. )However, this is a contentious theory and such claims have been treated skeptically by some scholars based on their reading of the relevant data. era 时代 minor 未成年人 the envy of 令人嫉妒 / 羡慕的人 / 事物 excessive 过度的 tablet PC = laptop computer 笔记本电脑 contentious theory 有争议的理论 skeptically 怀疑地 Now a new study has provided another contribution to the debate, uncovering strong evidence that adolescent wellbeing in the United States really is experiencing a decline and arguing that the most likely cause is the electronic riches we have given them. The background to this is that from the 1960s into the early 2000s measures of average wellbeing went up in the US. This was especially true for younger people. It reflected the fact that these decades saw a climb in general standards of living and avoidance of mass societal traumas like full-scale war or economic deprivation. However, the “screen time” hypothesis, advanced by researchers such as Jean Twenge, is that electronic devices and excessive time spent online may have reversed these trends in recent years causing problems for young peoples psychological health. debate 争论 mass societal traumas 大规模地社会创伤 economic deprivation 经济剥夺 hypothesis 假设 advanced by researchers 被研究人员推进 To investigate, Twenge and her colleagues dived into the “Monitoring the Future” dataset based on annual surveys of American school students from grades 8, 10, and 12 that started in 1991. In total, 1.1 million young people answered various questions related to their wellbeing. Twenge’s teams analysis of the answers confirmed the earlier, well-established wellbeing climb, with scores rising across the 1990s, and into the later 2000s. This was found across measures like self-esteem, life satisfaction, happiness and satisfaction with individual domains like job, neighborhood or friends. But around 2012 these measures started to decline. This continued through 2016, the most recent year for which data is available. well-established 为大家接受的 self-esteem 自尊 individual domain个别领域 Twenge and her colleagues wanted to understand why this change in average wellbeing occurred. However, it is very hard to demonstrate causes using non-experimental data such as this. In fact, when Twenge previously used this data to suggest a screen time effect, some commentators were quick to raise this problem. They argued that her causal-sounding claims rested on correlational data, and that she had not adequately accounted for other potential causal factors. This time around, twenge and her team make a point of saying that they are not trying to establish causes as such, but that they are assessing the plausibility of potential causes. causal-sounding 因果关系 account for sth 解释…的原因 plausibility 貌似可信 First, they explain that if a given variable is playing a role in affecting wellbeing, then we should expectany change in that variable to correlate with the observed changes in wellbeing. If not, it is not plausible that the variable is a causal factor. So the researchers looked at time spent in a number of activities that could plausibly be driving the wellbeing decline. Less sport, and fewer meetings with peers correlated with lower wellbeing, as did less time reading print media (newspapers) and, surprisingly, less time doing homework. (This last finding would appear to contradict another popular hypothesis that it is our burdening of students with assignment that is causing all the problems. ) In addition, more tv watching and more electronic communication both correlated with lower wellbeing. All these effects held true for measures of happiness, life satisfaction and self-esteem, with the effects stronger in the 8th and 10th-graders. held true for… 对…也一样成立 Next, Twenge’s team dug a little deeper into the data on screen time. They found that adolescents whospent a very small amount of time on digital devices — couple of hours a week — had the highest wellbeing. Their wellbeing was even higher than those who never used such devices. However, higher doses of screen time were clearly associated with lower happiness. Those spending 10-19 hours per week on their devices were 4 percent more likely to be unhappy than lower-frequency users. Those who used such devices 40 hours a week or more (one in ten teenagers) were twice as likely to be unhappy. The data was slightly complicated by the fact that there was a tendency for kids who were social in the real world to also use more online communication, but by bracketing out different cases it became clear that the real-world sociality component correlated with greater wellbeing, whereas greater time on screens or online only correlated with poorer wellbeing. doses of …的剂量 bracket out 摆脱 So far, so plausible. But the next question is, are the drops in average wellbeing happening at the sametime as trends toward increased electronic device usage? It looks like it — after all, 2012 was the tipping point when more than half of Americans began owning smartphones. Twenge and her colleagues also found that across the key years of 2013-16, wellbeing was indeed lowest in years where adolescents spent more time online, on social media, and reading news online, and when more youth in the United States had smartphones. And in a second analysis, they found that where technology went, dips in wellbeing followed. For instance, years with a larger increase in online usage were followed by years with lower wellbeing, rather than the other way around. This does not prove causality, but is consistent with it. Meanwhile, TV use did not show this tracking. TV might make you less happy, but this is not what seems to be driving the recent declines in young people s average happiness. rather than the other way around 而不是相反的 causality 因果关系 be consistent with 符合 A similar but reversed pattern was found for the activities associated with greater wellbeing. For example, years when people spent more time with friends were better years for wellbeing (and followed by better years). Sadly, the data also showed face-to-face socializing and sports activity had declined over the period covered by the survey. There is another explanation that Twenge and her colleagues wanted to address: the impact of the greatrecession of 2007-2009, which hit a great number of American families and might be affecting adolescents. The dataset they used did not include economic data, so instead the researchers looked at whether the 2013-16 wellbeing decline was tracking economic indicators. They found some evidence that some crude measures, like income inequality, correlated with changes in wellbeing. but economic measures with a more direct impact like family income and unemployment rates (which put families into difficulties), had no relationship with wellbeing. The researchers also note the recession hit some years before we see the beginning of the wellbeing drop, and before the steepest wellbeing decline, which occurred in 2013. the great recession 大衰退 crude 粗糙的 cruel 残酷的 The researchers conclude that electronic communication was the only adolescent activity that increased atthe same time psychological wellbeing declined. I suspect that some experts in the field will be keen to address alternative explanations, such as unassessed variables playing a role in the wellbeing decline. but the new work does go further than previous research and suggests that screen time should still be considered a potential barrier to young people’s flourishing. flourishing 繁荣的 Passage OneThe dangerous thing about lying is people don’t understand how the act changes us, says Dan Arielybehavioural psychologist at Duke University. Psychologists have documented children lying as early as the age of two. Some experts even consider lying a developmental milestone, like crawling and walking. because it requires sophisticated planning, attention and the ability to see a situation from someone else’s perspective to manipulate them. But, for most people, lying gets limited as we develop a sense of morality and the ability to self-regulate. behavioural psychologist 行为心理学家 sophisticated planning 复杂的规划 manipulate 操作 Harvard cognitive neuroscientist Joshua Greene says. for most of us, lying takes work. In studies, he gavesubjects a chance to deceive for monetary gain while examining their brains in a functional MRI machine, which maps blood flow to active parts of the brain. Some people told the truth instantly and instinctively. But others opted to lie, and they showed increased activity in their frontal parietal control network, which isinvolved in difficult or complex thinking. This suggests that they were deciding between truth and dishonesty and ultimately opting for the latter. For a follow-up analysis, he found that people whose neural reward centres were more active when they won money were also more likely to be among the group of liars — suggesting that lying may have to do with the inability to resist temptation. cognitive neuroscientist 认知神经学家 deceive for monetary gain 骗取金钱收益 subject 受试者 instinctively 本能地 ultimately 最后 the inability to resist temptation 无法抗拒诱惑 External conditions also matter in terms of when and how often we lie. We are more likely to lie, researchshows, when we are able to rationalise it, when we are stressed and fatigued or see others being dishonest and we are less likely to lie when we have moral reminders or when we think others are watching. We as a society need to understand that, when we don’t punish lying we increase the probability it will happen again, Ariely says. in terms of 在…方面 fatigued 疲乏的 rationalise 使合理化 In a 2016 study published in the journal Nature Neuroscience, Ariely and colleagues showed how dishonesty alters peoples brains, making it easier to tell lies in the future. When people uttered a falsehood, the scientists noticed a burst of activity in their amygdala. The amygdala is a crucial part of the brain that produces fear, anxiety and emotional responses including that sinking, guilty feeling you get when you lie. But when scientists had their subjects play a game — in which they won money by deceiving their partner, they noticed the negative signals from the amygdala began to decrease. not only that, but when people faced no consequences for dishonesty their falsehoods tended to get even more sensational. This means that if you give people multiple opportunities to lie for their own benefit, they start with little lies which get bigger over time. alter 改变 alternate 交替的 utter a falsehood 说谎 crucial 决定性的 sinking 消沉 sensational 轰动的 Passage TwoHere’s how the pacific northwest is preparing for “The big one”. It’s the mother of all disaster drills for what could be the worst disaster in American history. California has spent years preparing for “The big one” — the inevitable earthquake that will undoubtedly unleash all kinds of havoc along the famous San Andreas fault. But what if the fault that runs along the pacific northwest delivers a gigantic earthquake of its own? If the people of the Cascadia region have anything to do with it, they wont be caught unawares. It’s the mother of disaster drills 灾难演习的源头 unleash all kinds of havoc释放各种破坏 fault 断层 The region is engaged in a multi-day earthquake-and-tsunami drill involving around 20,000 people. The Cascadia Rising drill gives area residents and emergency responders a chance to practice what to do in case of a 9.0-magnitude earthquake and tsunami along one of the nations dangerous — and underestimated — faults. be engaged in 从事 进行 tsunami 海啸 emergency responders 应急人员 The Cascadia Earthquake Zone is big enough to compete with San Andreas ( it’s been called the mostdangerous fault in America), but it’s much lesser known than its California cousin. Nearly 700 miles long the earthquake zone is located by the North American Plate off the coast of Pacific British Columbia, Washington Oregon and Northern California. Cascadia is what’s known as a “megathrust” fault. Megathrusts are created in earthquake zones — land plate boundaries where two plates converge. In the areas where one plate is beneath another, stress builds up over time. During a megathrust event, all of that stress releases and some of the worlds most powerful earthquakes occur. Remember the 9. 1 earthquake and tsunami in the Indian Ocean off Sumatra in 2004? It was caused by a megathrust event as the India plate moved beneath the Burma micro-plate. The last time a major earthquake occurred along the Cascadia fault was in 1700, so officials worry thatanother event could occur any time. To prevent that event from becoming a catastrophe, first responders will join members of the public in rehearsals that involve communication, evacuation, search and rescue, and other scenarios. first responders 急救人员 rehearsal 练习 evacuation 疏散 Thousands of casualties are expected if a 9.0 carthquake were to occur. First the earthquake would shakemetropolitan areas including Seattle and Portland. This could trigger a tsunami that would create havoc along the coast. Not all casualties can necessarily be prevented — but by coordinating across local, state, and even national borders, officials hope that the worst-case scenario can be averted. On the exercises website officials explain that the report they prepare during this rehearsal will inform disaster management for years to come. casualty 伤亡人员 trigger 触发 averted 避免 For hundreds of thousands of cascadia residents, “The big one” isn’t a question of if, only when. and it’snever too early to get ready for the inevitable. 12 (二)The persistent haze over many of our cities is a reminder of the polluted air that we breathe, Over 80% of the world’s urban population is breathing air that fails to meet World Health Organisation guidelines, and an estimated 4.5 million people died prematurely from outdoor air pollution in 2015. Globally, urban populations are expected to double in the next 40 years, and an extra 2 billion people will need new places to live, as well as services and ways to move around their cities. What is more important, the decisions that we make now about the design of our cities will determian the everyday lives and health of the coming gerations. So what would a smug-free, or at least low-pollution, city be like? Traffic has become synonymous with air pollution, and many countries intend to ban the sale of new petrol and diesel cars in the next two decades. But simply switching to electric can will not mean pollution-free cities. The level of emissions they cause will depend on how the electricity to run them is generated, while brakes, tyres and toads all create tiny airborne particles as they wear out. Across the developed world, car use is in decline as more people move to city centers, while young people especially are opting for other means of travel. Researchers are already asking if motor vehicle use has reached itspeak and will decline, but transport planners have yet to catch up with this trend, instead of laying new roads to tackle traffic jams. As users of London’s orbital M25 motorway will know, new roads rapidly fill with more traffic. In the US, studies have shown that doubling the size of a road can simply double the traffic, taking us back to the starting poin. How Much Protein Do You Really Need?The marketing is tempting: Get stronger muscles and healthier bodies with minimal effort by adding protein powder to your morning shake or juice drink. Or grab a protein bar at lunch or for a quick snack. Today you can find protein supplements everywhere — online or at the pharmacy, grocery store or health food store. They come in powders, pills and bars. With more than $12 billion in sales this year, the industry is booming and according to the market research company, Grand View Research, is on track to sell billions more by 2025. But do we really need all this supplemental protein? It depends. There are pros, cons and some other things to consider. the marketing is tempting 营销很诱人 protein powder 蛋白粉 pharmacy 药房 pros and cons 利与弊 For starters, protein is critical for every cell in our body. It helps build nails, hair, bones and muscles. Itcan also help you feel fuller longer than eating foods without protein. And, unlike nutrients that are found only in few foods, protein is present in all foods. The typical American diet is a lot higher in protein than a lot of us think, says registered dietitian Angela Pipitone. It’s in foods many of us expect, such as beef, chicken and other types of meat and dairy. But it’s also in foods that may not come immediately to mind like vegetables, fruit, beans and grains. critical 至关重要的 dietitian 营养师 grain 谷物 shake 奶昔 broccoli 西兰花 The U.S. government’s recommended daily allowance (RDA) for the average adult is 50 to 60 gram of protein a day. This may sound like a lot, but Pipitone says: “We get bits of protein here and there and that really adds up throughout the day.” Take, for example, breakfast If you eat two eggs topped with a little bit of cheese and an orange on the side, you already have 22 grams of protein. Each egg gives you 7 grams, the cheese gives you about 6 grams and the orange — about 2 grams. Add a lunch of chicken, rice and broccoli, and you are already over the recommended 50 grams. ”You can get enough protein and meet the RDA before you even get to dinner,“ says Pipitone. So if it’s so easy to get your protein in food, why add more in the form of powders, snack bars or a boost at your local juice bar? No need to, says Pipitone, because, in fact, most of us already get enough protein in our diet. “Whole foods are always the best option rather than adding supplements,” she says, noting the FDA does not regulate supplements as rigorously as foods or drugs. So there could be less protein, more sugar and some additives you wouldn’ t expect, such as caffeine. regulate 控制 调控 有系统管理的 rigorously 严厉地 残酷地 If you are considering a supplement, read the list of ingredients, she says, although this is not always reliable. “I’ve seen very expensive protein supplements that claim to be high quality but they might not really be beneficial for the average healthy adult,” she says. “It could just be a waste of money.” ingredient 组成部分 配料 do warrant 可以 允许 marathon 马拉松 moderately 适度地 有节制地 edge 优势 But there are certain situations that do warrant extra protein. “Anytime you’re repairing or building muscle.” Pipitone says, “such as if you’re an extreme endurance athlete training for a marathon or you’re a body builder. If you are moderately exercising for 150 minutes a week, as the Centers for Disease Control and Prevention recommends, or less than that, you’ re probably not an extreme athlete. Extreme athletes expend lots of energy breaking down and repairing and building muscles. Protein can give them the edge they need to speed that process. Vegans can benefit from protein supplements since they do not eat animal-based protein sources like meat, dairy or eggs. And, for someone always on-the-go who may not have time for a meal, a protein snack bar can be a good option for occasional meal replacement. Also, individuals recovering from surgery or an injury can also benefit from extra protein. So, too, can older people. At around age 60, “muscles really start to break down,” says Kathryn Starr, an aging researcher, “and because of that, the protein needs of an older adult actually Increase.” Vegans 纯素主义者 dairy 奶制品 In fact, along with her colleague Connie Bales. Starr recently conducted a small study that found that adding extra protein foods to the diet of obese older individuals who were trying to lose weight strengthened their muscles. Participants in the study were separated into two groups — one group was asked to eat 30 grams of protein per meal in the form of whole foods. That meant they were eating 90 grams of protein a day. The other group — the control group — was put on a typical low-calorie diet with about 50 to 60 grams of protein a day. after six months, researchers found the high protein group had significantly improved their muscle function — almost twice as much as the control group. “They were able to walk faster, had improved balance, and were also able to get up out of a chair faster than the control group.” Starr says. All 67 participants were over 60 years of age, and both groups lost about the same amount of weight. Starr is now looking into whether high-protein diets also improve the quality of the muscle itself in seniors. She’s using CT scans to measure muscle size and fat, and comparing seniors on a high-protein diet with those on regular diets. She says her findings should be available in a couple of months. In the meantime, 70-year-old Corliss Keith, who was in the high protein group in Starr’s latest study, say the feels a big difference. “I feel excellent,” she says. “I feel like i have a different body. I have more energy stronger.” She says she is able to take Zumba exercise classes three times a week, work out on the treadmill and take long, brisk walks. Keith also lost more than 15 pounds. “Im a fashionable person, so now I’m back in my 3-inch heels,” she says work out on the treadmill 在跑步机上运动 heel 高跟鞋 As people age, Starr says muscle strength is key to helping them stay strong and continue living on their own in their own home. “I feel very much alive now,” says Keith. “I feel like I could stay by myself until I’m 100.” Bat can people overdo protein? Pipitone says you do have to be careful. Other researchers say too much protein can cause cramps, headaches, and fatigue. Dehydration risk is also a risk when you eat too much protein. Pipitone says if you increase protein, you also have to increase your fluid intake. I always tell people to make sure they‘re drinking enough fluids, which for the average person is 60 to 70 ounces a day, which translates into eight 8-ounce glasses of water or liquid per day. cramp 肌肉抽搐 fatigue 疲劳 dehydration 脱水 kidney 肾脏 There have been some indications that extra protein makes the kidneys work harder, which could be problematic for individuals with a history of kidney disease and for them the supplements may increase the risk of kidney stones, the says. Bottom line, if you think you need more protein in your diet, consider these questions: Are you anextreme athlete; are you recovering from injury or surgery; or are you 60 years or older? If so, adding high protein foods like eggs and meat products to your diet can be beneficial. And, if you’re not sure, in is always a good idea to check with your primary care provider. Passage OneLast year, a child was born at a hospital in the uk with her heart outside her body. Few babies survive this rare condition,and those who do must endure numerous operations and are likely to have complex needs. When her mother was interviewed, three weeks after her daughter’s birth, she was asked if she was prepared for what might be a daunting task caring for her. She answered without hesitation that, as far as she was concerned, this would be a “privilege”. daunt 使气馁 privilege 荣幸 特殊待遇 ideologies 意识形态 interpret 解释 interrupt 打断 Rarely has there been a better example of the power of attitude, one of our most powerful psychological tools. Our attitudes allow us to turn mistakes into opportunities, and loss into the chance for new beginnings. An attitude is a settled way of thinking, feeling and/or behaving towards particular objects, people, events or ideologies. We use our attitudes to filter, interpret and react to the world around us. You weren’t born with attitudes; rather they are all learned, and this happens in a number of ways. The most powerful influences occur during early childhood and include both what happened to you directly and what those around you did and said in your presence. As you acquire a distinctive identity your attitudes are further refined by the behavior of those with whom you identify — your family, those of your gender and culture and the people you admire, even though you may not know them personally. Friendships and other important relationships become increasingly important, particularly during adolescense, About that same time and throughout adulthood, the information you receive, especially when ideas are repeated in association with goals and achievements you find attractive, also refines your attitudes. acquire a distinctive identity 获得独特的身份 refined 完善 Many people assume that our attitudes are internally consistent, that is, the way you think and feel about someone or something predicts your behavior towards them. However, may studies have found that feelings and thoughts don’t necessarily predict behavior. In general, your attitudes will be internally consistent only when th behavior is easy, and when those around you hold similar beliefs. That’s why, for example, many say they believe in the benefits of recycling or exercise, but don’t behave in line with their views, because it takes awareness, effort and courage to go beyond merely stating that you believe something is a good idea. One of the most effective ways to change an attitude is to start behaving as if you already feel and think the way you’d prefer to. Take some time to reflect on your attitudes, to think about what you believe and why. Is there anything you consider a burden rather than a privilege? It so, start behaving right now as if the latter is the case. Passage TwoIndustrial fishing for krill in the unspoilt waters around Antarctica is threatening the future of one of the worlds last great wildernesses, according to a new report. the unspoilt waters 未受污染的水域 vessel 容器 in the immediate vicinity of 在…附近 penguin 企鹅 The study by Greenpeace analysed the movements of krill fishing vessels in the region and found they were increasingly operating “in the immediate vicinity of penguin colonies and whale feeding grounds.” It also highlights incidents of fishing boats being involved in groundings, oil spills and accidents, which posed a serious threat to the Antarctic ecosystem. oil spills 漏油 Antarctic 南极 sanctuary 保护区 tract 土地 地带 reserve 保护区 保留 存储 marine 海的 The report, published on Tuesday, comes amid growing concern about the impact of fishing and climate change on the Antarctic. a global campaign has been launched to create a network of ocean sanctuaries to protect the seas in the region and Greenpeace is calling for an immediate halt to fishing in areas being considered for sanctuary status. Frida Bengtsson from Greenpeace’s Protect the Antarctic campaign said: “If the krill industry wants to show it’s a responsible player, then it should be voluntarily getting out of any area which is being proposed as an ocean sanctuary, and should instead be backing the protection of these huge tracts of the Antarctic.” A global campaign has been launched to turn a huge tract of Antarctic seas into ocean sanctuaries, protecting wildlife and banning not just krill fishing, but all fishing. One was created in the ross sea in 2016, another reserve is being proposed in a vast area of the Weddell Sea, and a third sanctuary is under consideration in the area west of the Antarctic Peninsula — a key krill fishing area. The Commission for the Conservation of Antarctic Marine Living Resources (CCAMLR) manages the seas around Antarctica. It will decide on the Weddell Sea sanctuary proposal at a conference in Australia in October, although a decision on the peninsula sanctuary is not expected until later. peninsula 半岛 thrive 繁荣的 Keith Reid, a science manager at CCAMLR, said that the organisation sought “a balance between protection, conservation and sustainable fishing in the Southern Ocean.” He said although more fishing was taking placenearer penguin colonies it was often happening later in the season when these colonies were empty. The creation of a system of marine protected areas is a key part of ongoing scientific and policy discussions in CCAMLR, he added. “ Our long-term operation in the region depends on a healthy and thriving antarctic marine ecosystem, which is why we have always had an open dialogue with the environmental non-governmental organisations. We strongly intend to continue this dialogue, including talks with Greenpeace, to discuss improvements based on the latest scientific data. We are not the ones to decide on the establishment of marine protected areas, but we hope to contribute positively with our knowledge and experience.” 12（三）The number of devices you can talk to is multiplying — first it was your phone, then your cat, and now you can tell your kitchen appliances what to do. But even without gadgets that understand our spoken commands, research suggests that, as bizarre is it sounds under certain circumstances, people regularly ascribe human traits to everyday objects. gadgets 小配件 小工具 bizarre 奇异的 ascribe 把…归于 human traits 人的特质 under certain circumstances 在某些情况下 Sometimes we see things as human because we are lonely. In one experiment, people who reported feeling isolated were more likely than others to attribute consciousness to various gadget. In turn, feeling close to objects can alleviate loneliness. When college students were reminded of a time they had been exclude in a social setting, they compensated by exaggerating their number of friends — unless they were first given tasks that caused them to interact with their phone as if it had human qualities. according to the researchers the participants’ phones apparently substituted for real friends. isolated 孤立的 alleviate 缓和 in a social setting 在社交场合中 interact with 与…相互作用 At other times, we personify products in an effort to understand them. One study found that three in fourrespondents yelled at their computer. Further, the more their computer gave them problems, the more likely therespondents were to report that it had its own “beliefs and desires”. So how do people assign trails to an object? In part, we rely on looks. On humans wide faces are associated withdominance. Similarly, people rated cars, clocks and watches with wide faces as more dominant-looking thannarrow-faced ones, and preferred them — especially in competitive situations. An analysis of car sales in Germany found that cars with grilles that were upturned like smiles sold best. The purchasers saw this feature — as increasing acar’s friendliness. dominance 优势 支配地位 rate 认为 grille 格子,格栅 Why More Farmers Are Making The Switch to Grass-Fed Meat and Dairy?Though he didn’t come from a farming family, from a young age Tim Joseph was fascinated by the idea of living off the land. Reading magazines like The Stockman Grass Farmer and Graze, he got hooked on the idea of grass-fed agriculture. The idea that all energy and wealth comes from the sun really intrigued him. He thought the shorter the distance between the sun and the end product the higher the profit to the farmer. intrigued 好奇的 被迷住了的 Joseph wanted to put this theory to the test. In 2009, he and his wife Laura launched Maple hill Creamery, an organic, all grass-fed yogurt company in northern New York. he quickly learned what the market has demonstrated: Demand for grass-fed products currently exceeds supply. Grass-fed beef is enjoying a 25-30% annual growth rate. Sales of grass-fed yogurt and kefir, on the other hand, have in the last year increased by over 38%. This is in comparison with a drop of just under 1% in the total yogurt and kefir market, according to natural and organic market research company SPINS. Joseph’s top priority became getting is hands on enough grass-fed milk to keep customers satisfied, since his own 64-cow herd wasn’t going to suffice. demonstrate 显示 kefir 发酵乳饮品 exceed 超过 top priority 当务之急 suffice 足够 herd 畜群 His first partnership was with Paul and Phyllis Amburgh, owners of the Dharma Lea farm in New York. The Amburghs, too, were true believers in grass-fed. In addition to supplying milk from their own 85-head herd, they began to help other farmers in the area convert from conventional to certified organic and grass-fed in order to enter the Maple Hill supply chain. Since 2010, the couple has helped 125 small dairy farms convert to grass-fed, with more than 80% of those farms coming on board during the last two years. All this conversion has helped Maple hill grow 40-50% every year since it began, with no end in sight. Joseph has learned that a farmer has to have a certain mindset to successfully convert. But convincing open-minded dairy people is actually not that hard, when you look at the economics. Grass fed milk can fetch up to 2.5 times the price of conventional milk. Another factor is the squeeze that conventional dairy farmers have felt as the price of grain they feed their cows has gone up tightening their profit margins. By replacing expensive grain feed with regenerative management practices, grass-fed farmers are insulated from jumps in the price of feed. These practices include grazing animals on grasses grown from the pastureland’s natural seed bank, and fertilized by the cows’ own fertilizer. with no end in sight 看不到尽头 mindset 心态 insulate 隔离 graze 放牧 pastureland 牧草地 牧场 fertilizer 肥料 Champions of this type of regenerative grazing also point to its animal welfare, climate and health benefits: Grass-fed animals live longer out of confinement. Grazing herds stimulate microbial activity in the soil, helping to capture water and separate carbon. And grass-fed dairy and meat have been shown to be higher in certain nutrients and healthy fats. confinement 限制 被监禁 microbial 微生物的 In the grass-fed system, farmers are also not subject to the wildly fluctuating milk prices of the international commodity market. The unpredictability of global demand and the lag-time it takes to add more cows to a herd to meet demand can result in events like the recent cheese surplus. Going grass-fed is a safe refuge, a way for family-scale farms to stay viable. Usually a farmer will get to the point where financially, what they’re doing is not working. Thats when they call Maple Hill. If the farm is well managed and has enough land, and the desire to convert is sincere, a relationship can begin. Through regular regional educational meetings, a large annual meeting, individual farm visits and thousands of phone calls, the Amburghs pass on the principles of pasture management. Maple hill signs a contract pledging to buy the farmer’s milk at a guaranteed base price plus quality premiums and incentives for higher protein, butter-fat and other solids. fluctuating 波动 unpredictability 不可预测性 lag-time 滞后时间 surplus 过剩 refuge 庇护所 pasture 牧场 pass on 传递 incentive 激励 pledge 许诺 While Maple Hill’s conversion program is unusually hands-on and comprehensive, it’s just one of a growing number of businesses committed to slowly changing the way America farms. Joseph calls sharing his knowledge network through peer-to-peer learning a core piece of the companys culture. Last summer, Massachusetts grass-fed beef advocate John Smith launched Big Picture Beef, a network of small grass-fed beef farms in New England and New York that is projected to bring to market 2,500 head of cattle from 125 producers this year. Early indications are that Smith will have no shortage of farm members. Since he began to informal announce the network at farming conferences and on social media, he’s received a steady stream of inquiries from interested farmers. unusually 不寻常地 非常 inquiry 调查 Smith says he’ll provide services ranging from formal seminars to on-farm workshops on holistic management, to one-on-one hand-holding and an almost 24/7 phone hotline for farmers who are converting. In exchange, he guarantees an above- market price for each animal and a calf-to-customer electronic ear tag ID system like that used in the European Union. holostic 整体的 seminar 讨论会 calf 牛犊 Though advocates portray grass-fed products as a win-win situation for all, they do have downsides. Price, for one, is an issue. Joseph says his products are priced 10-20% above organic versions, but depending on the product chosen, compared to non-organic conventional yogurt, consumers could pay a premium of 30-50% or more for grass-fed. As for the meat, Smith says his grass-fed hamburger will be priced 20-25% over the conventional alternative. But a look at the prices on online grocer Fresh Direct suggests a grass-fed premium of anywhere from 35-60%. premium 额外费用 And not every farmer has the option of going grass-fed. For both beef and dairy production, it requires, at least in the beginning, more pastureland. Grass-fed beef production tends to be more labor-intensive as well. But Smith counters that if you factor in the hidden cost of government corn subsidies, environment degradation, and decreased human health and animal welfare, grass-fed is the more cost-effective model. The sun provides the lowest cost of production and the cheapest meat he says. labor-intensive 劳动密集型的 subsidy 津贴 degradation 下降 Another grass-fed booster spurring farmers to convert is EPIC, which makes meat-based protein bars. Founders Taylor Collins and his wife, Katie Forrest, used to be endurance athletes: now they’re advocates of grass-fed meat. Soon after launching EPICs most successful product — the Bison Bacon Cranberry Bar — Collins and Forrest found they‘d exhausted their sources for bison raised exclusively on pasture. When they started researching the supply chain, they learned that only 2-3% of all bison is actually grass-fed. The rest is feed lot confined and fed grain and corn. spur 激励 bison 野牛 confined (空间)有限的 But after General Mills bought EPIC in 2016, Collins and forrest suddenly had the resources they needed to expand their supply chain. So the company teamed up with Wisconsin-based rancher Northstar Bison. EPIC fronted the money for the purchase of $2. 5 million worth of young bison that will be raised according to its grass-fed protocols, with a guaranteed purchase price. The message to young people who might not otherwise be able to afford to break into the business is, ‘ You can purchase this $3 million piece of land here, because I’m guaranteeing you today you’ll have 1,000 bison on it. We’re bringing new blood into the old, conventional farming ecosystem, which is really cool to see,” Collins explains. protocol 条款 Passage OneSchools are not just a microcosm of society; they mediate it too. The best seek to alleviate the external pressures on their pupils while equipping them better to understand and handle the world outside — at once sheltering them and broadening their horizons. this is ambitious in any circumstances, and in a divided and unequal society the two ideals can clash outrigh. microcosm 缩影 pupil 学生 瞳孔 horizon 眼界 outright 直接地 Trips that many adults would consider the adventure of a lifetime — treks in Borneo, a sports tour to Barbados — appear to have become almost routine at some state schools. Parents are being asked for thousands of pounds. Though schools cannot profit from these trips, the companies that arrange them do. Meanwhile, pupils arrive at school hungry because their families cant afford breakfast. The Child Poverty Action Group says nine out of 30 in every claasroom fall below the poverty line. The discrepancy is startlingly apparent. Introducing a fundraising requirement for students does not help, as better-off children can tap up richer aunts and neighbours. discrepancy 差异 startlingly 令人震惊的 fundraising 筹款 Probing the rock pools of a local beach or practising French on a language exchange can fire childrens passions, boost their skills and open their eyes to lifes possibilities. Educational outings help bright but disadvantaged students to get better scores in A-level tests. In this globalised age, there is a good case for international travel, and some parents say they can manage the cost of a school trip abroad more easily than a family holiday. Even in the face of immense and mounting financial pressures, some schools have shown remarkable determination and ingenuity in ensuring that all their pupils are able to take up opportunities that may be truly life-changing. They should be applauded. Methods such as whole-school fundraising, with the proceeds pooled, can help to extend opportunities and fuel community spirit. probe 探索 remarkable 异常的 ingenuity 足智多谋 foster 滋养 But ￡3,000 trips cannot be justified when the average income for families with children is just over ￡30,000. Such initiatives close doors for many pupils. Some parents pull their children out of school because of expensive field trips. Even parents who can see that a trip is little more than a party or celebration may well feel guilt that their child is left behind. initiative 主动 board and lodging 食宿 syllabus 教学大纲 exempt 免除 glamorous 迷人的 exotic 吸引人的 The Department for Education’s guidance says schools can charge only for board and lodging if the trip is part of the syllabus, and that students receiving government aid are exempt from these costs. However, many schools seem to ignore the advice; and it does not cover the kind of glamorous, exotic trips which are becoming increasingly common. Schools cannot be expected to bring together communities single-handed. But the least we should expect is that they do not foster divisions and exclude those who are already disadvantaged. Passage TwoRising temperatures and overfishing in the pristine waters around the Antarctic could see king penguin populations pushed to the brink of extinction by the end of the century, according to a new study. The studys report states that as global warming transforms the environment in the world’s last great wilderness, 70 percent of king penguins could either disappear or be forced to find new breeding grounds. pristine 原始状态的 brink (危险的)边沿 extinction 灭绝 Co-author Celine le bohea, from the university of Strasbourg in France, warned: If therere no actions aimed at halting or controlling global warming, and the pace of the current human-induced changes such as climate change and overfishing stays the same, the species may soon disappear. The findings come amid growing concern over the future of the Antarctic. Earlier this month a separate study found that a combination of climate change and industrial fishing is threatening the kril population in Antarctic waters, with a potentially disastrous impact on whales, seals and penguins. But today’s report is the starkest warning yet of the potentially devastating impact of climate change and human exploitation on the Antarctic’s delicate ecosystems. stark 严酷的 wiped out 灭绝 plight 困境 mammal 哺乳动物 predic 预言 scarce 缺乏的 a handful of 少量的 Le Bohec said: “Unless current greenhouse gas emissions drop, 70 percent of king penguins — 1.1 millionbreeding pairs — will be forced to relocate their breeding grounds, or face extinction by 2100.” King penguins arethe second-largest type of penguin and only breed on specific isolated islands in the Southern Ocean where there isno ice cover and easy access to the sea. As the ocean warms, a body of water called the Antarctic Polar Front — anupward movement of nutrient-rich sea that supports a huge abundance of marine life — is being pushed furthersouth. This means that king penguins, which feed on fish and krill in this body of water, have to travel further totheir feeding grounds, leaving their hungry chicks for longer. And as the distance between their breeding, groundsand their fool grows, entire colonies could be wiped out. Le bohec said: “The plight of the king penguin should serve as a warning about the future of the entire marine environment in the Antarctic. Penguins, like other seabirds and marine mammals, occupy higher levels in the food chain and they are what we call bio-indicators of their ecosystems. Penguins are sensitive indicators of changes in marine ecosystems. As such, they are key species for understanding and predicting impacts of global change on Antarctic and sub-Antarctic marine ecosystems. The report found that although some king penguins may be able to relocate to new breeding grounds closer to their retreating food source, suitable new habitats would be scarce. Only a handful of islands in the Southern Ocean are suitable for sustaining large breeding colonies.","categories":[{"name":"English","slug":"English","permalink":"http://yoursite.com/categories/English/"}],"tags":[{"name":"CET6","slug":"CET6","permalink":"http://yoursite.com/tags/CET6/"}]},{"title":"Chatroom 各功能模块的实现","slug":"Chatroom/Chatroom 功能模块","date":"2020-02-24T02:20:02.000Z","updated":"2020-04-19T06:24:52.203Z","comments":true,"path":"2020/02/24/Chatroom/Chatroom 功能模块/","link":"","permalink":"http://yoursite.com/2020/02/24/Chatroom/Chatroom%20%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97/","excerpt":"Chatroom 各功能模块的分析与实现。","text":"Chatroom 各功能模块的分析与实现。 数据库结构 基于 Spring 注解式开发 前后端分离，返回 Json 的视图对象类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class ResponseJson extends HashMap&lt;String, Object&gt; &#123; private static final long serialVersionUID = 1L; private static final Integer SUCCESS_STATUS = 200; private static final Integer ERROR_STATUS = -1; private static final String SUCCESS_MSG = \"一切正常\"; public ResponseJson() &#123; super(); &#125; public ResponseJson(int code) &#123; super(); setStatus(code); &#125; public ResponseJson(HttpStatus status) &#123; super(); setStatus(status.value()); setMsg(status.getReasonPhrase()); &#125; public ResponseJson success() &#123; put(\"msg\", SUCCESS_MSG); put(\"status\", SUCCESS_STATUS); return this; &#125; public ResponseJson success(String msg) &#123; put(\"msg\", msg); put(\"status\", SUCCESS_STATUS); return this; &#125; public ResponseJson error(String msg) &#123; put(\"msg\", msg); put(\"status\", ERROR_STATUS); return this; &#125; public ResponseJson setData(String key, Object obj) &#123; @SuppressWarnings(\"unchecked\") HashMap&lt;String, Object&gt; data = (HashMap&lt;String, Object&gt;) get(\"data\"); if (data == null) &#123; data = new HashMap&lt;String, Object&gt;(); put(\"data\", data); &#125; data.put(key, obj); return this; &#125; public ResponseJson setStatus(int status) &#123; put(\"status\", status); return this; &#125; public ResponseJson setMsg(String msg) &#123; put(\"msg\", msg); return this; &#125; public ResponseJson setValue(String key, Object val) &#123; put(key, val); return this; &#125; /** * 返回JSON字符串 */ @Override public String toString() &#123; return JSONObject.toJSONString(this); &#125;&#125; 用来存放 Netty WebSocket 连接信息的常量类 123456789101112public class Constant &#123; // 一个 userId 对应一个 Session public static final String USER_TOKEN = \"userId\"; // 用于保存 Http 升级 WebSocket 后的握手实例 public static Map&lt;String, WebSocketServerHandshaker&gt; webSocketHandshakerMap = new ConcurrentHashMap&lt;String, WebSocketServerHandshaker&gt;(); // 用于保存已登录的用户的通道信息 public static Map&lt;String, ChannelHandlerContext&gt; onlineUserMap = new ConcurrentHashMap&lt;String, ChannelHandlerContext&gt;();&#125; 用户登录 User 👉 实体类，与数据库表 user 向对应 123456789public class User &#123; private Long userId; private String username; private String password; private String avatarUrl; // 省略了 Getter Setter toString 方法&#125; UserDao、UserMapper👉 通过用户输入的用户名到数据库中找到此用户的用户信息。 1User getByUsername(String username); 123456789&lt;select id=\"getByUsername\" resultType=\"com.wingo.model.po.User\" &gt; &lt;!-- 具体的sql --&gt; SELECT user_id, username, password FROM user WHERE username = #&#123;username&#125;&lt;/select&gt; SecurityService、SecurityServiceImpl 👉 实现登录的业务逻辑 123456789101112public ResponseJson login(String username, String password, HttpSession session) &#123; User user = userDao.getByUsername(username); if (user == null) &#123; return new ResponseJson().error(\"不存在该用户名\"); &#125; if (!user.getPassword().equals(password)) &#123; return new ResponseJson().error(\"密码不正确\"); &#125; // 将已登录的用户的 userId 保存在 Session 中 session.setAttribute(Constant.USER_TOKEN, user.getUserId()); return new ResponseJson().success();&#125; SecurityController 👉 URL映射以及前后端数据交互 12345@RequestMapping(value = \"login\", method = RequestMethod.POST)@ResponseBodypublic ResponseJson login(HttpSession session, @RequestParam String username, @RequestParam String password) &#123; return securityService.login(username, password, session);&#125; 用户点击登录按钮后，发送 Ajax 请求进行用户验证，验证通过后跳转到 chatroom 页面。 123456789101112131415161718192021&lt;script type=\"text/javascript\"&gt; function login() &#123; $.ajax(&#123; type : 'POST', url : 'login', dataType: 'json', data : &#123; username: $(\"#username\").val(), password: $(\"#password\").val() &#125;, async : false, success: function(data) &#123; if (data.status == 200) &#123; window.location.href=\"chatroom\"; &#125; else &#123; alert(data.msg); &#125; &#125; &#125;);&#125;&lt;/script&gt; 初始化用户信息 用户拦截认证UserAuthInteceptor 👉 检测用户是否登录并设置资源访问权限 12345678910111213141516171819202122232425262728public class UserAuthInteceptor implements HandlerInterceptor &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; HttpSession session = request.getSession(); Object userToken = session.getAttribute(Constant.USER_TOKEN); if (userToken == null) &#123; response.sendRedirect(\"login\"); return false; &#125; return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; // 允许所有资源都可以访问资源 response.setHeader(\"Access-Control-Allow-Origin\", \"*\"); // 表示是否可以将对请求的响应暴露给页面 response.setHeader(\"Access-Control-Allow-Credentials\",\"true\"); &#125; @Override public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception &#123; &#125;&#125; 配置 Spring MVC 对 chatoom 页面的访问请求进行拦截认证 1234567&lt;!-- 用户认证拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/chatroom/**\" /&gt; &lt;bean class=\"com.wingo.web.interceptor.UserAuthInteceptor\" /&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; PO &amp; VO在返回给用户的信息中，除了用户的个人信息，还需要用户的好友列表信息以及群聊列表信息。创建一个 VO 类用于保存前端所需要的所有信息。 UserInfo 类 123456789101112public class UserInfo &#123; private Long userId; private String username; private String password; private String avatarUrl; private List&lt;User&gt; friendList; // 好友列表信息 private List&lt;Chatgroup&gt; groupList; // 群聊信息 // 构造器方法便于实例化 // ...&#125; Chatgroup 类 123456789// group 为 MySQL 的关键字，不可使用public class Chatgroup &#123; private Long groupId; private String groupName; private String groupAvatarUrl; // ...&#125; GroupInfo 类 12345678910public class GroupInfo &#123; private Long groupId; private String groupName; private String groupAvatarUrl; private List&lt;User&gt; members; // 构造器方法便于实例化 // ...&#125; ChatroomController 👉 通过 userId 获取用户的信息 1234567@RequestMapping(value = \"/get_userinfo\", method = RequestMethod.POST) @ResponseBodypublic ResponseJson getUserInfo(HttpSession session) &#123; Object userId = session.getAttribute(Constant.USER_TOKEN); System.out.println(\"Session 中的 userId = \" + userId); return userService.getByUserId(String.valueOf(userId));&#125; UserServiceImpl 123456789101112131415161718192021222324252627282930313233343536373839@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Autowired private UserChatRelationDao userChatRelationDao; @Autowired private GroupDao groupDao; @Override public ResponseJson getByUserId(String userId) &#123; User user = userDao.getByUserId(userId); UserInfo userInfo = new UserInfo( user.getUserId(), user.getUsername(), user.getPassword(), user.getAvatarUrl() ); // friendList 构造 List&lt;String&gt; friendsId = userChatRelationDao.getUserFriendsIdByUserId(userId); List&lt;User&gt; friends = new ArrayList&lt;User&gt;(); for(String friendId : friendsId)&#123; User friend = userDao.getByUserId(friendId); friends.add(friend); &#125; // groupList 构造 List&lt;String&gt; groupsId = userChatRelationDao.getGroupsIdByUserId(userId); List&lt;Chatgroup&gt; groups = new ArrayList&lt;Chatgroup&gt;(); for(String groupId : groupsId)&#123; Chatgroup group = groupDao.getByGroupId(groupId); groups.add(group); &#125; userInfo.setGroupList(groups); userInfo.setFriendList(friends); return new ResponseJson().success() .setData(\"userInfo\", userInfo); &#125;&#125; 通过 Swagger 模拟请求取得返回的 Json 数据。 123456789101112131415161718192021222324252627282930313233343536373839&#123; \"msg\": \"一切正常\", \"data\": &#123; \"userInfo\": &#123; \"userId\": 1, \"username\": \"test1\", \"password\": null, \"avatarUrl\": \"static/img/avatar/Member001.jpg\", \"friendList\": [ &#123; \"userId\": 2, \"username\": \"test2\", \"password\": null, \"avatarUrl\": \"static/img/avatar/Member001.jpg\" &#125;, &#123; \"userId\": 4, \"username\": \"test3\", \"password\": null, \"avatarUrl\": \"static/img/avatar/Member001.jpg\" &#125;, &#123; \"userId\": 5, \"username\": \"test4\", \"password\": null, \"avatarUrl\": \"static/img/avatar/Member001.jpg\" &#125; ], \"groupList\": [ &#123; \"groupId\": 1000, \"groupName\": \"Group1\", \"groupAvatarUrl\": \"static/img/avatar/Group01.jpg\" &#125; ] &#125; &#125;, \"status\": 200&#125; 用户信息初始化完成。 页面布局粗略版 用户单聊前端页面在取得后台所返回的 Json 信息之后，根据信息初始化用户的聊天页面。 此程序不将聊天信息保存到数据库中，而是保存在前端的聊天页面用 Javascript 所自定义的一个数据结构里，一个SentMessageMap(key, new Array())。用户进行用户信息的初始化时要将此用户信息中的 groupId 以及 userId 作为键初始化这个聊天信息的 Map，以便后面进行聊天信息的保存。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function setUserInfo() &#123; $.ajax(&#123; type : 'POST', url : 'chatroom/get_userinfo', dataType: 'json', async : true, success: function(data) &#123; console.log(\"获取用户信息...\"); if (data.status == 200) &#123; // 自定义的数据结构，用于保存聊天信息进行回显 sentMessageMap = new SentMessageMap(); // 获取用户信息 var userInfo = data.data.userInfo; userId = userInfo.userId; $(\"#username\").html(userInfo.username); $(\"#avatarUrl\").attr(\"src\", userInfo.avatarUrl); var groupListHTML = \"\"; // 获取用户的群组信息 var groupList = userInfo.groupList; // 初始化群聊框列表 for (var i = 0; i &lt; groupList.length; i++) &#123; // 添加 Key sentMessageMap.put(groupList[i].groupId, new Array()); groupListHTML += '&lt;li&gt;' + '&lt;div class=\"liLeft\"&gt;&lt;img src=\"' + groupList[i].groupAvatarUrl + '\"&gt;&lt;/div&gt;' + '&lt;div class=\"liRight\"&gt;' + '&lt;span class=\"hidden-groupId\"&gt;' + groupList[i].groupId + '&lt;/span&gt;' + '&lt;span class=\"intername\"&gt;' + groupList[i].groupName + '&lt;/span&gt;' + '&lt;span class=\"infor\"&gt;&lt;/span&gt;' + '&lt;/div&gt;' + '&lt;/li&gt;'; &#125; // 添加群聊框列表 $('.conLeft ul').append(groupListHTML); var friendListHTML = \"\"; // 获取用户好友信息 var friendList = userInfo.friendList; // 初始化好友框列表 for (var i = 0; i &lt; friendList.length; i++) &#123; // 添加 Key sentMessageMap.put(friendList[i].userId, new Array()); friendListHTML += '&lt;li&gt;' + '&lt;div class=\"liLeft\"&gt;&lt;img src=\"' + friendList[i].avatarUrl + '\"&gt;&lt;/div&gt;' + '&lt;div class=\"liRight\"&gt;' + '&lt;span class=\"hidden-userId\"&gt;' + friendList[i].userId + '&lt;/span&gt;' + '&lt;span class=\"intername\"&gt;' + friendList[i].username + '&lt;/span&gt;' + '&lt;span class=\"infor\"&gt;&lt;/span&gt;' + '&lt;/div&gt;' + '&lt;/li&gt;'; &#125; // 添加好友列表 $('.conLeft ul').append(friendListHTML); // 绑定好友框点击事件：显示右侧消息框 $('.conLeft ul li').on('click', friendLiClickEvent); &#125; else &#123; alert(data.msg); &#125; &#125; &#125;);&#125; 单聊流程 监听绑定1234567891011121314151617181920212223242526272829303132333435363738if(!window.WebSocket)&#123; window.WebSocket = window.MozWebSocket; &#125; if(window.WebSocket)&#123; socket = new WebSocket(\"ws://localhost:3333\"); socket.onmessage = function(event)&#123; var json = JSON.parse(event.data); if (json.status == 200) &#123; var type = json.data.type; console.log(\"收到一条新信息，类型为：\" + type); switch(type) &#123; case \"REGISTER\": ws.registerReceive(); break; case \"SINGLE_SENDING\": ws.singleReceive(json.data); break; default: console.log(\"不正确的类型！\"); &#125; &#125; else &#123; alert(json.msg); console.log(json.msg); &#125; &#125;; // 连接成功1秒后，将用户信息注册到服务器在线用户表 socket.onopen = setTimeout(function(event)&#123; console.log(\"WebSocket已成功连接！\"); ws.register(); &#125;, 1000) socket.onclose = function(event)&#123; console.log(\"WebSocket已关闭...\"); &#125;; &#125; else &#123; alert(\"您的浏览器不支持WebSocket！\"); &#125; WebSocket 处理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162var ws = &#123; register: function() &#123; if (!window.WebSocket) &#123; return; &#125; if (socket.readyState == WebSocket.OPEN) &#123; var data = &#123; \"userId\" : userId, \"type\" : \"REGISTER\" &#125;; socket.send(JSON.stringify(data)); &#125; else &#123; alert(\"Websocket连接没有开启！\"); &#125; &#125;, singleSend: function(fromUserId, toUserId, content) &#123; if (!window.WebSocket) &#123; return; &#125; if (socket.readyState == WebSocket.OPEN) &#123; var data = &#123; \"fromUserId\" : fromUserId, \"toUserId\" : toUserId, \"content\" : content, \"type\" : \"SINGLE_SENDING\" &#125;; // 将信息发送给客户端的 WebSocketServerhandler 进行处理 socket.send(JSON.stringify(data)); &#125; else &#123; alert(\"Websocket连接没有开启！\"); &#125; &#125;, registerReceive: function() &#123; console.log(\"userId为 \" + userId + \" 的用户登记到在线用户表成功！\"); &#125;, singleReceive: function(data) &#123; // 获取、构造参数 console.log(data); var fromUserId = data.fromUserId; var content = data.content; var fromAvatarUrl; var $receiveLi; // 为设置消息提醒以及获取头像取得元素 $('.conLeft').find('span.hidden-userId').each(function()&#123; if (this.innerHTML == fromUserId) &#123; fromAvatarUrl = $(this).parent(\".liRight\") .siblings(\".liLeft\").children('img').attr(\"src\"); $receiveLi = $(this).parent(\".liRight\").parent(\"li\"); &#125; &#125;) var answer=''; answer += '&lt;li&gt;' + '&lt;div class=\"answers\"&gt;'+ content +'&lt;/div&gt;' + '&lt;div class=\"answerHead\"&gt;&lt;img src=\"' + fromAvatarUrl + '\"/&gt;&lt;/div&gt;' + '&lt;/li&gt;'; // 消息框处理 放入暂存区，若用户正处于与新发消息用户的聊天窗口则回显（利用暂存区计算高度） processMsgBox.receiveSingleMsg(answer, fromUserId); // 好友列表处理 1.设置红色提醒标志 2.设置部分新消息提醒 3.置顶新消息 processFriendList.receiving(content, $receiveLi); &#125;,&#125; 发送按钮1234567891011121314151617181920212223242526272829303132333435$('.sendBtn').on('click',function()&#123; var fromUserId = userId; var toUserId = $('#toUserId').val(); var toGroupId = $('#toGroupId').val(); var news = $('#dope').val(); if (toUserId == '' &amp;&amp; toGroupId == '') &#123; alert(\"请选择对话方\"); return; &#125; if(news == '')&#123; alert('消息不能为空'); return; &#125; else &#123; if (toUserId.length != 0) &#123; ws.singleSend(fromUserId, toUserId, news); &#125; else &#123; // 群发 &#125; $('#dope').val(''); var avatarUrl = $('#avatarUrl').attr(\"src\"); var msg = ''; msg += '&lt;li&gt;'+ '&lt;div class=\"news\"&gt;' + news + '&lt;/div&gt;' + '&lt;div class=\"nesHead\"&gt;&lt;img src=\"' + avatarUrl + '\"/&gt;&lt;/div&gt;' + '&lt;/li&gt;'; // 消息框处理： processMsgBox.sendMsg(msg, toUserId, toGroupId); // 好友列表处理： var $sendLi = $('.conLeft').find('li.bg'); processFriendList.sending(news, $sendLi); &#125;&#125;) 消息框处理123456789101112131415161718192021222324252627282930sendMsg: function(msg, toUserId, toGroupId) &#123; // 把内容添加到消息框 $('.newsList').append(msg); // 2. 手动计算、调整回显消息的宽度 var $newsDiv = $('.newsList li').last().children(\"div\").first(); var fixWidth = 300; // 自定义的消息框本身的最长宽度 var maxWidth = 493; // 消息框所在行 div 的满宽度（不包含头像框的宽度部分） var minMarginLeftWidth = 224; // 按理说应该是 maxwidth - fixWidth，这里出现了点问题 var marginLeftWidth; // 要计算消息框的margin-left宽度 if ($newsDiv.actual('width') &lt; fixWidth) &#123; marginLeftWidth = maxWidth - $newsDiv.actual('width'); $newsDiv.css(\"margin-left\", marginLeftWidth + \"px\"); &#125; else &#123; $newsDiv.css(\"width\", fixWidth + \"px\") .css(\"margin-left\", minMarginLeftWidth + \"px\"); &#125; // 3. 把 调整后的消息html标签字符串 添加到已发送用户消息表 if (toUserId.length != 0) &#123; // 得到数组添加新消息 以 outerHTML 的形式 // last() 得到匹配元素的最后一个 sentMessageMap.get(toUserId).push($('.newsList li').last().prop(\"outerHTML\")); &#125; else &#123; sentMessageMap.get(toGroupId).push($('.newsList li').last().prop(\"outerHTML\")); &#125; // 4. 滚动条往底部移 $('.RightCont').scrollTop($('.RightCont')[0].scrollHeight );&#125; 好友列表处理12345678910111213141516sending: function(content, $sendLi) &#123; // 设置部分新消息提醒 if (content.length &gt; 8) &#123; content = content.substring(0, 8) + \"...\"; &#125; $('.conLeft').find('li.bg').children('.liRight').children('.infor').text(content); // 如果存在新消息提醒徽章，则去除徽章 if ($sendLi.find('.layui-badge').length &gt; 0) &#123; $sendLi.find('.layui-badge').remove(); &#125; //$('.conLeft ul').prepend('&lt;li class=\"bg\"&gt;' + $sendLi.html() + '&lt;/li&gt;'); // 好友框新消息置顶 $('.conLeft ul').prepend($sendLi.prop(\"outerHTML\")); $sendLi.remove(); $('.conLeft ul li').first().on('click', friendLiClickEvent)&#125; 服务器处理12345678910111213141516171819202122@Overridepublic void singleSend(JSONObject param, ChannelHandlerContext ctx) &#123; String fromUserId = String.valueOf(param.get(\"fromUserId\")); String toUserId = (String)param.get(\"toUserId\"); String content = (String)param.get(\"content\"); // 取得接收者的通道 ChannelHandlerContext toUserCtx = Constant.onlineUserMap.get(toUserId); if (toUserCtx == null) &#123; String responseJson = new ResponseJson() .error(MessageFormat.format(\"userId为 &#123;0&#125; 的用户没有登录！\", toUserId)) .toString(); sendMessage(ctx, responseJson); &#125; else &#123; String responseJson = new ResponseJson().success() .setData(\"fromUserId\", fromUserId) .setData(\"content\", content) .setData(\"type\", ChatType.SINGLE_SENDING) .toString(); // 发送消息给接收者的通道，浏览器 socket 监听处理 sendMessage(toUserCtx, responseJson); &#125;&#125; 测试 通过控制台调试可以取得 sentMessageMap 中保存了与 userId=2 的用户的聊天信息数组。 通过控制台调试可以取得 sentMessageMap 中保存了与 userId=1 的用户的聊天信息数组。 群组聊天群组聊天的流程与用户单聊流程基本相似，只是在给接收者的通道发送消息时需要通过群组信息取得群组里的成员的信息，并获取成员的所有通道进行消息的遍发送。 1234567891011121314151617181920212223242526272829303132333435363738@Overridepublic void groupSend(JSONObject param, ChannelHandlerContext ctx) &#123; String fromUserId = String.valueOf(param.get(\"fromUserId\")); String toGroupId = (String)param.get(\"toGroupId\"); String content = (String)param.get(\"content\"); Chatgroup chatgroup = groupDao.getByGroupId(toGroupId); if (chatgroup == null) &#123; String responseJson = new ResponseJson().error(\"该群id不存在\").toString(); sendMessage(ctx, responseJson); &#125; else &#123; List&lt;String&gt; groupUsersId = userChatRelationDao.getUsersIdByGroupId(toGroupId); List&lt;User&gt; groupUser = new ArrayList&lt;User&gt;(); for(String groupUserId : groupUsersId)&#123; groupUser.add(userDao.getByUserId(groupUserId)); &#125; GroupInfo groupInfo = new GroupInfo( chatgroup.getGroupId(), chatgroup.getGroupName(), chatgroup.getGroupAvatarUrl(), groupUser ); String responseJson = new ResponseJson().success() .setData(\"fromUserId\", fromUserId) .setData(\"content\", content) .setData(\"toGroupId\", toGroupId) .setData(\"type\", ChatType.GROUP_SENDING) .toString(); groupInfo.getMembers() .forEach(member -&gt; &#123; ChannelHandlerContext toCtx = Constant.onlineUserMap.get(String.valueOf(member.getUserId())); if (toCtx != null &amp;&amp; !String.valueOf(member.getUserId()).equals(fromUserId)) &#123; sendMessage(toCtx, responseJson); &#125; &#125;); &#125;&#125; 接收消息者则根据 groupId 来显示接收到的消息。 1234567891011121314151617181920212223242526272829303132groupReceive: function(data) &#123; // 获取、构造参数 console.log(data); var fromUserId = data.fromUserId; var content = data.content; var toGroupId = data.toGroupId; var fromAvatarUrl; var $receiveLi; $('.conLeft').find('span.hidden-userId').each(function()&#123; if (this.innerHTML == fromUserId) &#123; fromAvatarUrl = $(this).parent(\".liRight\") .siblings(\".liLeft\").children('img').attr(\"src\"); /* $receiveLi = $(this).parent(\".liRight\").parent(\"li\"); */ &#125; &#125;) $('.conLeft').find('span.hidden-groupId').each(function()&#123; // 群组聊天框 if (this.innerHTML == toGroupId) &#123; $receiveLi = $(this).parent(\".liRight\").parent(\"li\"); &#125; &#125;) var answer=''; answer += '&lt;li&gt;' + '&lt;div class=\"answers\"&gt;'+ content +'&lt;/div&gt;' + '&lt;div class=\"answerHead\"&gt;&lt;img src=\"' + fromAvatarUrl + '\"/&gt;&lt;/div&gt;' + '&lt;/li&gt;'; // 消息框处理 processMsgBox.receiveGroupMsg(answer, toGroupId); // 好友列表处理 processFriendList.receiving(content, $receiveLi);&#125;, 发送表情表情的发送的底层原理和发送文字是一样的，只是发送表情的话，发送内容是一串静态资源的 URI。 表情模块绑定的监听事件： 1234567$('.ExP').on('mouseenter',function()&#123; $('.emjon').show();&#125;)$('.emjon').on('mouseleave',function()&#123; $('.emjon').hide();&#125;) 发送文件文件的上传使用的是 commons-fileupload 工具类。 123456&lt;!-- 文件上传 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.3&lt;/version&gt;&lt;/dependency&gt; 文件上传的模态框表格： 123456789101112&lt;div class=\"modal-body\"&gt; &lt;form class=\"form-horizontal\"&gt; &lt;div class=\"form-group\"&gt; &lt;label class=\"col-sm-3 control-label\"&gt;选择文件&lt;/label&gt; &lt;div class=\"col-sm-9\"&gt; &lt;input type=\"file\" name=\"file\" class=\"col-sm-9 myfile\" /&gt; &lt;p class=\"help-block\"&gt;注意：文件大小不超过30M，有效期为7天&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt;&lt;/div&gt; Bootstrap 的文件上传控件 bootstrap-fileinput 的使用： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778$(\".myfile\").fileinput(&#123; uploadUrl:\"chatroom/upload\", uploadAsync : true, // 默认异步上传 showUpload : true, // 是否显示上传按钮 showRemove : false, // 显示移除按钮 showCaption : false, // 是否显示标题 showPreview : true, // 是否显示预览，默认为 true dropZoneTitle: \"请通过拖拽图片文件放到这里\", dropZoneEnabled : false, // 是否显示拖拽区域，默认不写为 true，但是会占用很大区域 maxFileSize: 30720, // 单位为 kb，如果为 0 表示不限制文件大小 maxFileCount : 1, // 表示允许同时上传的最大文件个数 enctype : 'multipart/form-data', validateInitialCount : true, previewFileIcon : \"&lt;i class='glyphicon glyphicon-file'&gt;&lt;/i&gt;\", msgFilesTooMany : \"选择上传的文件数量(&#123;n&#125;) 超过允许的最大数值&#123;m&#125;！\", language : 'zh'&#125;)// 异步上传返回文件上传错误结果处理$('.myfile').on('fileerror', function(event, data, msg) &#123; console.log(\"fileerror\"); console.log(data);&#125;);// 异步上传返回结果处理$(\".myfile\").on(\"fileuploaded\", function(event, data, previewId, index) &#123; // 1. 上传成功1.5秒后自动关闭上传模态框 console.log(\"fileuploaded\"); setTimeout(function() &#123; $('#upload-cancel').trigger('click'); $('.fileinput-remove').trigger('click'); &#125;, 1500); // 2. 获取、设置参数 var returnData = data.response.data; var originalFilename = returnData.originalFilename; var fileSize = returnData.fileSize; var fileUrl = returnData.fileUrl; var content = \"[文件]\"; var fromUserId = userId; var avatarUrl = $('#avatarUrl').attr(\"src\"); var $sendLi = $('.conLeft').find('li.bg'); var toUserId = $('#toUserId').val(); var toGroupId = $('#toGroupId').val(); // 拼接发送者对话框的消息 var fileHtml = '&lt;li&gt;'+ '&lt;div class=\"send-file-shown\"&gt;' + '&lt;div class=\"media\"&gt;' + '&lt;a href=\"' + fileUrl + '\" class=\"media-left\"&gt;' + '&lt;i class=\"glyphicon glyphicon-file\" style=\"font-size:28pt;\"&gt;&lt;/i&gt;' + '&lt;/a&gt;' + '&lt;div class=\"media-body\"&gt; ' + '&lt;h5 class=\"media-heading\"&gt;' + originalFilename + '&lt;/h5&gt;' + '&lt;span&gt;'+ fileSize + '&lt;/span&gt;' + '&lt;/div&gt;' + '&lt;/div&gt;'+ '&lt;/div&gt;' + '&lt;div class=\"nesHead\"&gt;&lt;img src=\"' + avatarUrl + '\"/&gt;&lt;/div&gt;' + '&lt;/li&gt;'; // 3. 发送信息到服务器 if (toUserId.length != 0) &#123; ws.fileMsgSingleSend(fromUserId, toUserId, originalFilename, fileUrl, fileSize); &#125; else &#123; ws.fileMsgGroupSend(fromUserId, toGroupId, originalFilename, fileUrl, fileSize); &#125; // 4. 消息框处理： processMsgBox.sendFileMsg(fileHtml, toUserId, toGroupId); // 5. 好友列表处理 processFriendList.sending(content, $sendLi);&#125;);//上传前$('.myfile').on('filepreupload', function(event, data, previewId, index) &#123; console.log(\"filepreupload\");&#125;); 文件上传的控制器： 123456@RequestMapping(value = \"/upload\", method = POST)@ResponseBody public ResponseJson upload( @RequestParam(value = \"file\", required = true) MultipartFile file, HttpServletRequest request) &#123; return fileUploadService.upload(file, request);&#125; 文件上传的业务逻辑处理： 123456789101112131415161718192021222324252627282930313233343536373839public class FileUploadServiceImpl implements FileUploadService &#123; // 项目的打包目录，本项目打包在根目录下 private final static String SERVER_URL_PREFIX = \"http://localhost:8080/\"; // 保存上传文件的文件夹名称 private final static String FILE_STORE_PATH = \"UploadFile\"; @Override public ResponseJson upload(MultipartFile file, HttpServletRequest request) &#123; // 重命名文件，防止重名 String filename = getRandomUUID(); String suffix = \"\"; String originalFilename = file.getOriginalFilename(); String fileSize = FileUtils.getFormatSize(file.getSize()); // 截取文件的后缀名 if (originalFilename.contains(\".\")) &#123; suffix = originalFilename.substring(originalFilename.lastIndexOf(\".\")); &#125; filename = filename + suffix; // getRealPath(“/”) 获取实际路径,“/”指代项目根目录,所以代码返回的是项目在容器中的实际发布运行的根路径 String prefix = request.getSession().getServletContext().getRealPath(\"/\") + FILE_STORE_PATH; System.out.println(\"存储路径为:\" + prefix + \"\\\\\" + filename); Path filePath = Paths.get(prefix, filename); try &#123; Files.copy(file.getInputStream(), filePath); &#125; catch (IOException e) &#123; e.printStackTrace(); return new ResponseJson().error(\"文件上传发生错误！\"); &#125; return new ResponseJson().success() .setData(\"originalFilename\", originalFilename) .setData(\"fileSize\", fileSize) .setData(\"fileUrl\", SERVER_URL_PREFIX + FILE_STORE_PATH + \"\\\\\" + filename); &#125; private String getRandomUUID() &#123; return UUID.randomUUID().toString().replace(\"-\", \"\"); &#125;&#125; WebSoclet 处理文件发送方法： 123456789101112131415161718192021222324public void FileMsgSingleSend(JSONObject param, ChannelHandlerContext ctx) &#123; String fromUserId = String.valueOf(param.get(\"fromUserId\")); String toUserId = (String)param.get(\"toUserId\"); String originalFilename = (String)param.get(\"originalFilename\"); String fileSize = (String)param.get(\"fileSize\"); String fileUrl = (String)param.get(\"fileUrl\"); ChannelHandlerContext toUserCtx = Constant.onlineUserMap.get(toUserId); if (toUserCtx == null) &#123; String responseJson = new ResponseJson() .error(MessageFormat.format(\"userId为 &#123;0&#125; 的用户没有登录！\", toUserId)) .toString(); sendMessage(ctx, responseJson); &#125; else &#123; String responseJson = new ResponseJson().success() .setData(\"fromUserId\", fromUserId) .setData(\"originalFilename\", originalFilename) .setData(\"fileSize\", fileSize) .setData(\"fileUrl\", fileUrl) .setData(\"type\", ChatType.FILE_MSG_SINGLE_SENDING) .toString(); sendMessage(toUserCtx, responseJson); &#125;&#125;// 群发文件则与群组聊天类似，取群组中的用户的通道遍历发送文件信息 接收者对话框接收文件消息的拼接： 1234567891011121314151617181920212223242526272829303132333435363738fileMsgSingleRecieve: function(data) &#123; // 获取、构造参数 console.log(data); var fromUserId = data.fromUserId; var originalFilename = data.originalFilename; var fileSize = data.fileSize; var fileUrl = data.fileUrl; var content = \"[文件]\"; var fromAvatarUrl; var $receiveLi; $('.conLeft').find('span.hidden-userId').each(function()&#123; if (this.innerHTML == fromUserId) &#123; fromAvatarUrl = $(this).parent(\".liRight\") .siblings(\".liLeft\").children('img').attr(\"src\"); $receiveLi = $(this).parent(\".liRight\").parent(\"li\"); &#125; &#125;) var fileHtml = '&lt;li&gt;'+ '&lt;div class=\"receive-file-shown\"&gt;' + '&lt;div class=\"media\"&gt;' + '&lt;div class=\"media-body\"&gt; ' + '&lt;h5 class=\"media-heading\"&gt;' + originalFilename + '&lt;/h5&gt;' + '&lt;span&gt;'+ fileSize + '&lt;/span&gt;' + '&lt;/div&gt;' + '&lt;a href=\"' + fileUrl + '\" class=\"media-right\"&gt;' + '&lt;i class=\"glyphicon glyphicon-file\" style=\"font-size:28pt;\"&gt;&lt;/i&gt;' + '&lt;/a&gt;' + '&lt;/div&gt;'+ '&lt;/div&gt;' + '&lt;div class=\"answerHead\"&gt;&lt;img src=\"' + fromAvatarUrl + '\"/&gt;&lt;/div&gt;' + '&lt;/li&gt;'; // 消息框处理 processMsgBox.receiveSingleMsg(fileHtml, fromUserId); // 好友列表处理 processFriendList.receiving(content, $receiveLi);&#125;,","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"}],"tags":[{"name":"Chatroom","slug":"Chatroom","permalink":"http://yoursite.com/tags/Chatroom/"}]},{"title":"Chatroom Mybatis","slug":"Chatroom/Chatroom Mybatis","date":"2020-02-22T03:26:36.000Z","updated":"2020-04-19T06:24:14.533Z","comments":true,"path":"2020/02/22/Chatroom/Chatroom Mybatis/","link":"","permalink":"http://yoursite.com/2020/02/22/Chatroom/Chatroom%20Mybatis/","excerpt":"Mybatis 的初步整合与测试","text":"Mybatis 的初步整合与测试 项目目录 Model： po/User.java 用户实体 Dao UserDao.java 用户数据访问对象 Service UserService.java 用户业务逻辑 UserServiceImpl.java Xml UserMapper.xml 持久层 / 对象关系映射文件 ApplicationContext-dao.xml ApplicationContext-service.xml MybatisConfig.xml pom.xml Properties jdbc.properties 数据库配置文件 项目搭建pom.xml 添加 Mybatis 相关依赖包 12345678910111213141516171819202122232425&lt;!-- MySQL --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!-- c3p0 连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt;&lt;/dependency&gt; 数据库的建立 123456CREATE TABLE `user` ( `user_id` int(11) NOT NULL AUTO_INCREMENT, `user_name` varchar(64) DEFAULT NULL, `password` varchar(64) DEFAULT NULL, PRIMARY KEY (`user_id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 用户实体类 123456789101112131415161718192021222324252627282930313233343536373839public class User &#123; private Long userId; private String userName; private String password; public Long getUserId() &#123; return userId; &#125; public void setUserId(Long userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; @Override public String toString() &#123; return \"User&#123;\" + \"userId='\" + userId + '/'' + \", username='\" + userName + '/'' + \", password='\" + password + '/'' + '&#125;'; &#125;&#125; 数据访问类 1234567public interface UserDao &#123; // 保存用户信息 void saveUser(User user); // 通过 id 取得用户信息 User queryById(long user);&#125; 对象 / 持久层映射文件 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"wingo.dao.UserDao\"&gt; &lt;insert id=\"saveUser\" parameterType=\"wingo.model.po.User\" useGeneratedKeys=\"true\" keyProperty=\"userId\"&gt; INSERT INTO user (user_name,password) VALUES (#&#123;userName&#125;,#&#123;password&#125;) &lt;/insert&gt; &lt;select id=\"queryById\" parameterType=\"long\" resultType=\"wingo.model.po.User\" &gt; &lt;!-- 具体的sql --&gt; SELECT user_id,user_name,password FROM user WHERE user_id = #&#123;userId&#125; &lt;/select&gt;&lt;/mapper&gt; 业务逻辑类 12345public interface UserService &#123; void saveUser(User user); User queryById(long userId);&#125; 业务逻辑类的实现 123456789101112131415public class UserServiceImpl implements UserService &#123; private Logger logger= LoggerFactory.getLogger(this.getClass()); @Autowired private UserDao userDao; public void saveUser(User user) &#123; userDao.saveUser(user); &#125; public User queryById(long userId) &#123; return userDao.queryById(userId); &#125;&#125; 数据库信息配置 jdbc.properties 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://127.0.0.1:3306/nettychatroom?useUnicode=true&amp;characterEncoding=utf8jdbc.username=rootjdbc.password= 123456 Mybatis 配置 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;!-- 配置全局属性 --&gt; &lt;settings&gt; &lt;!-- 使用jdbc的getGeneratedKeys获取数据库自增主键值 --&gt; &lt;setting name=\"useGeneratedKeys\" value=\"true\" /&gt; &lt;!-- 使用列别名替换列名 默认:true --&gt; &lt;setting name=\"useColumnLabel\" value=\"true\" /&gt; &lt;!-- 开启驼峰命名转换:Table&#123;create_time&#125; -&gt; Entity&#123;createTime&#125; --&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\" /&gt; &lt;!-- 开启控制台打印 SQL 语句 --&gt; &lt;setting name=\"logImpl\" value=\"STDOUT_LOGGING\" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 数据访问层上下文配置 ApplicationContext-dao.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 配置整合mybatis过程 --&gt; &lt;!-- 1.配置数据库相关参数properties的属性：$&#123;url&#125; --&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;!-- 2.数据库连接池 --&gt; &lt;bean id=\"dataSource\" class=\"com.mchange.v2.c3p0.ComboPooledDataSource\"&gt; &lt;!-- 配置连接池属性 --&gt; &lt;property name=\"driverClass\" value=\"$&#123;jdbc.driver&#125;\" /&gt; &lt;property name=\"jdbcUrl\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"user\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;!-- c3p0连接池的私有属性 --&gt; &lt;property name=\"maxPoolSize\" value=\"30\" /&gt; &lt;property name=\"minPoolSize\" value=\"10\" /&gt; &lt;!-- 关闭连接后不自动commit --&gt; &lt;property name=\"autoCommitOnClose\" value=\"false\" /&gt; &lt;!-- 获取连接超时时间 --&gt; &lt;property name=\"checkoutTimeout\" value=\"10000\" /&gt; &lt;!-- 当获取连接失败重试次数 --&gt; &lt;property name=\"acquireRetryAttempts\" value=\"2\" /&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name=\"configLocation\" value=\"classpath:MybatisConfig.xml\" /&gt; &lt;!-- 扫描entity包，使用别名 --&gt; &lt;property name=\"typeAliasesPackage\" value=\"wingo.dao\" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mapper/*.xml\" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name=\"sqlSessionFactoryBeanName\" value=\"sqlSessionFactory\" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name=\"basePackage\" value=\"wingo.dao\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 业务逻辑层上下文配置 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package=\"wingo.service\"/&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven/&gt;&lt;/beans&gt; Junit 4 测试Junit 4 整合引入依赖 1234567&lt;!-- Junit --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;&lt;/dependency&gt; 测试基类 123456789@RunWith(SpringJUnit4ClassRunner.class) //使用junit4进行测试@ContextConfiguration(locations=&#123; \"classpath:spring/ApplicationContext-dao.xml\", \"classpath:spring/ApplicationContext-service.xml\"&#125;) //加载配置文件public class BaseJunit4Test &#123;&#125; 测试类 12345678910111213141516171819202122public class UserTest extends BaseJunit4Test&#123; @Autowired private UserService userService; @Test @Transactional //标明此方法需使用事务 @Rollback(false) //标明使用完此方法后事务不回滚,true时为回滚 public void test()&#123; System.out.println(\"测试Spring整合Junit4进行单元测试\"); // User user = new User(); // user.setUserName(\"test1\"); // user.setPassword(\"111\"); // userService.saveUser(user); User user = userService.queryById(1); System.out.println(user.toString()); &#125;&#125; 测试结果","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"}],"tags":[{"name":"Chatroom","slug":"Chatroom","permalink":"http://yoursite.com/tags/Chatroom/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Chatroom SpringMVC","slug":"Chatroom/Chatroom SpringMVC","date":"2020-02-22T01:46:26.000Z","updated":"2020-04-19T06:25:11.120Z","comments":true,"path":"2020/02/22/Chatroom/Chatroom SpringMVC/","link":"","permalink":"http://yoursite.com/2020/02/22/Chatroom/Chatroom%20SpringMVC/","excerpt":"Chatroom 的 SpringMVC 的整合与测试。","text":"Chatroom 的 SpringMVC 的整合与测试。 项目结构 View： longin.html 用户登录页面 chatroom.html 聊天室页面 Controller UserController.java LoginController.java Xml ApplicationContext-mvc.xml web.xml pom.xml 项目搭建pom.xml 添加 Spring 全家桶依赖。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; web.xml 中将请求交给 SpringMVC 处理 12345678910111213141516&lt;!-- 前端控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet &lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/ApplicationContext-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 对 SpringMVC 进行配置 12345678910111213141516171819202122232425262728293031323334&lt;!-- MVC 负责扫描 Controller --&gt;&lt;context:component-scan base-package=\"wingo.web.controller\"/&gt;&lt;!-- 启动 Spring MVC 的注解功能，完成请求和注解POJO的映射,解决 @ResponseBody 乱码问题 --&gt;&lt;!-- 需要在 annotation-driven 之前,否则乱码问题同样无法解决 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启 MVC 的注解式配置 --&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 视图解释类 --&gt;&lt;bean name=\"viewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/views/\" /&gt; &lt;property name=\"suffix\" value=\".html\" /&gt; &lt;property name=\"order\" value=\"0\" /&gt;&lt;/bean&gt;&lt;!-- 设置不拦截静态文件 --&gt;&lt;mvc:resources location=\"/WEB-INF/views/\" mapping=\"/WEB-INF/views/**\" /&gt;&lt;mvc:resources location=\"/static/\" mapping=\"/static/**/**\" /&gt;&lt;mvc:resources location=\"/UploadFile/\" mapping=\"/UploadFile/**\" /&gt; 编写控制器方法 12345678@Controllerpublic class UserController &#123; // 跳转到登陆页面 @RequestMapping(value = &#123;\"login\", \"/\"&#125;, method = RequestMethod.GET) public String toLogin() &#123; return \"login\"; &#125;&#125; 1234567public class ChatroomController &#123; // 登录成功后的跳转页面 @RequestMapping(method = RequestMethod.GET) public String toChatroom() &#123; return \"chatroom\"; &#125;&#125; 项目测试控制台输出 @RequestMapping(value = {&quot;login&quot;, &quot;/&quot;}, method = RequestMethod.GET) 整合 SwaggerSwagger 是一款 RESTFUL 接口的文档在线自动生成 + 功能测试功能软件。 @Api ：修饰整个类，描述Controller的作用；@ApiOperation ：描述一个类的一个方法，或者说一个接口；@ApiParam ：单个参数描述；用在方法参数上@ApiModel ：用对象来接收参数；@ApiProperty ：用对象接收参数时，描述对象的一个字段；@ApiResponse ：HTTP响应其中1个描述；@ApiResponses ：HTTP响应整体描述；@ApiIgnore ：使用该注解忽略这个API；@ApiError ：发生错误返回的信息；@ApiImplicitParam ：一个请求参数：用在方法上 。@ApiImplicitParams ：多个请求参数：用在方法上。 引入依赖包 123456789101112131415161718192021222324252627282930313233&lt;!-- Swagger 可帮助开发人员设计，构建，记录和使用 RESTful Web 服务 --&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- Jackson 包，配合 Spring @ResponseBody 注解，以及 Json 工具包 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.6&lt;/version&gt;&lt;/dependency&gt; 配置 Swagger 1234567891011121314151617181920212223@EnableSwagger2 //使 Swagger2 生效@ComponentScan(basePackages = &#123;\"wingo.web.controller\"&#125;) //需要扫描的controller包路径@Configurable //配置注解，自动在本类上下文加载一些环境变量信息public class SwaggerConfig extends WebMvcConfigurationSupport &#123; //RestApiConfig @Bean public Docket buildDocket()&#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(buildApiInf()) .select() .apis(RequestHandlerSelectors.basePackage(\"wingo.web.controller\"))//controller路径 .paths(PathSelectors.any()) .build(); &#125; private ApiInfo buildApiInf()&#123; return new ApiInfoBuilder() .title(\"Wingo's Swagger\") .description(\"Web Restful 测试\") .build(); &#125;&#125; Spring 加载 SwaggerConfig 123456&lt;!-- 加载 SwaggerConfig --&gt;&lt;bean class=\"springfox.documentation.swagger2.configuration.Swagger2DocumentationConfiguration\" id=\"swagger2Config\"/&gt;&lt;!-- 不拦截所需静态文件 --&gt;&lt;mvc:resources mapping=\"swagger-ui.html\" location=\"classpath:/META-INF/resources/\"/&gt;&lt;mvc:resources mapping=\"/webjars/**\" location=\"classpath:/META-INF/resources/webjars/\"/&gt; 在需要标注的控制器类方法上添加注解 123456789101112131415161718192021@Controller@RequestMapping(value=\"/swagger\")public class TestSwaggerController &#123; @ApiOperation(value = \"测试专用\", notes = \"返回一个 JSON 字符串\") @RequestMapping(value=\"/test\",method= RequestMethod.GET) @ResponseBody public String test()&#123; ObjectMapper mapper = new ObjectMapper(); User user = new User(); user.setUserId((long) 1); user.setUserName(\"中文测试\"); user.setPassword(\"111\"); String str = null; try &#123; str = mapper.writeValueAsString(user); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return str; &#125;&#125; 访问：[项目根目录]/swagger-ui.html 点击 Try it out 进行请求的发送。 成功请求并的到响应。","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"}],"tags":[{"name":"Chatroom","slug":"Chatroom","permalink":"http://yoursite.com/tags/Chatroom/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"}]},{"title":"Java 基础知识回顾","slug":"Welab/Java 基础知识回顾","date":"2020-02-19T13:17:04.000Z","updated":"2020-03-02T06:55:23.277Z","comments":true,"path":"2020/02/19/Welab/Java 基础知识回顾/","link":"","permalink":"http://yoursite.com/2020/02/19/Welab/Java%20%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/","excerpt":"","text":"入门基础Block123456789public class Block &#123; // 块（block）开始 public static void main(String[] args) &#123; // 块（block）是指括在一对 &#123;&#125; 里的部分，关键字之间的多个空格“ “视作一个 System.out.println(\"Block Example!\"); // 一条命令以分号结束 &#125; // 块（block）结束 &#125; 注释1234567891011121314151617/** * @Title: Annotate.java * @Description: [Java语言的基本语法 - 注释] 这里是 javadoc 注释，生成 API 文档时使用，注释在编译时会被忽略 * * @author Wingo */public class Annotate &#123; /* * 这里是多行注释 */ public static void main(String[] args) &#123; System.out.println(\"Annotate Example!\"); // 这里是单行注释 &#125; &#125; 标识符Java 里的标识符只能是大/小写字母、数字、美元符号、下划线及上述组合，且不能以数字开头，不能为 Java 关键字，最大长度为 65534 个字符。 变量与常量Java 中类名以大写字母开头，变量和方法名以小写字母开头，一般采用驼峰命名的规则。虽然不是强制要求，但是强烈建议遵守规范。 12int number = 1; // 这里 number 是变量，1 是常量，此语句将常量 1 赋值给变量 numberboolean tureOrFalse = ture // 这里 trueOrFalse 是变量，ture 是常量 数据类型Java 里的数据类型分为基本数据类型（Primitive Type）和对象数据类型（Object Type）。 基本数据类型 基本数据类型分为： 逻辑型（Logical，也称为布尔型，1 个字节）；👉 true / false 字符型（Textual）； 👉 Java 使用字符型（char）存储单个字符，占2个字节内存。使用 Unicode 字符集处理文字，Unicode 使用 2 个字节表示一个字符，几乎可以处理所有国家的语言文字。 注意：Java 中，字符型属于基本数据类型，而字符串是对象数据类型。因此，像 char a = “A”; 是错误的，因为 “A” 不是字符类型，而是一个字符串对象（String 类型），char a = ‘A’; 才是正确的赋值形式。 整型（Integral）；👉 long 型 L / l 不能省 byte short int long 1 字节 2 字节 4 字节 8 字节 -128～127 实数类型（Floating，也称为浮点数）。👉 float 型 f 不能省 float double 4 字节 8 字节 进制的表示1234// 不同进制的表示形式int num1 = 12; // 十进制（0、1、2、3、4、5、6、7、8、9，逢十进一位）int num2 = 012; // 八进制（0、1、2、3、4、5、6、7，逢八进一位）int num3 = 0x12 // 十六进制（0、1、2、3、4、5、6、7、8、9、A、B、C、D、E、F、G，逢十六进一位） 进制的转换 数值 操作 num = 5; n = 2; str = “”; 5 ÷ 2 = 2…..1 进入递归 num = 2; n = 2; str = “?1”; 层次一 2 ÷ 2 = 1……0 进入递归 num = 1 ; n = 2; str = “?0”; 层次二 num &lt; n 触发递归终止返回 num 对应字符 str = “1”; 层次三，即 ? = 1; 返回第二层 str = “10”; 返回第第一层 str = “101”; return “101”; 12345678910111213141516171819202122232425// 进制的转换 API: Integer.toBinaryString();public class ConvertTo &#123; // 初始化用于拼接的字符 private static char[] a = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'&#125;; public static void main(String[] args) &#123; int number = 20; System.out.println(number + \" 转二进制: \" + toNumber(number, 2)); System.out.println(number + \" 转八进制: \" + toNumber(number, 8)); System.out.println(number + \" 转十六进制: \" + toNumber(number, 16)); &#125; public static String toNumber(int number, int n) &#123; String str = \"\"; for (int i = 0; i &lt; n; i++) &#123; // 商 &lt; 进制数直接取商 if (number == i) &#123; // 用对应的字符进行拼接 str = a[i] + str; return str; &#125; &#125; str = a[number % n] + str; // 商 &gt;= 进制数的取余数 str = toNumber(number / n, n) + str; // 传递商进行递归的 return str; &#125;&#125; 对象数据类型String 对象与基本数据类型的数据可以进行 ”+” 运算，其结果值为一个 String 型的对象，即”字符串+整数（实数）=字符串”。 类型的转换自动类型转换从低位类型到高位类型自动转换。 float 型是比 long 型更大的数据类型，long 型数据占用 8 个字节的内存空间，float 型数据仅占用 4 个字节的内存空间。但是，由于 long 型无法展示小数（float 型变量则可以），所以我们将 float 型看作是比 long 型更大的数据类型。 变量 变量 结果 变量 变量 结果 byte byte int byte short int byte int int short int int int int int int long long long long long byte float float int float float long float float double float double double double double 12byte a = 7;byte b = -a; // -c 运算后的结果是整型，再赋值给 byte （字节型）变量，显然是错误的 强制类型转换(高位类型) 低位类型 编写程序是要时刻留心数据类型的转换，机器的执行跟人的思维习惯某些时候存在差异。 运算符运算符优先级（由高到低）： () 👉 单目运算符（!、~、+、-、++、–）👉 算术运算符（+、-、*、/、%）👉 位移运算符（&lt;&gt;、&gt;&gt;&gt;）👉 关系元算符（&gt;、=、&lt;=、==、!=）👉 逻辑元算符（&amp;&amp;、||、&amp;、|、^）👉 三目运算符（b?x:y;）👉 赋值运算符（=、+=、-=、*=、/=、%=、&amp;=、|=、^=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=）。 逻辑非运算符 ! 是表示逻辑非的单目运算符，它把真（true）变为假（false），把假（false）变为真（true）。 位非运算符 ～ 是表示位非的单目运算符，它的运算规则是：逢 1 变 0，逢 0 变 1。 符号运算符 +、- 分别用于表示正数和负数。 增减运算符 ++、– 是使变量值增 1 或减 1 的单目运算符。 ++a; 前置递增运算符，先运算后赋值。 a++; 后置递增运算符，先赋值后运算。 快速逻辑与（&amp;&amp;）、快速逻辑或（||）称为短路运算符 A&amp;&amp;B：若 A 为 false，则整个表达式即为假，此时 B 将不会参与运算，因此将出现 false 概率最高的表达式放到前面是推荐的做法；A||B：若 A 为 true，则整个表达式为真，此时 B 将不会参与运算，因此将出现 true 概率最高的表达式放到前面是推荐的做法。 &amp;：作位与运算 |：作位或运算 ^：作位异或运算 三目运算符格式：条件式 ? 值1 : 值2; 如果条件表达式为真，则表达式的值取值 1，否则取值 2。 a += 1; 👉 a = a + 1; a-=1; 👉 a = a-1; 对象运算符 instanceof 结果值为 boolean 型，A instanceof B：如果 A 是 B 的对象，则返回 true，否则，返回 false。 流程控制语句条件语句（if、switch）针对某种条件进行某种处理 循环语句（for、while、do-while）重复执行某一段代码 异常处理语句（try-catch-finally）处理程序发生的异常 If 语句注意：多分支 if 语句，永远只执行其中一条或一条也不执行。建议把触发条件概率较高的条件放到更前面执行。 Java 中 else if 语句中间是隔开的，但是在 JavaScript 脚本语言中， elseif 是连在一起的，这点需要留意一下. 12345678910111213141516171819202122// 形式一 ifif() &#123; //&#125;// 形式二 if_elseif() &#123; //&#125; else() &#123; //&#125;// 形式三 if_else if_elseif() &#123; //&#125; if else() &#123; //&#125; if else() &#123; //&#125; else() &#123; //&#125; switch 语句switch 语句也是一种条件语句，表达式的结果必须是整型数字（byte/Byte、short/Short、int/Integer）、字符（char/Character，本质上也是数字，字母或中文都是可以的）、枚举（Enum）等形式，JDK1.7 之后支持 String 类型。 break 语句在 switch 语句中，用于终止一种情形；在循环语句中，用于强制退出循环。continue 语句为跳出本次循环，继续执行下一次循环，注意 break 与 continue 的差异。 12345678910111213141516171819202122switch(expression) &#123; case value_one: // 若 expresion == value_one 👉 do_one、do_two、...、do_default do_one; case vlaue_two: // 若 expresion == value_two 👉 do_two、...、do_default do_two; // ... dafault: do_default; // 若 expression 没有匹配的 value 👉 do_default&#125;// 添加加 break 语句强制退出循环switch(expression) &#123; case value_one: // 若 expresion == value_one 👉 do_one do_one; break; case vlaue_two: // 若 expresion == value_two 👉 do_two do_two; break; // ... dafault: do_default; // 若 expression 没有匹配的 value 👉 do_default&#125; for 语句for 语句是一种循环语句，它在某种条件满足时，反复执行某些语句。for 循环语句可以嵌套，嵌套后就是多重循环语句。 for 语句中，若条件表达式始终为真，则会出现死循环的情况。编程时，一定要考虑周全，防止程序陷入死循环中。 123456789public class ForBrief &#123; public static void main(String[] args) &#123; int a = 1; for (; a &lt;= 5;) &#123; // 只有判断条件 System.out.print(a + \" \"); a++; &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334// 多个表达式for (int a = 1, b = 1; (a + b) &lt;= 10; a++, b++) &#123; System.out.print((a + b) + \" \");&#125;// break 语句for (int i = 1; true; i++) &#123; if (i == 6) &#123; break; // 若 i 为 6，则退出 for 循环 &#125; System.out.print(i + \" \");&#125;// continue 语句for (int i = 1; i &lt;= 10; i++) &#123; if (i &lt;= 5) continue; // 跳过此次循环进行下一次循环 System.out.print(i + \" \");&#125;// 多重循环for (int a = 1; a &lt;= 2; a++) &#123; for (int b = 1; b &lt;= 3; b++) &#123; System.out.println(\"a=\" + a + \" b=\" + b); &#125;&#125;// 标签的使用outer: for (int a = 1; a &lt;= 3; a++) &#123; for (int b = 1; b &lt;= 2; b++) &#123; if (a &lt;= 2) &#123; continue outer; &#125; System.out.println(a + \" \" + b); &#125; System.out.println(\"您好 \" + a);&#125; while 语句类似 for 循环语句，while 也是循环语句，也可以进行嵌套。 123456789101112131415// 九九乘法表public class While &#123; public static void main(String[] args) &#123; int a = 1, b; while (a &lt;= 9) &#123; b = 1; while (b &lt;= a) &#123; System.out.print(b + \"*\" + a + \"=\" + a * b + \" \"); b++; &#125; a++; System.out.println(); &#125; &#125;&#125; do-while 语句do-while 语句同 while 语句作用类似，但是它首先执行然后再判断条件表达式，与 while 循环语句的不同之处是 do-while 循环语句至少被执行一次。 123456789public class DoWhile &#123; public static void main(String[] args) &#123; int a = 1; do &#123; System.out.print(a + \" \"); a++; &#125; while (a &lt;= 3); &#125;&#125; 类与对象","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Base","slug":"Base","permalink":"http://yoursite.com/tags/Base/"}]},{"title":"Friends S01","slug":"English/Friends/Friends S01","date":"2020-02-19T03:46:03.000Z","updated":"2020-04-19T06:26:00.372Z","comments":true,"path":"2020/02/19/English/Friends/Friends S01/","link":"","permalink":"http://yoursite.com/2020/02/19/English/Friends/Friends%20S01/","excerpt":"","text":"Episode 01 ~ 05Episode 01 Come on, You’re going out with the guy! 👉 go out with &lt;俚&gt; 约会 So does he have a hump? A hump and a hairpiece? 👉 hump n. 驼背 hairpiece / false hair / wig n. 假发 Wait, does he eat chalk? 👉 chalk n. 粉笔 All of a sudden adv. 突然之间地 I just feel like someone reached down my throat, grabbed my small intestine, pulled it out of my mouth and tied it around my neck. 👉 intestine n. 肠 Stop cleansing my aura! 👉 aura: a distinctive atmosphere surrounding a given source n. 气氛 灵气 光环 👉 distinctive adj. 有特色的 与众不同的 To hell with her, she left me! 👉 to hell with &lt;口&gt; 让…见鬼去，去(她)该死的 Why does everyone keep fixating on that? 👉 fixate on: to focus one’s gaze or attention on sth 关注某事 I realized that I was more turned on by this gravy boat than by Barry! 👉 turn on &lt;俚&gt; if someone or something turns you on, that means they make you interested or excited sexually 👉 freak out &lt;俚&gt; means you suddenly behave in a very strange and uncontrolled way | drift apart: lose person contact over time v. 疏远 👉 hit &lt;口&gt; 使…想起 [It hit me all of a sudden that I had forgotten her birthday] gravy boat pipe organ 管风琴 lizard What if I wanna be a purse… It’s a metaphor. 👉 metaphor / analogy n. 隐喻 类比 Well, I guess we’ve established who’s staying here with Monica. 👉 establish v. 确定 建立 Okay, look, this is probably for the best, you know? 👉 be for the best 极其口语化的表达法，表示某件事情可能并不像看上去那么糟，也颇有点良药虽苦，其利于病的意思 Stop hitting on her! It’s her wedding day! 👉 hit on &lt;俚&gt; to pay unsolicited 主动提供的 and usually unwanted 不必要的 sexual attention to someone 👉 = flirt v. 调情 with someone / to make a pass at someone / to come on to someone Buzz him in 👉 make a signal using the buzzer to let him in Ooh, this is a Dear Diary moment! 👉 a Dear Diary moment 值得纪念的时刻 Ooh, I just pulled out four eyelashes. That can’t be good. 👉 eyelashes n. 睫毛 Well, I was kinda supposed to be headed for Aruba on my honeymoon, so nothing! 👉 be headed for v. 前往 I think I’m just gonna hang out here tonight. 👉 hang out here 呆在这儿（聊家常） I’m supposed to attach a bracket-y thing to the side things, using a bunch of these little worm guys. I have no bracket-y thing, I see no whom guys whatsoever and I cannot feel my legs. 👉 squat v. 蹲坐 bracket n. 支架 👉 bracket-y: means an L-shaped support projecting 突出的 from a wall (as to hold a shelf) 👉 whatsoever = whatever 语气比 whatever 强 👉 worm guys 指代螺丝钉，因为螺丝钉上的纹路与 worm 很相似 worm worm guy bracket-y stereo sock You got screwed. 👉 got screwed &lt;俚&gt; to cheat or deceive 欺诈 someone I should have caught on… 👉 catch on: Understand clearly / comprehend v. 理解 He is such a mess 👉 mess &lt;俚&gt; informal terms 非正式用语 for a difficult situation I went for the watch 👉 went for v. 攻击 尽力想求得 I said the other day about you making love with your socks on 👉 the other day adv. 前几天 Machine cut me off again 👉 cut off = disconnect = terminate = shut off There’s Rocky Road, and Cookie Dough, and Bing! Cherry Vanilla. You could get them with Jimmies, or nuts, or whipped cream! I honestly don’t know if I’m hungry or horny. 👉 horny &lt;俚&gt; feeling great sexual desire Ever since she walked out on me. 👉 walk out on = abandon = run out on 遗弃 抛弃 I know being spit on is probably not what you need right now. 👉 being spit on 被人唾弃 I’m glad you smashed her watch. 👉 smash v. 打碎 撞击 n. 撞车 扣球 十分走红的歌曲 While you’re on a roll, if you feel like you gotta make like a western omelet or something… 👉 on a roll &lt;俚&gt; undergoing or experiencing sustained, even increasing good fortune or success omelet I will not take this abuse. 👉 take abuse: recoil 畏缩 as to someone else’s language offense You look like you slept with a hanger in your mouth. 👉 hanger 衣架 I take credit for Paul. You know before me, there was no snap in his turtle for two years. 👉 take credit for &lt;俚&gt; if A takes credit for B, that means B is indebted 感激的 to A 👉 snap in his turtle &lt;俚&gt; sexual performance 👉 unable to have an erection / turtle &lt;俚&gt; a vulgar 庸俗的 expression to refer to male’s genitalia 生殖器 Of course it was a line! 👉 line &lt;俚&gt; glib 油腔滑调的 or insincere 不真诚的 talk, usually intended to deceive or impress I assume we’re looking for an answer more sophisticated than ‘to get you into bed’. 👉 sophisticated adj. 成熟稳重的 Is it like I have some sort of beacon that only dogs and men with severe emotional problems can hear? 👉 beacon n. 灯塔 信标(电)台 I’m trained for nothing! I was laughed out of twelve interviews today. And yet you’re surprisingly upbeat. 👉 and yet adv. 可是 upbeat adj. = cheerful optimistic You can’t live off your parents your whole life. 👉 live off v. 靠…生活 I ended up living with this albino guy who was like cleaning windshields outside port authority, and then he killed himself, and then I found aromatherapy. 👉 port authority 港务局 albino n. 白化病者 end up &lt;口&gt; means finally be or do something You gonna crash on the couch? 👉 crash &lt;俚&gt; to temporarily stay over or sleep at a place other than at one’s own usual abode 住处 I had a…major crush on you. 👉 If you are a crush on someone, you are in love with them but do not have a relationship with them. I always figured you just thought I was Monica’s geeky older brother. 👉 geeky &lt;俚&gt; 书呆子气的 令人讨厌的 Try not to let my intense vulnerability become any kind of a factor here. 👉 vulnerability n. 易受责难 弱点 intense vulnerability n. 强烈的脆弱感 Episode 02 I mean it’s like the stand-up comedian you have to sit through before Pink Floyd comes out. 👉 sit through 耐着性子看 / 听完 stand-up comedy 单口相声 stand-up comedian ~演员 Yeah, well, word of advice. 👉 word of advice 建议如下 glacier mastodon thighmaster Marty’s still totally paranoid. 👉 paranoid adj. 类似妄想狂的 Are you through with that? 👉 to have finished using or doing something See, I wrote a note to myself, and then I realised I didn’t need it, so I balled it up. 👉 ball it up 揉成纸团 She’s already fluffed that pillow. 👉 fluff vi. 抖松 pillow n. 枕头 I just don’t wanna give them any more ammunition than they already have. 👉 ammunition n. &lt;喻&gt; “炮弹”（指抨击别人的材料 手段或依据等） I mean, you’re like all chaotic and twirly. 👉 chaotic adj. 混乱的 无秩序的 twirl v. 旋转 捻弄 That’s because as far as my parents are concerned… 👉 as far as…be concerned 就…而言 couch cushion lasagna sonogram Oh, like I wasn’t dreading tomorrow enough having to give it back to him. ‘Hi Barry! Remember me? I’m the girl in the veil who stomped on your heart in front of your entire family!’ 👉 dreading v. 恐惧 担心 👉 the girl in the veil 穿着婚纱的女孩 stomp on your heart 伤透了你的心 Kinda puts that whole pillow thing in perspective. 👉 in perspective adv. 正确地 👉 kinda 在片中出现的次数非常频繁，也是口语中非常实用的词语，意思是有一点儿，相当于 kind of Well now, how do you fit into this whole thing? 👉 fit into v. 适应 协调 I mean presumably, the biggest part of your job is done. 👉 presumably adv. 推测起来 大概 from scratch 白手起家 从零开始 The big one had a thing for you, didn’t she? 👉 have a thing for v. 对…特别感兴趣 We ran into her parents at the club, they were not playing very well. 👉 run into v. 偶遇 altar chubby harmonica What’s that supposed to mean? “What does that mean?” might be simple not understanding the sentence.but if there is focus on the word “that” eg. what does THAT mean? it is asking what the intention / meaning is while taking offence 生气. “what is that supposed to mean?” is for when someone reads into more of the message beyond the literal words, usually with offence. Look, there are people like Ross who need to shoot for the stars. 👉 “Shoot for the stars“ means to set high goals for yourself No news, no little anecdotes to share with the folks? 👉 anecdote n. 轶事 八卦 the folks n. 父母 Well, y’know, these people are pros. They know what they’re doing, they take their time, they get the job done. 👉 pro = professional n. 专家 take one’s time 从容不迫 Well, you may wanna steer clear of the word ‘dumped’. Chances are he’s gonna be this broken shell of a man, y’know, so you should try not to look too terrific, I know it’ll be hard. 👉 steer clear of 避开 绕开 👉 shell n. 壳 terrific adj. 光彩照人 Chances are… (很有)可能… 👉 “Broken shell of a man“ means that his spirit was broken and he only looks like a man now. He is empty of what makes someone a man. Got me. 👉 It can be as you are playing a game, whether physical or a board game, and your opponent gets a score, going against something you did perhaps. It can also mean you do not know when a person asks you a question. Sorry I’m late, I got stuck at work. 👉 informal unable to escape from a bad or boring situation How could I forget? 👉 咬牙切齿 Things change, roll with the punches. I believe Julia’s on the table? 👉 roll with the punches 👉 to be able to deal with a series of difficult situations 👉 on the table adv. 在桌面上 在讨论的范围 tanned maid of honour = bridemaid You’ve got plugs! And you’ve got lenses! 👉 got plugs 植发 lens n. 隐形眼镜 = contact lens I’m an orthodontist. 👉 orthodontist n. 正牙医生 I don’t remember you making any sperm. Yeah, and we all know what a challenge that is! 👉 sperm n. 精液 精子 she gets a credit. 👉 get a credit v. 得到功劳 Cause I think that borders on child abuse. 👉 border on 与……接壤 He knows no-one’s gonna say all those names, so they’ll wind up calling her Geller, then he gets his way! 👉 wind up doing = end up doing 最终… get his way 他就得逞 随心所欲 How are we today? Any nausea? I was just wondering about the mother-to-be 👉 nausea n. 恶心 What are we supposed to be seeing here? Are you welling up? 👉 well up 热泪盈眶 y’know, if everything works out, and you guys end up getting married and having kids - and everything - I just hope they have his old hairline and your old nose. 👉 works out 👉 be capable of being solved. / have a good or specified result. Okay, I know it was a cheap shot, but I feel so much better now. 👉 a cheap shot 贱招 Episode 03 He walked me to the subway. 👉 walk sb to sw 送某人去哪里 Cushions the blow. 👉 &lt;俚&gt; to do something that reduces harm 善意的谎言 So how does it feel knowing you’re about to die? 👉 be about to do 将要 Try taking a puff. 👉 吐口烟 It’s the same as the distance from the tip of a guy’s thumb to the tip of his index finger. 👉 index finger 食指 I’m going through my mail, and I open up their monthly, you know, STATEMENT. 👉 go through 仔细检查 monthly statement 每月声明 We’re with you. We got it. 👉 我们懂你 I mean, I bring a guy home, and within five minutes they’re all over him. 👉 1）不喜欢 全身挑毛病 👉 2）非常着迷 I’m all over you. = I have a crush on you. 我對你非常地著迷 👉 I’m over you. 我跟你之間完了 Thank you for calling attention to our error. 👉 感谢你提出我们的错误 We have credited your account with five hundred dollars. 👉 往你账户里存了500元 The way his smile was kinda crooked. 👉 他笑起来有点邪邪的 From the nursery rhyme. 👉 nursery rhyme 儿歌 童谣 So I think Alan will become the yardstick against which all future boyfriends will be measured. 👉 yardstick 准绳 saltine tin foil hat pretzel coyote I opened it up and there it was, just floating in there, like this tiny little hitch-hiker! 👉 hitch-hiker 搭便车的旅行者 He’ll get over it. 👉 get over 熬过 I have had it with you guys and your cancer and your emphysema and your heart disease. The bottom line is, smoking is cool, and you know it. 👉 hava hsd 受够了 emphysema 肺气肿 the bottom line is 最重要的是 I have one now and then 👉 偶尔 Pop-Tart I’m getting a deja vu. 👉 deja vu 似曾相识的感觉 幻觉记忆 Episode 04 If I were omnipotent for a day. 👉 omnipotent 全能的 无所不能的 You just nodded off again. 👉 nod off 打盹 打瞌睡 My grandmother has this new boyfriend, and they’re both kind of insecure in bed. Oh, and deaf. So they’re constantly, like, having to reassure each other that they’re having a good time. 👉 insecure 局促不安的 无把握的 reassure 使…恢复信心 打消…的疑虑 You got way too much free time. 👉 way too 太过于… You are way too young to see that. Today’s the day Carol and I first .. consummated our physical relationship. Sex. ..You know what, I’d better pass on the game. 👉 consummate 圆房 完婚 pass on 不去 You can totally, totally live on this. 👉 live on 靠…生活 apron peache nectarine Twister puck I know. I know! I’m a duplex. 👉 duplex &lt;美&gt; 双层楼公寓 双胞胎 we’re on the subject of news. 👉on the subject of 谈到…时 涉及…时 👉 While we are on the subject of money, may I ask when you will repay the loan? Tell me all the dirt! 👉 dirt 八卦 丑闻 Let’s talk reality for a second. we’d have kinda like a slumber party thing. We got some trashy magazines, we got cookie dough, we got Twister … 👉 slumber party 女孩子的睡衣派对 cookie dough 曲奇饼 Could you please tell me what this is in reference to? 👉 in reference to 关于 floopy &lt;俚&gt; 👉 confused, in a state of inner turmoil. if soemone feels floopy, nothing is going right and they can’t make sense of their life or the things that are happening to them. Look, I don’t wanna make any trouble, okay, but I’m in a lot of pain here, alright? My face is dented. 👉 凹陷 Was he wearing a stunning blue suit? 👉 stunning 极好的 stun stun 打晕 击晕 I remember the moonlight coming through the window and her face had the most incredible glow. 👉 glow 脸红 发烫 Could I get some painkillers over here? 👉 painkiller 止痛药 I think there’s a man on the twelfth floor in a coma who didn’t quite hear you … 👉 in a coma 昏迷 Finders keepers, losers weepers. 👉 weep 哭泣 No rough holding in my ER! 👉 rough holding 粗暴的行为 ER emergency room Episode 05 There’s one little maneuver, and bam, a bra right out the sleeve. 👉 maneuver 策略 谋略 花招 Ok, you know what blows my mind? Women can see breasts any time they want. You just look down and there they are. How you get any work done is beyond me. 👉 blow one’s mind 使某人感到兴奋 be beyond sb 某件事使某人难以理解 Multiple orgasms! 👉 多次高潮 Oh, thanks, but I think she’d feel like we’re ganging up on her. 👉 gang up on sb 联合反对 hunger strike 绝食抗议 sophisticated 成熟的 audition 试镜 What’s the matter? Why so scrunchy? 👉 scrunch 缩紧 揉皱 scrunchy &lt;俚&gt; 愁眉苦脸的 Did he give you that whole “You’re-not-up-to-this” thing again? 👉 be up to 胜任 That’s because I’m wearing a dress that accents my boobs. 👉 accent 强调 着重 Oh, big glamour night. 👉 glamour 魅力 诱惑力 The moonlight cast a glamour over the scene. Not after your cousin who could belch the alphabet. 👉 belch the alphabet 打嗝嗝出字母 指无聊的人 lay kitchen tile 👉 铺厨房瓷砖 Are you sure you’ve thought this thing through? 👉 think through 想清楚 fuzzy bear espresso moose squirrel You can mix and match, moose and squirrel. Whatever you want. 👉 mix and match 混搭 detergent Oh, like you’ve never gotten a little rambunctious with Ross. 👉 rambunctious 粗暴的 喧闹的 If we put our heads together, between the two of us, we can break them up. 👉 put our head together 共同想办法 What a neat idea! 👉 neat &lt;美口&gt; 美妙的 很棒的 Oh, he needed some time to grieve. 👉 grieve 悲痛 忧伤 Episode 06~10Episodee 06 You can always spot someone who’s never seen one of his plays before. Notice, no fear, no sense of impending doom… 👉 spot 看见 场所 impending 即将发生的 doom 毁灭 死亡 The exclamation point in the title scares me. 👉 exclamation point 惊叹号 God. I feel violated. 👉 violate 冒犯 干扰 She makes the women that I dream about look like short, fat, bald men! 👉 对比 Oh yeah, and what would my opening line be? 👉 opening line 开场白 Oh please, could she be more out of my league? 👉 A be out of B league B 配不上 A I’m very very aware of my tongue… 👉 be aware of one’s tongue 谨慎行事 It was better than that thing I did with the trolls, at least you got to see my head. 👉 troll (合唱中的)轮唱 Oh, listen, the usher gave me this to give to you. 👉 usher 引座员 fish out 掏出 Well, You know, monogamy can be a, uh, tricky concept. I mean, anthropologically speaking. 👉 monogamy 一夫一妻制 tricky 复杂的 anthropologically 人类学上 ottoman robe Thank God you didn’t try to fan out the magazines. I mean, she’ll scratch your eyes right out. 👉 fan out 散开 right out / away 马上 Oh come on! When we were kids, yours was the only Raggedy Ann doll that wasn’t raggedy! 👉 raggedy 褴褛的 Alright, you madcap gal. 👉 madcap 鲁莽的 gal 女孩 right away 立即 I buy laundry detergent, but it’s not the one with the easy-pour spout. 👉 spout 喷口 Little beads of condensation are inching their way closer and closer to the surface of the wood. 👉 coaster 杯垫 bead 水珠 condensation 冷凝 inch 缓慢地移动 You’ve finally been able to crack your way into show business. 👉 crack your way into 闯入 I need to borrow some moisturizer. 👉 moisturize 变潮湿 增加水分 moisturizer 保湿乳液 Ooh, do I sense a little bit of resentment? 👉 resentment 怨恨 不满 The old Monica would remind you to scrub that pan with a plastic brush. But I’m not gonna do that. 👉 scrub 洗擦 I’ve done nothing but crappy plays for six years. 👉 crappy &lt;俚&gt; 蹩脚的 无价值的","categories":[{"name":"English","slug":"English","permalink":"http://yoursite.com/categories/English/"}],"tags":[{"name":"Friends","slug":"Friends","permalink":"http://yoursite.com/tags/Friends/"}]},{"title":"Java 8 新特性","slug":"Welab/Java 开发实战经验/Java 8 新特性","date":"2020-02-18T07:14:54.000Z","updated":"2020-03-31T06:57:49.634Z","comments":true,"path":"2020/02/18/Welab/Java 开发实战经验/Java 8 新特性/","link":"","permalink":"http://yoursite.com/2020/02/18/Welab/Java%20%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%E7%BB%8F%E9%AA%8C/Java%208%20%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"LambdJava SE 8 的一个大亮点是引入了 Lambda 表达式，使用它设计的代码会更加简洁。 当开发者在编写 Lambda 表达式时，也会随之被编译成一个函数式接口，Lambda 允许把函数作为一个方法的参数传递进方法中。Lambda 表达式本质是匿名函数（或者叫匿名方法），也可称之为闭包，像方法一样， Lambda 表达式具有带类型的参数、主体和返回类型。可使用 Lambda 语法来代替匿名的内部类，代码不仅简洁而且还可读。 当然，不足之处可能就是可读性稍差及调试稍麻烦一些。 Lambda 语法格式能够用于 Lambda 表达式的只能是 interface，且 interface 中只有一个方法。 Lambda 表达式的标准结构： (parameters) -&gt; {statements;} 123456789101112&#x2F;&#x2F; 标准结构的各种变形&#x2F;&#x2F; 当方法体中只有一条语句时，return 和 &#123;&#125; 都可省略(parameters) -&gt; expression&#x2F;&#x2F; 当仅有一个参数时，() 可省略parameters -&gt; expression&#x2F;&#x2F; 当没有参数时，可直接使用 ()() -&gt; expression&#x2F;&#x2F; 绝大多数情况下，编译器可以从上下文环境中推断出 Lambda 表达式的参数类型，所以参数的类型声明也可以省掉 Lambda 方法引用Lambda 表达式简洁写法：s -&gt; s.toLowerCase()可省略为 String::toLowerCase 方法引用包含的情况 静态方法引用Class::static_method 构造方法引用Class::new或Class&lt;T&gt;::new 类成员方法引用Class::method 对象方法引用instance::method Supplier 接口：不接受任何参数，返回一个结果（只有一个get()方法）。 123456public class SupplierTest &#123; public static void main(String n args)&#123; Supplier&lt;String&gt; supplier = () -&gt; \"hello world\"; System.out.println(supplier.get()); // 控制台打印 hello world &#125;&#125; StreamJava 8 中的Stream是对集合（Collection）对象功能的增强，适用于对集合对象进行各种便利、高效的过滤、映射、排序及聚合等操作，可以独立也可以组合成复杂的操作。 Stream还同时支持串行和并行两种操作模式，并行模式能够充分利用目前主流的多核处理器的优势，使用 Fork / Join 并行方式来拆分和加速任务的处理过程。Stream API 无需编写多线程代码，通过并发模式很容易就支持任务的并行处理。 Stream API 使用一种类似 SQL 语句从数据库查询数据的直观方式来操作 Java 集合数据，可以写出高效率、干净、简洁的代码，极大的提高集合操作的生产力。可以将要处理的集合元素看作一种流，流在管道中传输，并且可以在管道传输的各个节点上进行筛选、排序及聚合等操作。流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作（terminal operation）得到前面处理的结果。 Stream 示例12345678910111213141516171819202122232425262728293031public class StreamDemo &#123; public static void main(String[] args) &#123; List&lt;String&gt; peekList = Stream.of(\"one\", \"tow\", \"three\", \"four\", \"five\", \"six\", \"seven\") .filter(e -&gt; e.length() &gt; 3) // 过滤出字符串长度大于 3 的元素 .peek(e -&gt; System.out.println(\"Filtered value: \" + e)) .map(String::toUpperCase) // 将元素转为大写 .peek(e -&gt; System.out.println(\"Mapped value: \" + e)) .collect(Collectors.toList()); // 将输出 Stream 转换为 List System.out.println(\"集合打印：\"); for (String string : peekList) &#123; System.out.println(string); &#125; &#125;&#125;// 运行结果Filtered value: threeMapped value: THREEFiltered value: fourMapped value: FOURFiltered value: fiveMapped value: FIVEFiltered value: sevenMapped value: SEVEN集合打印：THREEFOURFIVESEVEN Stream 基础特性 基本流程：数据源（存储） → 元素队列（Stream） → 操作（filter、map、reduce、find、match、sorted 等） Pipelining：中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行（laziness）和短路（short-circuiting）； 内部迭代：以前对集合遍历都是通过 Iterator 或者 For-Each 的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Java Stream 提供了内部迭代的方式， 通过访问者模式（Visitor）实现。 Stream 串 / 并行","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Base","slug":"Base","permalink":"http://yoursite.com/tags/Base/"}]},{"title":"WebSocket","slug":"Netty/WebSocket","date":"2020-02-17T04:12:30.000Z","updated":"2020-04-19T06:34:07.314Z","comments":true,"path":"2020/02/17/Netty/WebSocket/","link":"","permalink":"http://yoursite.com/2020/02/17/Netty/WebSocket/","excerpt":"WebSocket 入门介绍以及 Netty WebSocket 协议开发。","text":"WebSocket 入门介绍以及 Netty WebSocket 协议开发。 HTTP 请求 / 响应模式：客户端加载一个网页，然后直到用户点击下一页之前，什么都不会发生。 Ajax：网络开始变得更加动态了，但所有的 HTTP 通信仍然由客户端控制，这就需要用户进行互动或定期轮询，以便从服务器加载新数据。 长期以来存在着各种技术让服务器得知有新数据可用时，立即将数据发送到客户端这些技术种类繁多。最常用的一种黑客手段是对服务器发起链接创建假象，被称为长轮询。利用长轮询，客户端可以打开指向服务器的 HTTP 连接，而服务器会一直保持连接打开，直到发送响应。服务器只要实际拥有新数据，就会发送响应。 问题：由于 HTTP 协议的开销，导致它们不适用于低延迟应用。 WebSocket：将网络套接字引入到了客户端和服务端来解决这一问题，浏览器和服务器之间可以通过套接字建立持久的连接，双方随时都可以互发数据给对方，而不是之前由客户端控制的一请求一应答模式。 WebSocket 入门在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道，两者就可以直接互相传送数据了。WebSocket 基于 TCP 双向全双工进行消息传递，在同一时刻，既可以发送消息，也可以接收消息，相比于 HTTP 的半双工协议，性能得到很大提升。 WebSocket 连接建立 WebSocket 连接时，需要通过客户端或者浏览器发出握手请求。 握手请求消息如下： 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息 Upgrade: WebSocket表明这是一个申请协议升级的 HTTP 请求。服务器端解析这些附加的头信息，然后生成应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方可以通过这个连接通道自由地传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动关闭连接。 握手应答消息如下： 请求消息中的Sec-WebSocket-Key是随机的,服务器端会用这些数据来构造出一个 SHA-1 的信息摘要。使用 SHA-1 加密,然后进行 BASE-64 编码，将结果做为Sec- WebSocket- Accept头的值，返回给客户端。 WebSocket 生命周期握手成功之后,服务端和客户端就可以通过 messages 的方式进行通信了，一个消息由一个或者多个帧组成，WebSocket的消息并不一定对应一个特定网络层的帧，它可以被分割成多个帧或者被合并。 WebSocket 的握手关闭消息带有一个状态码和一个可选的关闭原因，它必须按照协议要求发送一个 Close 控制帧，当对端接收到关闭控制帧指令时，需要主动关闭 WebSocket连接。 Netty WebSocket 协议开发Netty 基于 HTTP 协议栈开发了 WebSocket 协议栈,利用 Netty 的 WebSocket 协议栈可以非常方便地开发出 WebSocket 客户端和服务端。 Netty 服务端实例功能介绍 支持 WebSocket 的浏览器通过 WebSocket 协议发送请求消息给服务端，服务端对请求消息进行判断； 如果是合法的 WebSocket 请求,则获取请求消息体（文本）并在后面追加字符串“欢迎使用 Netty WebSocket服务,现在时刻:[系统时间]”； 客户端 HTML 通过内嵌的 JS 脚本创建 WebSocket 连接，握手成功 / 失败，在文本框中打印“打开 Web Socket服务正常,浏览器支持 Web Socket!” / “抱歉，您的浏览器不支持 Web Socket协议!”。 功能开发12345678&lt;!-- pom.xml --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty-all&lt;/artifactId&gt; &lt;version&gt;5.0.0.Alpha1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// WebSocket 服务端启动类public class WebSocketServer&#123; public void run(int port) throws Exception&#123; EventLoopGroup bossGroup = new NioEventLoopGroup (); EventLoopGroup workerGroup = new NioEventLoopGroup(); try &#123; ServerBootstrap b= new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline (); // 将请求和应答消息编码 / 解码为 HTTP 消息 pipeline.addLast(\"http-codec\", new HttpServerCodec()); // 将 HTTP 消息的多个部分组合成一条完整的 HTTP 消息 pipeline.addLast (\"aggregator\", new HttpObjectAggregator(65536)); // 主要用于支持浏览器和服务端进行 WebSocket 通信 ch.pipeline().addLast(\"http-chunked\", new ChunkedWriteHandler()); // 增加 WebSocket 服务端 handler pipeline.addLast(\"handler\", new WebSocketServerHandler()); &#125; &#125;); Channel ch = b.bind(port).sync().channel(); System.out.println(\"Web socket server started at port\" + port +'.'); System.out.println (\"Open our browser and navigate to http://localhost:\" + port + '/'); ch.closeFuture().sync(); &#125; finally &#123; bossGroup. shutdownGracefully(); workerGroup. shutdownGracefully(); &#125; &#125; public static void main(String[] args) throws Exception &#123; int port = 8080; if (args.length &gt;0) &#123; try&#123; port = Integer.parseInt(args[0]); &#125; catch(NumberFormatException e) &#123; e.printStackTrace(); &#125; &#125; new WebSocketServer().run(port); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889// Websocket 服务端处理类public class WebSocketServerHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; private static final Logger logger = Logger.getLogger(WebSocketServerHandler.class.getName()); private WebSocketServerHandshaker handshaker; @Override protected void messageReceived(ChannelHandlerContext ctx, Object msg) throws Exception &#123; // 传统的 HTTP 接入 if (msg instanceof FullHttpRequest)&#123; // 判断请求消息有中是否包含 Upgrade: websocket handleHttpRequest(ctx,(FullHttpRequest)msg); &#125;// WebSocket 接入 else if (msg instanceof WebSocketFrame)&#123; handleWebSocketFrame(ctx,(WebSocketFrame)msg); &#125; &#125; private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception&#123; // 如果 HTTP 解码失败，返回 HTTP 400 响应异常 if (!req.getDecoderResult().isSuccess() || (!\"websocket\".equals(req.headers().get(\"Upgrade\"))))&#123; sendHttpResponse(ctx, req,new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.BAD_REQUEST)); return; &#125; // 构造握手工厂，本机测试 WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory(\"ws://localhost:8080/websocket\",null,false); // 创建握手处理类 handshaker = wsFactory.newHandshaker(req); if (handshaker == null)&#123; WebSocketServerHandshakerFactory.sendUnsupportedWebSocketVersionResponse(ctx.channel()); &#125;else &#123; // 构造握手响应消息返回给客户端 // 将 WebSocket 相关的编码和解码类动态添加到 ChannelPipeline 中用于 WebSocket 消息的编解码 handshaker.handshake(ctx.channel(),req); &#125; &#125; // 链路建立成功之后分别对控制帧进行判断 private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) &#123; // 判断是否关闭链路指令 if (frame instanceof CloseWebSocketFrame)&#123; handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain()); return; &#125; // 判断是否是维持链路的 Ping 消息 if (frame instanceof PingWebSocketFrame)&#123; // 构造 pong 消息返回 ctx.channel().write(new PongWebSocketFrame(frame.content()).retain()); return; &#125; // 本例程仅支持文本信息，故对非文本消息抛出异常 if (!(frame instanceof TextWebSocketFrame))&#123; throw new UnsupportedOperationException(String.format(\"%s frame types not supported\",frame.getClass().getName())); &#125; // 返回应答消息 String request = ((TextWebSocketFrame) frame).text(); if (logger.isLoggable(Level.FINE))&#123; logger.fine(String.format(\"%s received %s\",ctx.channel(),request)); &#125; // 构造新的 TextWebSocketFrame 消息返回给客户端 // 由于握手应答时动态增加了 TextWebSocketframe 的编码类,所以可以直接发送 TextWebSocketFrame对象 ctx.channel().write(new TextWebSocketFrame(request+\"欢迎使用Netty WebSocket服务，现在时刻:\" + new Date().toString())); &#125; private static void sendHttpResponse(ChannelHandlerContext ctx,FullHttpRequest req,FullHttpResponse res)&#123; // 返回应答给客户端 if (res.getStatus().code() != 200)&#123; ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(), CharsetUtil.UTF_8); res.content().writeBytes(buf); // 明确释放ByteBuf的引用计数 buf.release(); setContentLength(res,res.content().readableBytes()); &#125; // 如果是非 Keep-Alive，关闭连接 ChannelFuture f = ctx.channel().writeAndFlush(res); if (!isKeepAlive(req) || res.getStatus().code() != 200)&#123; f.addListener(ChannelFutureListener.CLOSE); &#125; &#125; @Override public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123; ctx.flush(); &#125; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;WebSoket Demo&lt;/title&gt; &lt;script type=\"text/JavaScript\"&gt; var WebSocket = WebSocket || window.WebSocket || window.MozWebSocket; if (!WebSocket) &#123; alert(\"WebSocket not supported by this browser!\"); &#125; else &#123; var ws = null; function Display() &#123; console.log(\"websocket 测试\"); &#125; var log = function (s) &#123; if (document.readyState !== \"complete\") &#123; log.buffer.push(s); &#125; else &#123; document.getElementById(\"contentId\").value += (s + \"/n\"); &#125; &#125; function CreateConnect () &#123; var msg = document.getElementById(\"wsUrlId\"); console.log(\"CreateConnect(), url: \" + msg.value); if (ws == null) &#123; var wsUrlValue = msg.value; try &#123; ws = new WebSocket(wsUrlValue); ws.onmessage = function (event) &#123; log(\"onmessage(), 接收到服务器消息: \" + event.data); &#125;; ws.onclose = function (event) &#123; log(\"onclose(), Socket 已关闭!\"); ws = null; &#125;; ws.onopen = function (event) &#123; log(\"onopen(), Socket 连接成功!\"); &#125;; ws.onerror = function (event) &#123; &#125;; &#125; catch (e) &#123; ws = null; log(\"连接异常, 重置 websocket\"); &#125; &#125; &#125; function SendMsg() &#123; var msg = document.getElementById(\"messageId\"); console.log(\"SendMsg(), msg: \" + msg.value); if (ws != null) &#123; log(\"发送 Socket 消息: \" + msg.value); ws.send(msg.value); &#125; else &#123; log(\"Socket 还未创建!, msg: \" + msg.value); &#125; &#125; function CloseConnect () &#123; console.log(\"CloseConnect()\"); if (ws != null) &#123; ws.close(); &#125; &#125; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body onload=\"Display()\" &gt; &lt;div id=\"valueLabel\"&gt;&lt;/div&gt; &lt;textarea rows=\"10\" cols=\"40\" id=\"contentId\"&gt;&lt;/textarea&gt; &lt;br/&gt; &lt;input name=\"wsUrl\" id=\"wsUrlId\" value=\"ws://localhost:8080/websocket\"/&gt; &lt;button id=\"createButton\" onClick=\"javascript:CreateConnect()\"&gt;Create&lt;/button&gt; &lt;button id=\"closeButton\" onClick=\"javascript:CloseConnect()\"&gt;Close&lt;/button&gt; &lt;br/&gt; &lt;input name=\"message\" id=\"messageId\" value=\"Hello, Server!\"/&gt; &lt;button id=\"sendButton\" onClick=\"javascript:SendMsg()\"&gt;Send&lt;/button&gt; &lt;/body&gt;&lt;/html&gt; 测试结果控制台打印 浏览器调试","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"2020 读书笔记","slug":"Summary/社会心理学","date":"2020-02-16T14:22:10.000Z","updated":"2020-03-02T04:17:48.607Z","comments":true,"path":"2020/02/16/Summary/社会心理学/","link":"","permalink":"http://yoursite.com/2020/02/16/Summary/%E7%A4%BE%E4%BC%9A%E5%BF%83%E7%90%86%E5%AD%A6/","excerpt":"书籍摘要以及感悟。","text":"书籍摘要以及感悟。 二月情绪沟通：改变看法与自我认知 底层逻辑 法律 👉 将不规则的生活状态放入到一个规则的容器中 👉 如何处理“溢出”的部分？ 美学 👉 引起共鸣 👉 如何让观者感受到作者所要传达的情绪？ 沟通 👉 说服 👉 没有人喜欢被改变 ❗ 人的观点看法 = 过去的选择 + 过去的偏好 讲道理 / 命令式说教 👉 否定一个的过去 👉 本能抗拒 👎 引起共鸣 👍 给予选择权 👉 选择权语句 / 随时可以反悔 👍 我需要 你为什么要 人的情绪 👉 很大程度决定选择 👉 深挖情绪：这件事对你来说意味着什么？ 👉 根据情绪寻找解决办法 👍 愤怒 👉 强化现有想法 惊讶 👉 动摇现有看法 悲伤 👉 找到重要看法 问题的理解 期待与现实的落差 👉 是否合理 你眼中的问题是别人的解决方案 换角度思考问题 👉 别局限于自身 产品经理四个维度：产品、用户、场景、效率。 产品功能？ 👉 服务特性 ATM 机的显性特性：取钱 ATM 机的隐形特性：分流窗口压力、品牌效应、无利息的现金外存…（运营做大量的市场调查） 产品能否达成战略述求以及能否持续的提供服务 👉 资源的有限性 👉 取舍 用户 👉 分层、用户画像 👉 不同群体有不同的服务需求、用户特性影响决定方式 同程艺龙 VS 美团酒店 场景 👉 时间、空间、情绪 情绪的力量 👉 欲望 👉大甩卖 自我与自制二者不可共存 👉 探寻自我，选择适合自己的一面","categories":[{"name":"Life","slug":"Life","permalink":"http://yoursite.com/categories/Life/"}],"tags":[{"name":"Notes","slug":"Notes","permalink":"http://yoursite.com/tags/Notes/"}]},{"title":"Java 后端开发环境搭建","slug":"Welab/Java 后端开发环境搭建","date":"2020-02-15T09:48:23.000Z","updated":"2020-04-19T06:44:54.137Z","comments":true,"path":"2020/02/15/Welab/Java 后端开发环境搭建/","link":"","permalink":"http://yoursite.com/2020/02/15/Welab/Java%20%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","excerpt":"记录开发环境搭建过程以及整合资源以便快速搭建环境。","text":"记录开发环境搭建过程以及整合资源以便快速搭建环境。 JDK 安装 Oracle 官网 下载 JDK 安装包，需要注册账号后才可下载。 云盘资源下载：jdk-8u241-windows-x64.exe 修改安装目录注意事项： ​ 安装在非操作系统所在目录下； ​ 安装的路径中不要有中文及空格。 目录介绍JDK 目录：Java Development Kit 即 Java 开发工具，包含 JRE。 JRE 目录：Java Runtime Environment 即 Java 运行时环境。 JVM：Java Virtual Machine 即 Java 虚拟机 JVM 是整个 Java 实现跨平台的最核心的部分，所有的 Java 程序会首先被编译为 .class 的类文件，这种类文件可以在虚拟机上执行，也就是说 .class 文件并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。 JRE = JVM + lib。光有 JVM 还不能让 .class 文件执行，因为在解释 .class 文件的时候 JVM 需要调用解释所需要的类库 lib。在 JDK 的安装目录里你可以找到 JRE 目录，里面有两个文件夹 bin 和 lib，在这里可以认为 bin 里的就是 jvm，lib 中则是 JVM 工作所需要的类库，所以 JVM 和 lib 和起来就称为 JRE。 JDK 目录 bin：开发工具，包含了开发、执行、调试 Java 程序所使用的工具和实用程序，以及开发工具所需要的类库和支持文件。 include：头文件，它支持使用 Java 本地接口和 Java 虚拟机调试接口的本地代码编程。 jre：运行环境，实现了 Java 运行环境。是运行 Java 程序所必须的环境。JRE 包含了 Java 虚拟机 JavaTM Virtual Machine(JVM)、Java 核心类库和支持文件。如果只运行 Java 程序，则只需要安装 JRE。如需开发 Java 程序，则需安装 JDK。JDK 中包含了 JRE。 lib：包括了 Java 开发环境的 Jar 包，是给 JDK 用的。例如 JDK 下有一些工具，可能要用该目录中的文件。例如，编译器等。 src.zip：构成 Java 核心 API 的所有类的源文件，包括了 java.、javax. 和某些 org.* 包中类的源文件，不包含 com.sun.* 包中类的源文件。 验证安装 配置环境变量新建：JAVA_HOME = [JDK 安装目录]编辑添加：classpath = %JAVA_HOME%/lib/dt.jar;%JAVA_HOME%/lib/tools.jar;.;编辑添加：Path = %JAVA_HOME%/bin; Path 环境变量的值就是一个可执行文件路径的列表，提供给系统寻找和执行应用程序的路径。当执行一个可执行文件时，系统首先在当前路径下寻找，如未找到，则到 Path 中指定的各个路径中去寻找，直到找到为止，如果 Path 路径中也找不到，则报错。Java 的编译器（javac.exe）和解释器（java.exe）都在其安装路径下的 bin 目录中，为了在任何路径下都可以使用它们编译执行 Java 程序，应该将它们所在的目录添加到 Path 变量中;classpath 环境变量指定了 Java 程序编译或运行时所用到的类的搜索列表。Java 虚拟机查找类的过程不同于 Windows 查找可执行命令（.exe、.bat 或 .cmd 以及 .dll 动态链接库）的过程。它不在当前路径下寻找，只到 classpath 指定的路径列表中去寻找，所以在设定环境变量时一定要把当前路径包含进来。变量中的“.”代表当前路径，表示 Java 虚拟机先到当前路径下去查找要使用的类，当前路径指 Java 虚拟机运行时的当前工作目录;3、JAVA_HOME 的值就是 JDK 安装路径的值。当需要使用 JDK 路径时，直接用 %JAVA_HOME% 的方式引用，方便简单。如果 JDK 的安装路径发生了变化或者安装了新版本的 JDK，只需修改 JAVA_HOME 的值即可，其它引用 JAVA_HOME 的地方不需要修改。 测试运行 Java 程序新建 HelloWorld.java 文件。 12345public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 编译解释运行。 javac HelloWorld.java的意思是编译 HelloWorld.java 文件，并生成 HelloWorld.class 字节码文件。 java HelloWorld 的意思是运行字节码文件 HelloWorld.class，运行的时候并不需要输入 .class 后缀。 运行成功后输出结果：Hello World! MySQL 安装官网下载：MySQL Installer 8.0.19 云盘资源下载：mysql-installer-community-8.0.19.0.msi 下载 MSI 版本，直接安装，MSI 版本安装的好处是不用手动配置环境变量，和修改配置文件，整个安装过程只需要点击下一步即可。 安装版本分在线安装版本和离线安装版本，这里选择离线安装版本，整个安装过程会比较流畅。而在线安装在网络不佳的情况下可能会特别慢。 运行安装包，选择 Full 模式安装 测试模式下，为了兼容老版本的开发工具以及 jar 包，选择传统授权方法（MySQL 5.x）。 强密码加密方法（MySQL 8.0）采用了新的密码加密方式，也就意味着老版本的数据库访问客户端版本也要更新到支持的版本。 检测是否能连接上 MySQL 服务器。 安装完成。services.msc查看 MySQL 服务是否已经启动，并利用 SQLyog 访问数据库。 Tomcat 安装官网下载：apache-tomcat-8.5.51.exe 运行安装包。 下载完成后，来到安装目录。可以看到 Tomcat 服务已经启动。（可用 startup / showdown.bat 来启动 / 关闭服务） 通过脚本启动服务后发现输出的日志中存在乱码。到安装目录下的 bin 文件夹中编辑 logging.properties 配置文件。 重启 Tomcat 服务器，日志输出正常。成功访问 localhost:8080。 IDEA 安装官网下载：IntelliJ IDEA 云盘资源下载：IntelliJ-2019.1.4.exe IDEA 的安装和配置：点击进入 Maven 的安装和配置：点击进入 IDEA 常用插件介绍（Updating）PS：遇到使用场景后持续更新各插件用法。 Setting → Plugins 下搜索并下载插件 GitToolBox 提供 Git 的一些操作，可以设置时间间隔来比对本地代码和服务器上代码有多少不同，这样可以在提交代码先进行代码的更新。 Findbugs-IDEA 此插件仅支持到 2018.1.8 版本的 IDEA。 PMD 是一个静态代码检测工具，辅助我们检测潜在bug的工具，大大减少了人工审查成本，提高编码效率。 Alibaba Java Coding Guidelines 快捷键Ctrl+Shift+Alt+J，编码规约扫描。 Lombok项目中经常使用 bean，entity 等类，绝大部分数据类类中都需要 get、set、toString、equals 和 hashCode 方法，虽然 eclipse 和 idea 开发环境下都有自动生成的快捷方式，但自动生成这些代码后，如果 bean 中的属性一旦有修改、删除或增加时，需要重新生成或删除 get / set 等方法，给代码维护增加负担。而使用了 lombok 则不一样，使用了 lombok 的注解（@Setter，@Getter，@ToString，@@RequiredArgsConstructor，@EqualsAndHashCode，@Data）之后，就不需要编写或生成 get / set 等方法，很大程度上减少了代码量，而且减少了代码维护的负担。故强烈建议项目中使用 lombok，去掉 bean 中 get、set、toString、equals 和 hashCode 等方法的代码。 pom.xml 中添加 Lombok 依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.10&lt;/version&gt;&lt;/dependency&gt; 示例代码 1234567891011121314151617package com.lombok.demo; import lombok.EqualsAndHashCode;import lombok.Getter;import lombok.Setter;import lombok.ToString;@Setter@Getter@ToString@EqualsAndHashCodepublic class Student &#123; private String name; private int age; private String male;&#125; 测试类 1234567891011121314151617181920212223242526272829package com.lombok.demo; import lombok.extern.java.Log; // 省略了 private static final ogger log = Logger.getLogger(LogExample.class.getName());@Logpublic class LombokTest &#123; public static void main(String[] args) &#123; Student student = new Student(); student.setAge(23); student.setMale(\"man\"); student.setName(\"wingo\"); System.out.println(student.toString()); Student student2 = new Student(); student2.setAge(23); student2.setMale(\"man\"); student2.setName(\"wingo\"); System.out.println(student.equals(student2)); student2.setAge(\"24\"); System.out.println(student.equals(student2)); log.info(\"lombok test\"); &#125;&#125; 测试结果 1234Student(name&#x3D;wingo, age&#x3D;23, male&#x3D;man)truefalselombok test SonarLint 代码分析工具，能够在编码的阶段实时检查代码，并且在代码提交前做检查等，把存在的问题提前暴露，提高代码质量。 .ignore 在项目上右键 → New → .ignore file → .gitignore file(Git)，忽略不需要提交的文件。 Maven Helper 查看 Maven 的冲突与依赖。 Acejump 快速光标跳转方式。 RestfulToolkit 接口测试工具。 CodeGlance 在代码的右侧显示代码小地图。 MyBatis Log Plugin 控制台打印 MyBatis 脚本日志。 String Manipulation 强大的字符串转换工具。 GsonForma Json 实力类快速生成工具。 JUnitGenerator V2.0 帮助生成单元测试工具。 JRebel 热部署插件。完全不用重启服务器，开发后端和前端一样。包括添加类，方法，注解，修改 xml 和 properies 文件。 Translation GenerateAllSetter CodeMaker 代码生成插件。支持增加自定义代码模板（Velocity）；支持选择多个类作为代码模板的上下文。 Grep Console 可以设置不同级别log的字体颜色和背景色。 Key Promoter X 快捷键提示工具。当你在 IDEA 里面使用鼠标的时候，如果这个鼠标操作是能够用快捷键替代的，那么 Key Promoter X 会弹出一个提示框，告知你这个鼠标操作可以用什么快捷键替代。 Swip（Spring Web Initializr） IdeaVim 在 Intellij 中模拟 Vim 的操作方式。 BashSupport IEDA 中的 BashSupport 插件支持在IDEA中编写shell脚本文件，有友好的代码格式，支持自动补全，检查错误，并且配置完之后，还可以在IEDA中直接运行shell脚本 EduTools 使用 EduTools，您可以通过代码练习任务来学习和教导 Kotlin","categories":[{"name":"Welab","slug":"Welab","permalink":"http://yoursite.com/categories/Welab/"}],"tags":[{"name":"Env","slug":"Env","permalink":"http://yoursite.com/tags/Env/"}]},{"title":"Git 命令清单","slug":"Software/Git 命令清单","date":"2020-02-15T07:17:45.000Z","updated":"2020-04-19T06:41:15.261Z","comments":true,"path":"2020/02/15/Software/Git 命令清单/","link":"","permalink":"http://yoursite.com/2020/02/15/Software/Git%20%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/","excerpt":"Git 对于程序员可以说使一项必备的技能，故列此清单方便查询。","text":"Git 对于程序员可以说使一项必备的技能，故列此清单方便查询。 转载自：阮一峰的网络日志 → 常用 Git 命令清单 Git 操作流程 Workspace：工作区； Index / Stage：暂存区； Repository：本地仓库； Remote：远程仓库。 新建代码库12345678# 在当前目录新建一个 Git 代码库git init# 新建一个目录，将其初始化为 Git 代码库git init [project-name]# 下载一个项目和它的整个代码历史git clone [url] 配置Git 的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。 123456789101112# 显示当前的 Git 配置git config --list# 编辑 Git 配置文件git config -e [--global]# 查看 Git 配置文件git config -l# 设置提交代码时的用户信息git config [--global] user.name \"[name]\"git config [--global] user.email \"[email address]\" 文件操作123456789101112131415161718192021# 添加指定文件到暂存区git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录git add [dir]# 添加当前目录的所有文件到暂存区git add .# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交git add -p# 删除工作区文件，并且将这次删除放入暂存区git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区git rm --cached [file]# 改名文件，并且将这个改名放入暂存区git mv [file-original] [file-renamed] 代码提交123456789101112131415161718# 提交暂存区到仓库区git commit -m [message]# 提交暂存区的指定文件到仓库区git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区git commit -a# 提交时显示所有 diff 信息git commit -v# 使用一次新的 commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化git commit --amend [file1] [file2] ... 分支分支介绍分支是为了将修改记录的整体流程分叉保存。分叉后的分支不受其他分支的影响，所以在同一个数据库里可以同时进行多个修改。 分叉的分支是可以合并的。 master 分支：在数据库进行最初的提交后, Git 会创建一个名为 master 的分支。因此之后的提交，在切换分支之前都会添加到 master 分支里。 分支的运用Merge 分支：Merge 分支是为了可以随时发布 release 而创建的分支，它还能作为 Topic 分支的源分支使用。通常，大家会将 master 分支当作 Merge 分支使用。 Topic 分支：Topic 分支是为了开发新功能或修复 Bug 等任务而建立的分支。若要同时进行多个的任务，请创建多个的 Topic 分支。Topic 分支是从稳定的 Merge 分支创建的。完成作业后，要把 Topic 分支合并回 Merge 分支。 分支操作实例新建仓库12345mkdir testcd testgit initgit add myfile.txtgit commit -m \"first commit\" 新建分支12345# 创建分支git branch test01# 显示分支列表# 带*的就是现在的分支git branch 切换分支12345# 切换分支git checkout test01Switched to branch 'issue1'git add myfile.txtgit commit -m \"添加add的说明\" 合并分支123git checkout masterSwitched to branch 'master'git merge test01 master 分支指向的提交移动到和 test01 同样的位置。这个是 fast-forward（快进）合并。 常用命令123456789101112131415161718192021222324252627282930313233343536373839404142434445# 列出所有本地分支git branch# 列出所有远程分支git branch -r# 列出所有本地分支和远程分支git branch -a# 新建一个分支，但依然停留在当前分支git branch [branch-name]# 新建一个分支，并切换到该分支git checkout -b [branch]# 新建一个分支，指向指定commitgit branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区git checkout [branch-name]# 切换到上一个分支git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支git merge [branch]# 选择一个commit，合并进当前分支git cherry-pick [commit]# 删除分支git branch -d [branch-name]# 提交远程分支git push origin [branch-name]# 删除远程分支git push origin --delete [branch-name]git branch -dr [remote/branch] 标签1234567891011121314151617181920212223242526# 列出所有taggit tag# 新建一个tag在当前commitgit tag [tag]# 新建一个tag在指定commitgit tag [tag] [commit]# 删除本地taggit tag -d [tag]# 删除远程taggit push origin :refs/tags/[tagName]# 查看tag信息git show [tag]# 提交指定taggit push [remote] [tag]# 提交所有taggit push [remote] --tags# 新建一个分支，指向某个taggit checkout -b [branch] [tag] 查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件git status# 显示当前分支的版本历史git log# 显示commit历史，以及每次commit发生变更的文件git log --stat# 搜索提交历史，根据关键词git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其\"提交说明\"必须符合搜索条件git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名git log --follow [file]git whatchanged [file]# 显示指定文件相关的每一次diffgit log -p [file]# 显示过去5次提交git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序git shortlog -sn# 显示指定文件是什么人在什么时间修改过git blame [file]# 显示暂存区和工作区的差异git diff# 显示暂存区和上一个commit的差异git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异git diff HEAD# 显示两次提交之间的差异git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码git diff --shortstat \"@&#123;0 day ago&#125;\"# 显示某次提交的元数据和内容变化git show [commit]# 显示某次提交发生变化的文件git show --name-only [commit]# 显示某次提交时，某个文件的内容git show [commit]:[filename]# 显示当前分支的最近几次提交git reflog 远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动git fetch [remote]# 显示所有远程仓库git remote -v# 显示某个远程仓库的信息git remote show [remote]# 增加一个新的远程仓库，并命名git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并git pull [remote] [branch]# 上传本地指定分支到远程仓库git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突git push [remote] --force# 推送所有分支到远程仓库git push [remote] --all 撤销12345678910111213141516171819202122232425262728293031# 恢复暂存区的指定文件到工作区git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区git checkout [commit] [file]# 恢复暂存区的所有文件到工作区git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变git reset [file]# 重置暂存区与工作区，与上一次commit保持一致git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变git reset --keep [commit]# 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支git revert [commit]# 暂时将未提交的变化移除，稍后再移入git stashgit stash pop 实际问题解决123456789## 分支取得更新到 master 文件git checkout mastergit pull mastergit checkout wingogit merge master## 远程修改分支文件后的本地更新git reset --hard # 强制覆盖本地版本git pull origin wingo # 同步远程的分支","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"各种乱码问题","slug":"Software/各种乱码问题","date":"2020-02-01T11:38:54.000Z","updated":"2020-02-15T05:28:24.963Z","comments":true,"path":"2020/02/01/Software/各种乱码问题/","link":"","permalink":"http://yoursite.com/2020/02/01/Software/%E5%90%84%E7%A7%8D%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/","excerpt":"在项目开发中，因为各种语言的编码不同常常会遇到各种乱码的问题，令人糟心，故写一篇博客专门用于记录博主在开发过程遇到的各种乱码问题。","text":"在项目开发中，因为各种语言的编码不同常常会遇到各种乱码的问题，令人糟心，故写一篇博客专门用于记录博主在开发过程遇到的各种乱码问题。 Tomcat 控制台乱码到 Tomcat /conf /logging.properties 中修改此项java.util.logging.ConsoleHandler.encoding为 GBK。","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"MessyCode","slug":"MessyCode","permalink":"http://yoursite.com/tags/MessyCode/"}]},{"title":"Chatroom 简介","slug":"Chatroom/Chatroom 简介","date":"2020-01-31T04:16:27.000Z","updated":"2020-04-19T06:25:00.977Z","comments":true,"path":"2020/01/31/Chatroom/Chatroom 简介/","link":"","permalink":"http://yoursite.com/2020/01/31/Chatroom/Chatroom%20%E7%AE%80%E4%BB%8B/","excerpt":"一个网页版的线上聊天室","text":"一个网页版的线上聊天室 项目基本思路此项目以 Tomcat 作为核心服务器用于处理客户登录、个人信息管理等 HTTP 类型的请求，端口号：8080。 在 Tomcat 服务器中另开一个线程启动 Netty WebSocket 服务器用于处理用户消息通信的 WebSocket 类型的请求，端口号：3333。 用户登录后： Tomcat 服务器会返回用户的个人信息，同时更新记录在线用户，根据用户 id 建立一条 WebSocket 连接并保存在后端以便进行实时通信。 浏览器将维持一个 Session 对象来保持登录状态（30 min）。 用户与用户进行通信： 服务器根据收到的消息内容中的对话方的用户 id 找到保存的 WebSocket 连接，通过该连接发送消息。 用户退出： 释放用户的 WebSocket 连接。 清空用户在 Session 对象中的登陆状态。 系统功能模块登录模块：用户登录、用户注销。 聊天管理模块：单条消息发送、群组消息发送。（消息：文本、文件）","categories":[{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"}],"tags":[{"name":"Chatroom","slug":"Chatroom","permalink":"http://yoursite.com/tags/Chatroom/"}]},{"title":"Maven 安装和配置","slug":"Software/Maven 的安装和配置","date":"2020-01-30T06:36:59.000Z","updated":"2020-04-19T06:41:37.312Z","comments":true,"path":"2020/01/30/Software/Maven 的安装和配置/","link":"","permalink":"http://yoursite.com/2020/01/30/Software/Maven%20%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。","text":"Maven 是一个项目管理工具，可以对 Java 项目进行构建、依赖管理。 Maven 的安装Maven 下载地址：Maven 下载 3..6.x 版本会有莫名其妙的报错，建议使用 3.5.x 版本 解压后进行环境变量的配置：M2_HOME、%M2_HOME%\\bin。 在 cmd 窗口下输入mvn -v显示 Maven 版本即配置成功。 修改配置文件目录：…apache-maven-3.6.3\\conf\\settings.xml 本地仓库位置的修改在&lt;localRepository&gt;标签内添加自己的本地位置路径。 修改默认的 JDK 版本123456789101112&lt;profile&gt; &lt;id&gt;JDK-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; 添加国内镜像源1234567891011121314151617181920212223&lt;!-- 阿里云仓库 --&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库1 --&gt;&lt;mirror&gt; &lt;id&gt;repo1&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt;&lt;!-- 中央仓库2 --&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; IDEA 中配置 Maven","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"}]},{"title":"IDEA 安装与配置","slug":"Software/IDEA 安装与配置","date":"2020-01-29T08:25:01.000Z","updated":"2020-04-19T06:41:32.058Z","comments":true,"path":"2020/01/29/Software/IDEA 安装与配置/","link":"","permalink":"http://yoursite.com/2020/01/29/Software/IDEA%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一。让我们来了解一下这款编辑器，并且进行一定的配置。","text":"IDEA 全称 IntelliJ IDEA，是java语言开发的集成环境，IntelliJ在业界被公认为最好的java开发工具之一。让我们来了解一下这款编辑器，并且进行一定的配置。 IDEA 安装与破解下载 IDEA，链接：https://share.weiyun.com/50wrg7G 下载破解补丁，链接：https://share.weiyun.com/5kRW75Z 安装软件 （全部默认就行，小编安装在 D 盘的根目录），安装好后将破解补丁复制到 \\IntelliJ IDEA 2019.1.4\\bin\\ 目录下，在 bin 目录下分别找到 idea.exe.vmoptions 和 idea64.exe.vmoptions，在末尾添加-javaagent:安装目录下的\\IntelliJ IDEA 2019.1.3\\bin\\jetbrains-agent.jar后保存。 打开 IDEA，选择使用（Evaluate for free），选择 Configure - Edit Custom VM Options，在弹出的窗口确定末尾是刚刚修改的参数 -javaagent:D:\\IntelliJ IDEA 2019.1.4\\bin\\jetbrains-agent.jar （如果提示创建，选择是，在末尾再添加上面的参数）。 选择 Manage License， License Server 填写http://jetbrains-license-server，点击 Activate。重启你的 IDEA ,查看是否已经破解成功。 IDEA 模块在 Eclipse 中我们有 Workspace（工作空间）和 Project（工程）的概念，在 IDEA 中只有 Project（工程）和 Module（模块）的概念。 Eclipse IDEA Workspace Project Project Module IntelliJ IDEA 是无法在同一个窗口管理 n 个项目。 IntelliJ IDEA 提供的解决方案是打开多个项目实例，即打开多个项目窗口。 即： 一个 Project 打开一个 Window 窗口。 在 IntelliJ IDEA 中 Project 是最顶级的级别，次级别是 Module。一个 Project 可以有多个 Module。目前主流的大型项目都是分布式部署的， 结构都是类似这种多 Module 结构。 IDEA 配置View：Toolbar [√] 设置主题下载喜欢的 IDEA 的主题，下载地址：themesmap File：Import setting 选中下载的主题导入后提示重启，等待重启完成 Editor General Mouse：Change font size(Zoom) with Ctrl+Mouse Whee Other：Show quick documentation on mouse move Auto Import Java： appearance：Show method separators Code Completion：Match case [×] Editor Tabs：Show tabs in one row [×] Font：Size File and Code Templates 1234/**@author Wingo@create $&#123;YEAR&#125;-$&#123;MONTH&#125;-$&#123;DAY&#125; $&#123;TIME&#125;*/ File Encoding： Properties Files：UTF-8 [√] 快捷键设置KeyMap：Eclipse Eclipse 常用快捷键 执行 (run) alt+r 提示补全 (Class Name Completion) alt+/ 单行注释 ctrl + / 多行注释 ctrl + shift + / 向下复制一行 (Duplicate Lines) ctrl+alt+down 删除一行或选中行 (delete line) ctrl+d 向下移动行 (move statement down) alt+down 向上移动行 (move statement up) alt+up 向下开始新的一行 (start new line) shift+enter 向上开始新的一行 (Start New Line before current) ctrl+shift+enter 如何查看源码 (class) ctrl + 选中指定的结构 / ctrl + shift + t 万能解错 / 生成返回值变量 alt + enter 退回到前一个编辑的页面 (back) alt + left 进入到下一个编辑的页面 ( 针对于上条 ) (forward) alt + right 查看继承关系 (type hierarchy) F4 格式化代码 (reformat code) ctrl+shift+F 提示方法参数类型 (Parameter Info) ctrl+alt+/ 复制代码 ctrl + c 撤销 ctrl + z 反撤销 ctrl + y 查看类的结构：类似于 eclipse 的 outline ctrl+o 重构： 修改变量名与方法名 (rename) alt+shift+r 大写转小写 / 小写转大写 (toggle case) ctrl+shift+y 生成构造器/get/set/toString alt +shift + s 查看文档说明(quick documentation) F2 生成 try-catch 等(surround with) alt+shift+z 局部变量抽取为成员变量(introduce field) alt+shift+f 查找/替换(当前) ctrl+f 查找(全局) ctrl+h 查找文件 double Shift 查看类的继承结构图(Show UML Diagram) ctrl + shift + u 查看方法的多层重写结构(method hierarchy) ctrl+alt+h 抽取方法(Extract Method) alt+shift+m 关闭当前打开的代码栏(close) ctrl + w 关闭打开的所有代码栏(close all) ctrl + shift + w 快速搜索类中的错误(next highlighted error) ctrl + shift + q 查找方法在哪里被调用(Call Hierarchy) ctrl+shift+h 关于模板Editor &gt; General &gt; Postfix Completion Editor &gt; Live Templates（可自定义） 修改当行注解风格打开 idea 的设置，依次点击「Editor」——「Code Style」——「Java」——「Code Generation」，然后取消勾选 Line comment at first column，同时勾选 Add a space at comment start","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}]},{"title":"Hexo 安装与配置","slug":"Software/Hexo 安装与配置","date":"2020-01-29T04:59:01.000Z","updated":"2020-04-19T06:41:25.577Z","comments":true,"path":"2020/01/29/Software/Hexo 安装与配置/","link":"","permalink":"http://yoursite.com/2020/01/29/Software/Hexo%20%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/","excerpt":"Hexo 介绍Hexo 是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。","text":"Hexo 介绍Hexo 是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.io GitHub 搭建工作仓库搭建Hexo 是基于 GitHub 的，首先你需要有一个 GitHub 的账号，并且创建一个用于存放博客的静态文件的仓库。这个仓库的名称必须是[username].github.io，之后你便可以用http://[username].github.io访问你搭建的博客。 域名绑定在云平台购买自己喜欢的域名，并且在平台的控制台进行域名的绑定。 打开控制台ping http://[username].github.io，得到 IP 地址。 然后到你的域名 DNS 设置页，将 A 记录指向你 ping 出来的 IP，将 CNAME 指向[username].github.io，这样可以保证无论是否添加 www 都可以访问。 CNAME 文件：创建一个 CNAME ，在其中输入你的域名，保存后放置在你的 theme 目录下的 resource 目录下 配置 SSH Key到 Github 官网下载客户端，右键选择 git bash here。输入 cd ~/.ssh 检查本机是否已经存在 SSH 密钥。 若显示 No such file or directory 则说明本机还未创建 SSH 密钥。 输入ssh-keygen -t rsa -C &quot;[email]&quot;，并连续回车直到提示密钥生成成功。 输入cd ~/.ssh，然后输入ls即可看到此目录下生成的公钥（pub）和私钥。利用cat命令取得公钥的内容，并且复制公钥内容，粘贴到 GitHub 的 Settings 中的 SSH Keys 中（名称自定义即可）。 输入ssh -T git@github.com，输入 yes 后若提示连接成功则 SSH Key 配置成功。 此外，你还需要输入git config --global user.name &quot;[username]&quot;和git config --global user.email &quot;[email]&quot;进行配置。（局部配置时不加 --global） 多个 SSH Key为了区别个人 / 公司的代码仓库，公司的代码仓库的邮件生成一个新的 SSH Key，为避免之前的创建的 id_rsa 被覆盖，此次创建需要显示的重命名文件 id_rsa_welab。 得到公钥并且复制到公司用户后，进行项目克隆时报错，排查后发现此 id_rsa_welab 非默认命名，故需要手动添加到 ssh-agent 中（需手动开启）。 12# 开启 ssh-agent !!! 注意 是 ~ 下面的 ``，不是 ''eval `ssh-agent` 输入 ssh-add [path]命令。 添加后即可成功克隆项目。 Hexo 安装首先要安装 Node.js，然后利用 npm 安装 Hexo。 右键选择 git bash here。输入npm install -g Hexo，等待下载完成。 输入 cd [blog catalogue]，到你放置 Blog 文件的目录下，输入hexo init初始化 Hexo 文件。 输入 hexo generate回车，hexo server回车，浏览器输入localhost:4000即可看到博客页面 常用命令1234hexo cleanhexo generatehexo serverhexo deploy 主题更换见：[hexo-theme-indigo]","categories":[{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"}]},{"title":"Netty 引导","slug":"Netty/Netty 入门/Netty 引导","date":"2020-01-25T16:25:24.000Z","updated":"2020-04-19T06:31:12.172Z","comments":true,"path":"2020/01/26/Netty/Netty 入门/Netty 引导/","link":"","permalink":"http://yoursite.com/2020/01/26/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20%E5%BC%95%E5%AF%BC/","excerpt":"引导一个应用程序是指对它进行配置，并使它运行起来的过程。Netty处理引导的方式使你的应用程序和网络层相隔离，无论它是客户端还是服务器。所有的框架组件都将会在后台结合在 一起并且启用。","text":"引导一个应用程序是指对它进行配置，并使它运行起来的过程。Netty处理引导的方式使你的应用程序和网络层相隔离，无论它是客户端还是服务器。所有的框架组件都将会在后台结合在 一起并且启用。 Bootstrap 类引导类的层次结构包括一个抽象的父类和两个具体的引导子类。 相对于将具体的引导类分别看作用于服务器和客户端的引导来说，记住它们的本意是用来支 撑不同的应用程序的功能。也就是说，服务器致力于使用一个父 Channel 来接受来自客户端的连接，并创建子 Channel 以用于它们之间的通信；而客户端将最可能只需要一个单独的、没有父 Channel 的 Channel 来用于所有的网络交互。 为什么引导类是 Cloneable 的： 你有时可能会需要创建多个具有类似配置或者完全相同配置的Channel。为了支持这种模式而又不需要为每个 Channel 都创建并配置一个新的引导类实例， AbstractBootstrap 被标记为了 Cloneable。 注意，这种方式只会创建引导类实例的 EventLoopGroup 的一个浅拷贝，所以，后者将在所有克隆的 Channel 实例之间共享。这是可以接受的，因为通常这些克隆的 Channel 的生命周期都很短暂，一个典型的场景是：创建一个 Channel 以进行一次HTTP请求。 引导客户端Bootstrap 类负责为客户端和使用无连接协议的应用程序创建 Channel。 12345678910111213141516171819202122232425262728293031323334// 引导一个客户端EventLoopGroup group = new NioEventLoopGroup();// 创建一个 Bootstrap 类的实例用来创建和连接新的客户端 ChannelBootstrap bootstrap = new Bootstrap();// 设置 EventLoopGroup 提供用于处理 Channel 事件的 EventLoopbootstrap.group(group) // 指定要使用的 Channel 实现 .channel(NioSocketChannel.class) .handler( // 设置用于 Channel 事件和数据的 ChannelInboundHandler new SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123; @Override protected void channeRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception &#123; System.out.println(\"Received data\"); &#125; &#125; );ChannelFuture future = bootstrap.connect( // 连接到远程主机 new InetSocketAddress(\"www.manning.com\", 80));future.addListener( new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if (channelFuture.isSuccess()) &#123; System.out.println(\"Connection established\"); &#125; else &#123; System.err.println(\"Connection attempt failed\"); channelFuture.cause().printStackTrace(); &#125; &#125; &#125; ); 引导服务器负责引导 ServerChannel 的 ServerBootstrap 提供了负责创建子 Channel 的方法 childXxx()，这些子 Channel 代表了已被接收的连接。 1234567891011121314151617181920212223242526272829// 引导服务器NioEventLoopGroup group = new NioEventLoopGroup();ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(group) .channel(NioServerSocketChannel.class) // 子线程 .childHandler( new SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf byteBuf) throws Exception &#123; System.out.println(\"Received data\"); &#125; &#125; );// 监听端口ChannelFuture future = bootstrap.bind(new InetSocketAddress(8080));future.addListener( new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if (channelFuture.isSuccess()) &#123; System.out.println(\"Server bound\"); &#125; else &#123; System.err.println(\"Bound attempt failed\"); channelFuture.cause().printStackTrace(); &#125; &#125; &#125; ); 从 Channel 引导客户端假设你的服务器正在处理一个客户端的请求，这个请求需要它充当第三方系统的客户端。 1234567891011121314151617181920212223242526272829303132333435ServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(new NioEventLoopGroup(), new NioEventLoopGroup()) .channel(NioServerSocketChannel.class) .childHandler( new SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123; ChannelFuture connectFuture; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; Bootstrap bootstrap = new Bootstrap(); bootstrap.channel(NioSocketChannel.class).handler( new SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf in) throws Exception &#123; System.out.println(\"Received data\"); &#125; &#125; ); // 使用与分配给已被接受的子 Channel 相同的 EventLoop bootstrap.group(ctx.channel().eventLoop()); connectFuture = bootstrap.connect( new InetSocketAddress(\"www.manning.com\", 80)); &#125; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception &#123; if (connectFuture.isDone()) &#123; // do something with the data &#125; &#125; &#125; );ChannelFuture future = bootstrap.bind(new InetSocketAddress(8080));future.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture)throws Exception &#123; if (channelFuture.isSuccess()) &#123; System.out.println(\"Server bound\"); &#125; else &#123; System.err.println(\"Bind attempt failed\"); channelFuture.cause().printStackTrace(); &#125; &#125; &#125; ); 尽可能地重用 EventLoop，以减少线程创建所带来的开销。 在引导过程中添加多个 ChannelHandler在前面的几个例子中，在引导的过程中调用了 handler() 或者 childHandler() 方法来添加单个的 ChannelHandler。这对于简单的应用程序来说可能已经足够了，但是它不能满足更加复杂的需求。 protected abstract void initChannel(C ch) throws Exception; 这个方法提供了一种将多个 ChannelHandler 添加到一个 ChannelPipeline 中的简便方法 12345678910111213141516// 引导和使用 ChannelInitializerServerBootstrap bootstrap = new ServerBootstrap();bootstrap.group(new NioEventLoopGroup(), new NioEventLoopGroup()) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializerImpl());ChannelFuture future = bootstrap.bind(new InetSocketAddress(8080));future.sync();// ChannelInitializer 的实现final class ChannelInitializerImpl extends ChannelInitializer&lt;Channel&gt; &#123; @Override protected void initChannel(Channel ch) throws Exception &#123; ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new HttpClientCodec()); pipeline.addLast(new HttpObjectAggregator(Integer.MAX_VALUE)); &#125; &#125; 如果你的应用程序使用了多个 ChannelHandler，请定义你自己的 ChannelInitializer 实现来将它们安装到 ChannelPipeline 中。 ChannelOption 和属性你可以使用 option() 方法来将 ChannelOption 应用到引导。你所提供的值将会被自动应用到引导所创建的所有 Channel。可用的 ChannelOption 包括了底层连接的详细信息，如 keep-alive 或者超时属性以及缓冲区设置。 Netty 提供了 AttributeMap 抽象（一个由 Channel 和引导类提供的集合）以及 AttributeKey（一 个用于插入和获取属性值的泛型类）。使用这些工具，便可以安全地将任何类型的数据项与客户端和服务器 Channel（包含 ServerChannel 的子 Channel）相关联了。 123456789101112131415161718192021222324252627// 使用属性值// 创建一个 AttributeKey 以标识该属性final AttributeKey&lt;Integer&gt; id = new AttributeKey&lt;Integer&gt;(\"ID\");Bootstrap bootstrap = new Bootstrap();bootstrap.group(new NioEventLoopGroup()) .channel(NioSocketChannel.class) .handler( new SimpleChannelInboundHandler&lt;ByteBuf&gt;() &#123; @Override public void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123; // 使用 AttributeKey 检索属性以及它的值 Integer idValue = ctx.channel().attr(id).get(); // do something with the idValue &#125; @Override protected void channelRead0(ChannelHandlerContext channelHandlerContext, ByteBuf byteBuf) throws Exception &#123; System.out.println(\"Received data\"); &#125; &#125; );// 引导的每一个 Channel 都将具有这些属性bootstrap.option(ChannelOption.SO_KEEPALIVE,true) .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 5000);// 存储该 id 属性bootstrap.attr(id, 123456);ChannelFuture future = bootstrap.connect(new InetSocketAddress(\"www.manning.com\", 80));future.syncUninterruptibly(); 引导 DatagramChannel除了基于 TCP 协议的 SocketChannel，Bootstrap 类也可以被用于无连接协议。为此。Netty 提供了各种 DatagramChannel 的实现。唯一区别就是，不再调用 connect() 方法，而是只调用 bind() 方法。 1234567891011121314151617181920212223242526// 使用 Bootstrap 和 DatagramChannelBootstrap bootstrap = new Bootstrap();bootstrap.group(new OioEventLoopGroup()) .channel(OioDatagramChannel.class) .handler( new SimpleChannelInboundHandler&lt;DatagramPacket&gt;()&#123; @Override public void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) throws Exception &#123; // Do something with the packet &#125; &#125; );// 调用 bind() 方法，因为该协议是无连接的ChannelFuture future = bootstrap.bind(new InetSocketAddress(0));future.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture channelFuture) throws Exception &#123; if (channelFuture.isSuccess()) &#123; System.out.println(\"Channel bound\"); &#125; else &#123; System.err.println(\"Bind attempt failed\"); channelFuture.cause().printStackTrace(); &#125; &#125;&#125;); 关闭引导使你的应用程序启动并且运行起来，但是迟早你都需要优雅地将它关闭。 123456789// 优雅的关闭EventLoopGroup group = new NioEventLoopGroup();Bootstrap bootstrap = new Bootstrap();bootstrap.group(group) .channel(NioSocketChannel.class);...;Future&lt;?&gt; future = group.shutdownGracefully();// block until the group has shutdownfuture.syncUninterruptibly(); 注意，shutdownGracefully() 方法也是一个异步的操作，所以你需要阻塞等待直到它完成，或者向所返回的 Future 注册一个监听器以在关闭完成时获得通知。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Netty EventLoop 和线程模型","slug":"Netty/Netty 入门/Netty EventLoop 和线程模型","date":"2020-01-25T08:09:20.000Z","updated":"2020-04-19T06:32:52.820Z","comments":true,"path":"2020/01/25/Netty/Netty 入门/Netty EventLoop 和线程模型/","link":"","permalink":"http://yoursite.com/2020/01/25/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20EventLoop%20%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"线程模型指定了操作系统、编程语言、框架或者应用程序的上下文中的线程管理的关键方面，如何以及何时创建线程将对应用程序代码的执行产生显著的影响。","text":"线程模型指定了操作系统、编程语言、框架或者应用程序的上下文中的线程管理的关键方面，如何以及何时创建线程将对应用程序代码的执行产生显著的影响。 线程模型概述多核心或多个 CPU 的计算机现在已经司空见惯，大多数的现代应用程序都利用了 复杂的多线程处理技术以有效地利用系统资源。 在早期的 Java 语言中，我们使用多线程处理的主要方式无非是按需创建和启动新的 Thread 来执行并发的任务单元，这是一种在高负载下工作得很差的原始方式。Java 5 随后引入了 Executor API，其线程池通过缓存和重用 Thread 极大地提高了性能。 虽然池化和重用线程相对于简单地为每个任务都创建和销毁线程是一种进步，但是它并不能 消除由上下文切换所带来的开销，其将随着线程数量的增加很快变得明显，并且在高负载下愈演愈烈。Netty 框架帮助简化了这一处理。 EventLoop 接口运行任务来处理在连接的生命周期内发生的事件是任何网络框架的基本功能。与之相应的编程上的构造通常被称为事件循环：Netty 使用了 interface io.netty.channel.EventLoop 来适配的术语。 1234567// 在事件循环中执行任务while (!terminated) &#123; List&lt;Runnable&gt; readyEvents = blockUntilEventsReady(); for (Runnable ev: readyEvents) &#123; ev.run(); &#125; &#125; Netty 的 EventLoop 是协同设计的一部分，它采用了两个基本的 API：并发和网络编程。首先，io.netty.util.concurrent 包构建在 JDK 的 java.util.concurrent 包上，用来提供线程执行器。其次，io.netty.channel 包中的类，为了与 Channel 的事件进行交互，扩展了这些接口/类。 在这个模型中，一个 EventLoop 将由一个永远都不会改变的 Thread 驱动，同时任务 （Runnable 或者 Callable）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。根据配置和可用核心的不同，可能会创建多个 EventLoop 实例用以优化资源的使用，并且单个 EventLoop 可能会被指派用于服务多个 Channel。 事件/任务的执行顺序 ： 事件和任务是以先进先出（FIFO）的顺序执行的。这样可以通过保证字节内容总是按正确的顺序被处理，消除潜在的数据损坏的可能性。 任务调度使用核心的 Java API 和 Netty 的 EventLoop 来调度任务 JDK 的任务调度 API123456789101112// 使用 ScheduledExecutorService 来在 60 秒的延迟之后执行一个任务ScheduledExecutorService executor = Executors.newScheduledThreadPool(10);ScheduledFuture&lt;?&gt; future = executor.schedule( new Runnable() &#123; @Override public void run() &#123; System.out.println(\"60 seconds later\"); &#125; &#125;, 60, TimeUnit.SECONDS); // 调度任务在从现在开始的 60 秒之后执行...;executor.shutdown(); 使用 EventLoop 调度任务12345678910// 使用 EventLoop 来在 60 秒的延迟之后执行一个任务Channel ch = ...;ScheduledFuture&lt;?&gt; future = ch.eventLoop().schedule( new Runnable() &#123; @Override public void run() &#123; System.out.println(\"60 seconds later\"); &#125; &#125;, 60, TimeUnit.SECONDS); 123456789101112// 使用 EventLoop 调度周期性的任务Channel ch = ...;ScheduledFuture&lt;?&gt; future = ch.eventLoop().scheduleAtFixedRate( new Runnable() &#123; @Override public void run() &#123; System.out.println(\"Run every 60 seconds\"); &#125; &#125;, 60, 60, TimeUnit.Seconds);// 利用每个异步操作所返回的 ScheduledFuture 取消任务future.cancel(false); 实现细节更加详细地探讨 Netty 的线程模型和任务调度实现的主要内容。 线程管理Netty 线程模型的卓越性能取决于对于当前执行的 Thread 的身份的确定。 永远不要将一个长时间运行的任务放入到执行队列中，因为它将阻塞需要在同一线程上执行的任何其他任务。如果必须要进行阻塞调用或者执行长时间运行的任务，我们建议使用一个专门的 EventExecutor。 EventLoop / 线程的分配服务于 Channel 的 I/O 和事件的 EventLoop 包含在 EventLoopGroup 中。根据不同的传输实现，EventLoop 的创建和分配方式也不同。 异步传输异步传输实现只使用了少量的 EventLoop（以及和它们相关联的 Thread），而且在当前的线程模型中，它们可能会被多个 Channel 所共享。这使得可以通过尽可能少量的 Thread 来支撑大量的 Channel，而不是每个 Channel 分配一个 Thread。 一旦一个 Channel 被分配给一个 EventLoop，它将在它的整个生命周期中都使用这个 EventLoop（以及相关联的 Thread）。 阻塞传输这里每一个 Channel 都将被分配给一个 EventLoop（以及它的 Thread）。 每个 Channel 的 I/O 事件都将只会被一个 Thread （用于支撑该 Channel 的 EventLoop 的那个 Thread）处理（Netty 的一致性体现）。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Netty ChannelHandler 和 ChannelPipeline","slug":"Netty/Netty 入门/Netty ChannelHandler 和 ChannelPipeline","date":"2020-01-24T14:09:35.000Z","updated":"2020-04-19T06:32:46.172Z","comments":true,"path":"2020/01/24/Netty/Netty 入门/Netty ChannelHandler 和 ChannelPipeline/","link":"","permalink":"http://yoursite.com/2020/01/24/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20ChannelHandler%20%E5%92%8C%20ChannelPipeline/","excerpt":"ChannelPipeline 中将 ChannelHandler 链接在一起以组织处理逻辑，还有一个重要的关系 ChannelHandlerContext。","text":"ChannelPipeline 中将 ChannelHandler 链接在一起以组织处理逻辑，还有一个重要的关系 ChannelHandlerContext。 ChannelHandler 家族Channel 的生命周期当 Channel 的状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应。 ChannelHandler 的生命周期 类型 描述 handlerAdded 当把 ChannelHandler 添加到 ChannelPipeline 中时被调用 handlerRemoved 当从 ChannelPipeline 中移除 ChannelHandler 时被调用 exceptionCaught 当处理过程中在 ChannelPipeline 中有错误产生时被调用 Netty 定义了两个重要的 Channelhandler 子接口： ChannelInboundHandler——处理入站数据以及各种状态变化； ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作。 ChannelInboundHandler 接口12345678910// 释放消息资源@Sharable// 扩展了 ChannelInboundHandlerAdapterpublic class DiscardHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; // 丢弃已接收的消息 ReferenceCountUtil.release(msg); &#125; &#125; 123456789// 使用 SimpleChannelInboundHandler 会自动释放资源@Sharablepublic class SimpleDiscardHandler extends SimpleChannelInboundHandler&lt;Object&gt; &#123; @Override public void channelRead0(ChannelHandlerContext ctx, Object msg) &#123; // 不需要任何显式的资源释放 // No need to do anything special &#125; &#125; ChannelOutboundHandler 接口ChannelOutboundHandler 的一个强大的功能是可以按需推迟操作或者事件，这使得可 以通过一些复杂的方法来处理请求。 ChannelPromise 与 ChannelFuture：ChannelOutboundHandler 中的大部分方法都需要一个 ChannelPromise 参数，以便在操作完成时得到通知。ChannelPromise 是 ChannelFuture 的一个子类，其定义了一些可写的方法，如 setSuccess() 和 setFailure()，从而使 ChannelFuture 不可变。 ChannelHandler 适配器适配器对 ChannelHandler 进行了简单的实现，只需要简单地扩展它们，并且重写那些你想要自定义的方法。 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 中所提供的方法体调用了其相关联的 ChannelHandlerContext 上的等效方法，从而将事件转发到了 ChannelPipeline 中的下一个 ChannelHandler 中。 资源管理每当通过调用 ChannelInboundHandler.channelRead() 或者 ChannelOutboundHandler.write() 方法来处理数据时，你都需要确保没有任何的资源泄漏。 Netty 使用引用计数来处理池化的 ByteBuf。所以在完全使用完某个 ByteBuf 后，调整其引用计数是很重要的。 123456789101112// 丢弃并释放出战消息@Sharablepublic class DiscardOutboundHandler extends ChannelOutboundHandlerAdapter &#123; @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123; // 释放资源 ReferenceCountUtil.release(msg); // 通知 ChannelPromise 数据已经被处理了 promise.setSuccess(); &#125;&#125; 重要的是，不仅要释放资源，还要通知 ChannelPromise。否则可能会出现 ChannelFutureListener 收不到某个消息已经被处理了的通知的情况。 如果一个消息被消费或者丢弃了，并且没有传递给 ChannelPipeline 中的下一个 ChannelOutboundHandler，那么用户就有责任调用 ReferenceCountUtil.release()。 ChannelPipeline 接口每一个新创建的 Channel 都将会被分配一个新的 ChannelPipeline。这项关联是永久性的；Channel 既不能附加另外一个 ChannelPipeline，也不能分离其当前的。 根据事件的起源，事件将会被 ChannelInboundHandler 或者 ChannelOutboundHandler 处理。随后，通过调用 ChannelHandlerContext 实现，它将被转发给同一超类型的下一个 ChannelHandler。 修改 ChannelPipelineChannelHandler 可以通过添加 addXxx()、删除 remove() 或者替换 replace() 其他的 ChannelHandler 来实时地修改 ChannelPipeline 的布局。 ChannelHandler 的执行和阻塞 通常 ChannelPipeline 中的每一个 ChannelHandler 都是通过它的 EventLoop（I/O 线程）来处理传递给它的事件的。所以至关重要的是不要阻塞这个线程，因为这会对整体的 I/O 处理产生负面的影响。 但有时可能需要与那些使用阻塞 API 的遗留代码进行交互。对于这种情况，ChannelPipeline 有一些接受一个 EventExecutorGroup 的 add()方法。如果一个事件被传递给一个自定义的 EventExecutorGroup，它将被包含在这个 EventExecutorGroup 中的某个 EventExecutor 所处理，从而被从该 Channel 本身的 EventLoop 中移除。对于这种用例，Netty 提供了一个叫 DefaultEventExecutorGroup 的默认实现。 getXxx()：通过类型或者名称来访问 ChannelHandler 的方法。 context()：返回和 ChannelHandler 绑定的 ChannelHandlerContext。 names()：返回 ChannelPipeline 中所有 ChannelHandler 的名称。 触发事件ChannelPipeline 的 API 公开了用于调用入站和出站操作的附加方法。 小结 ChannelPipeline 保存了与 Channel 相关联的 ChannelHandler； ChannelPipeline 可以根据需要，通过添加或者删除 ChannelHandler 来动态地修改； ChannelPipeline 有着丰富的 API 用以被调用，以响应入站和出站事件。 ChannelHandlerContext 接口ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext。 ChannelHandlerContext 的主要功能是管理它所关联的 ChannelHandler 和在同一个 ChannelPipeline 中的其他 ChannelHandler 之间的交互。 ChannelHandlerContext 和 ChannelHandler 之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的； 使用 ChannelHandlerContextChannel、ChannelPipeline、ChannelHandler 以及 ChannelHandlerContext 之间的关系 1234// 从 ChannelHandlerContext 访问 ChannelChannelHandlerContext ctx = ..;Channel channel = ctx.channel();channel.write(Unpooled.copiedBuffer(\"Netty in Action\", CharsetUtil.UTF_8)); 1234// 通过 ChannelHandlerContext 访问 ChannelPipelineChannelHandlerContext ctx = ..;ChannelPipeline pipeline = ctx.pipeline();pipeline.write(Unpooled.copiedBuffer(\"Netty in Action\", CharsetUtil.UTF_8)); 重要的是要注意到，虽然被调用的 Channel 或 ChannelPipeline 上的 write()方法将一直传播事件通 过整个 ChannelPipeline，但是在 ChannelHandler 的级别上，事件从一个 ChannelHandler 到下一个 ChannelHandler 的移动是由 ChannelHandlerContext 上的调用完成的. 1234// 调用 ChannelHandlerContext 的 write()方法ChannelHandlerContext ctx = ..;// write()方法将把缓冲区数据发送到下一个 ChannelHandlerctx.write(Unpooled.copiedBuffer(\"Netty in Action\", CharsetUtil.UTF_8)); 高级用法缓存 ChannelHandlerContext 的引用以供稍后使用，这可能会发生在任何的 ChannelHandler 方法之外，甚至来自于不同的线程。 12345678910111213// 缓存到 ChannelHandlerContext 的引用public class WriteHandler extends ChannelHandlerAdapter &#123; private ChannelHandlerContext ctx; @Override public void handlerAdded(ChannelHandlerContext ctx) &#123; //存储到 ChannelHandlerContext 的引用以供稍后使用 this.ctx = ctx; &#125; public void send(String msg) &#123; // 使用之前存储的到 ChannelHandlerContext 的引用来发送消息 ctx.writeAndFlush(msg); &#125; &#125; 因为一个 ChannelHandler 可以从属于多个 ChannelPipeline，所以它也可以绑定到多个 ChannelHandlerContext 实例。对于这种用法指在多个 ChannelPipeline 中共享同一 个 ChannelHandler，对应的 ChannelHandler 必须要使用 @Sharable 注解标注；否则， 试图将它添加到多个 ChannelPipeline 时将会触发异常。显而易见，为了安全地被用于多个 并发的 Channel（即连接），这样的 ChannelHandler 必须是线程安全的。 123456789// 可共享的 ChannelHandler@Sharable public class SharableHandler extends ChannelInboundHandlerAdapter &#123; @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; System.out.println(\"Channel read message: \" + msg); ctx.fireChannelRead(msg); &#125; &#125; 异常处理Netty 提供了几种方式用于处理入站或者出站处理过程中所抛出的异常。 处理入站异常12345678// 基本的入站异常处理public class InboundExceptionHandler extends ChannelInboundHandlerAdapter &#123; @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125; &#125; 处理出站异常出站的异常处理基于一下通知机制： 每个出站操作都将返回一个 ChannelFuture。注册到 ChannelFuture 的 ChannelFutureListener 将在操作完成时被通知该操作是成功了还是出错了。 几乎所有的 ChannelOutboundHandler 上的方法都会传入一个 ChannelPromise 的实例。作为 ChannelFuture 的子类，ChannelPromise 也可以被分配用于异步通知的监听器。但是，ChannelPromise 还具有提供立即通知的可写方法。 ChannelPromise 的可写方法 通过调用 ChannelPromise 上的 setSuccess() 和 setFailure() 方法，可以使一个操作的状态在 ChannelHandler 的方法返回给其调用者时便即刻被感知到。 12345678910// 添加 ChannelFutureListener 到 ChannelFutureChannelFuture future = channel.write(someMessage);future.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture f) &#123; if (!f.isSuccess()) &#123; f.cause().printStackTrace(); f.channel().close(); &#125; &#125;&#125;); 123456789101112131415// 添加 ChannelFutureListener 到 ChannelPromisepublic class OutboundExceptionHandler extends ChannelOutboundHandlerAdapter &#123; @Override public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123; promise.addListener(new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture f) &#123; if (!f.isSuccess()) &#123; f.cause().printStackTrace(); f.channel().close(); &#125; &#125; &#125;); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Netty ByteBuf","slug":"Netty/Netty 入门/Netty ByteBuf","date":"2020-01-24T03:29:09.000Z","updated":"2020-04-19T06:32:38.747Z","comments":true,"path":"2020/01/24/Netty/Netty 入门/Netty ByteBuf/","link":"","permalink":"http://yoursite.com/2020/01/24/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20ByteBuf/","excerpt":"总所周知，网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。因此，Netty 提供了一个替代品 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。","text":"总所周知，网络数据的基本单位总是字节。Java NIO 提供了 ByteBuffer 作为它的字节容器，但是这个类使用起来过于复杂，而且也有些繁琐。因此，Netty 提供了一个替代品 ByteBuf，一个强大的实现，既解决了 JDK API 的局限性，又为网络应用程序的开发者提供了更好的 API。 ByteBuf 的 APINetty 的数据处理 API 通过两个组件暴露：abstract class ByteBuf 和 interface ByteBufHolder。 ByteBuf 类ByteBuf 类是 Netty 的数据容器，通过使用不同的索引来简化对它所包含的数据的访问。 HowByteBuf 维护了两个不同的索引：一个用于读取，一个用于写入。读取时，readerIndex 将会被递增已经被读取的字节数；写入时，writerIndex 也会被递增。readerIndex == writerIndex 时则到达可读取数据的末尾。 名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或者 get 开头的操作则不会。后面的这些方法将在作为一个参数传入的一个相对索引上执行操作。 Mode在使用 Netty 时，有几种常见的围绕 ByteBuf 而构建的使用模式。 堆缓冲区最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组。 12345678910111213// 支撑数组ByteBuf heapBuf = ...;// 检查 ByteBuf 是否有一个支撑数组if (heapBuf.hasArray()) &#123; // 获取对该数组的引用 byte[] array = heapBuf.array(); // 计算第一个字节的偏移量 int offset = heapBuf.arrayOffset() + heapBuf.readerIndex(); // 获取可读字节数 int length = heapBuf.readableBytes(); // 使用获取的信息作为参数调用自定义方法 handleArray(array, offset, length);&#125; 直接缓冲区（Updating）复合缓冲器（Updating）字节级操作ByteBuf 提供了许多超出基本读、写操作的方法用于修改它的数据。 随机访问索引123456// 访问数据ByteBuf buffer = ...;for (int i = 0; i &lt; buffer.capacity(); i++) &#123; byte b = buffer.getByte(i); System.out.println((char)b);&#125; 顺序访问索引虽然 ByteBuf 同时具有读索引和写索引，但是 JDK 的 ByteBuffer 却只有一个索引，这也就是为什么必须调用 flip() 方法来在读模式和写模式之间进行切换的原因 ByteBuf 的内部分段 可丢弃字节可丢弃字节的分段包含了已经被读过的字节。通过调用 discardReadBytes() 方法，可以丢弃它们并回收空间。这个分段的初始大小为 0，存储在 readerIndex 中，会随着 read 操作的执行而增加（get*操作不会移动 readerIndex）。 可读字节ByteBuf 的可读字节分段存储了实际数据。 12345// 读取所有数据ByteBuf buffer = ...;while (buffer.isReadable()) &#123; System.out.println(buffer.readByte());&#125; 可写字节可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域。 12345// 写数据ByteBuf buffer = ...;while (buffer.writableBytes() &gt;= 4) &#123; buffer.writeInt(random.nextInt());&#125; 索引管理可以通过调用 markReaderIndex()、markWriterIndex()、resetWriterIndex() 和 resetReaderIndex() 来标记和重置 ByteBuf 的 readerIndex 和 writerIndex。 也可以通过调用 readerIndex(int) 或者 writerIndex(int) 来将索引移动到指定位置。试图将任何一个索引设置到一个无效的位置都将导致一个 IndexOutOfBoundsException。 可以通过调用 clear()方法来将 readerIndex 和 writerIndex 都设置为 0（不会清除内存中的内容）。 查找操作（Updating）123// 使用 ByteBufProcessor 来寻找\\rByteBuf buffer = ...;int index = buffer.forEachByte(ByteBufProcessor.FIND_CR); 派生缓冲区派生缓冲区为 ByteBuf 提供了以专门的方式来呈现其内容的视图。修改了其中一个，源实例也会被修改（共享）。 12345678910// 对 ByteBuf 进行切片Charset utf8 = Charset.forName(\"UTF-8\");ByteBuf buf = Unpooled.copiedBuffer(\"Netty in Action rocks!\", utf8);ByteBuf sliced = buf.slice(0, 15);// 打印 Netty in ActionSystem.out.println(sliced.toString(utf8));// 更改索引 0 处的字节buf.setByte(0, (byte)'J');// True 因为数据是共享关系assert buf.getByte(0) == sliced.getByte(0); ByteBuf 复制 如果需要一个现有缓冲区的真实副本，请使用 copy() 或者 copy(int, int) 方法。不同于派生缓冲区，由这个调用所返回的 ByteBuf 拥有独立的数据副本 12345678// 复制一个 ByteBufCharset utf8 = Charset.forName(\"UTF-8\");ByteBuf buf = Unpooled.copiedBuffer(\"Netty in Action rocks!\", utf8);ByteBuf copy = buf.copy(0, 15);System.out.println(copy.toString(utf8));buf.setByte(0, (byte) 'J');// True 因为数据是非共享关系assert buf.getByte(0) != copy.getByte(0); 除了修改原始 ByteBuf 的切片或者副本的效果以外，这两种场景是相同的。只要有可能， 使用 slice() 方法来避免复制内存的开销。 读写操作getXxx() 和 setXxx() 操作，从给定的索引开始，并且保持索引不变。 12345678910111213// getXxx() And setXxx()Charset utf8 = Charset.forName(\"UTF-8\");ByteBuf buf = Unpooled.copiedBuffer(\"Netty in Action rocks!\", utf8);// 打印第一个字符 NSystem.out.println((char)buf.getByte(0));int readerIndex = buf.readerIndex();int writerIndex = buf.writerIndex();// 更改索引 0 处的字节buf.setByte(0, (byte)'B');System.out.println((char)buf.getByte(0));// True 不会影响相应的索引assert readerIndex == buf.readerIndex();assert writerIndex == buf.writerIndex(); readXxx() 和 writeXxx() 操作，从给定的索引开始，并且会根据已经访问过的字节数对索 引进行调整。 1234567891011// readXxx() And writeXxx()Charset utf8 = Charset.forName(\"UTF-8\");ByteBuf buf = Unpooled.copiedBuffer(\"Netty in Action rocks!\", utf8);System.out.println((char)buf.readByte());int readerIndex = buf.readerIndex();int writerIndex = buf.writerIndex();// 将字符 ？ 追加到缓存区，writerIndex 改变buf.writeByte((byte)'?');// Trueassert readerIndex == buf.readerIndex();assert writerIndex != buf.writerIndex(); ByteBufHolder 接口如果想要实现一个将其有效负载存储在 ByteBuf 中的消息对象，那么 ByteBufHolder 将是个不错的选择。 ByteBuf 分配常见的几种管理 ByteBuf 实例的不同方式。 按需分配：ByteBufAllocator 接口为了降低分配和释放内存的开销，Netty 通过 interface ByteBufAllocator 实现了（ByteBuf 的）池化，它可以用来分配我们所描述过的任意类型的 ByteBuf 实例。 可以通过 Channel（每个都可以有一个不同的 ByteBufAllocator 实例）或者绑定到 ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。 1234567// 获取一个到 ByteBufAllocator 的引用Channel channel = ...;ByteBufAllocator allocator = channel.alloc();....ChannelHandlerContext ctx = ...;ByteBufAllocator allocator2 = ctx.alloc();... Netty提供了两种ByteBufAllocator的实现：PooledByteBufAllocator 和 UnpooledByteBufAllocator。 Unpooled 缓冲池可能某些情况下，你不需要一个 ByteBufAllocator 的引用。对于这种情况，Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf 实例。 ByteBufUtil 类ByteBufUtil 提供了用于操作 ByteBuf 的静态的辅助方法。 引用计数引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty 在第 4 版中为 ByteBuf 和 ByteBufHolder 引入了引用计数技术，它们都实现了 interface ReferenceCounted。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Netty 传输","slug":"Netty/Netty 入门/Netty 传输","date":"2020-01-22T11:03:21.000Z","updated":"2020-04-19T06:30:56.156Z","comments":true,"path":"2020/01/22/Netty/Netty 入门/Netty 传输/","link":"","permalink":"http://yoursite.com/2020/01/22/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20%E4%BC%A0%E8%BE%93/","excerpt":"流经网络的数据总是具有相同的类型：字节。这些字节是如何流动的主要取决于我们所说的网络传输（一个帮助我们抽象底层数据传输机制的概念）","text":"流经网络的数据总是具有相同的类型：字节。这些字节是如何流动的主要取决于我们所说的网络传输（一个帮助我们抽象底层数据传输机制的概念） 案例研究：JDK VS. Netty原生 JDK123456789101112131415161718192021222324252627282930313233343536// JDK 的阻塞网络编程public class PlainOioServer &#123; public void serve(int port) throws IOException &#123; final ServerSocket socket = new ServerSocket(port); try &#123; for (;;) &#123; final Socket clientSocket = socket.accept(); System.out.println(\"Accepted connection from \" + clientSocket); new Thread( // 创建一个新的线程来处理该连接 new Runnable() &#123; @Override public void run() &#123; OutputStream out; try &#123; out = clientSocket.getOutputStream(); // 将消息写给已连接的客户端 out.write(\"Hi!\\r\\n\".getBytes(Charset.forName(\"UTF-8\"))); out.flush(); clientSocket.close(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; clientSocket.close(); &#125;catch (IOException ex) &#123; // ignore on close &#125; &#125; &#125; &#125;).start(); // 启动线程 &#125; &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 随着应用程序的用户越来越多，阻塞 I/O 并不能很好地伸缩到支撑成千上万地并发连入连接。此时异步 I/O 可以解决这个问题，但异步 I/O 的 API 是完全不同的，因此不得不重写此应用程序。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465// JDK 非阻塞网络处理public class PlainNioServer &#123; public void serve(int port) throws IOException &#123; ServerSocketChannel serverChannel = ServerSocketChannel.open(); serverChannel.configureBlocking(false); ServerSocket ssocket = serverChannel.socket(); InetSocketAddress address = new InetSocketAddress(port); ssocket.bind(address); // 打开 Selector 来处理 Channel Selector selector = Selector.open(); // 将 ServerChannel 注册到 Selector 以便接受连接（报个名） serverChannel.register(selector, SelectionKey.OP_ACCEPT); final ByteBuffer msg = ByteBuffer.wrap(\"Hi!\\r\\n\".getBytes()); for (;;) &#123; try &#123; // 等待 select() 需要处理的新事件，阻塞将一直持续到下一个传入事件 selector.select(); &#125; catch (IOException ex) &#123; ex.printStackTrace(); // handle exception break; &#125; // 获取所有接收事件的标识 SelectionKey() Set&lt;SelectionKey&gt; readyKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; iterator = readyKeys.iterator(); while (iterator.hasNext()) &#123; // 取出标识，以便标识所对应的事件进行业务操作 SelectionKey key = iterator.next(); // 此事件已经取出处理，将其标识符移除 iterator.remove(); try &#123; // 检查事件类型 if (key.isAcceptable()) &#123; ServerSocketChannel server = (ServerSocketChannel)key.channel(); // 接受客户端 SocketChannel client = server.accept(); client.configureBlocking(false); // 将客户端注册到选择器 client.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, msg.duplicate()); System.out.println(\"Accepted connection from \" + client); &#125; // 检查事件类型 if (key.isWritable()) &#123; SocketChannel client = (SocketChannel)key.channel(); ByteBuffer buffer =(ByteBuffer)key.attachment(); while (buffer.hasRemaining()) &#123; // 将数据写到已连接的客户端 if (client.write(buffer) == 0) &#123; break; &#125; &#125; client.close(); &#125; &#125; catch (IOException ex) &#123; key.cancel(); try &#123; key.channel().close(); &#125; catch (IOException cex) &#123; // ignore on close &#125; &#125; &#125; // while &#125; // for &#125; &#125; Netty 框架因为 Netty 为每种传输的实现都暴露了相同的 API，阻塞与非阻塞网络传输的实现都依赖于 interface Channel、 ChannelPipeline 和 ChannelHandler。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 使用 Netty 的网络处理public class NettyOioServer &#123; public void server(int port) throws Exception &#123; final ByteBuf buf = Unpooled.unreleasableBuffer( Unpooled.copiedBuffer(\"Hi!\\r\\n\", Charset.forName(\"UTF-8\")) ); // 阻塞模式 EventLoopGroup group = new OioEventLoopGroup(); // 非阻塞模式 // EventLoopGroup group = new OioEventLoopGroup(); try &#123; ServerBootstrap b = new ServerBootstrap(); b.group(group) // 非阻塞模式 // .channel(NioServerSocketChannel.class) .channel(OioServerSocketChannel.class) .localAddress(new InetSocketAddress(port)) // 每个连接的通道都需要调用此初始化方法 .childHandler( new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast( // 拦截和处理事件 new ChannelInboundHandlerAdapter() &#123; @Override public void channelActive(ChannelHandlerContext ctx)throws Exception &#123; ctx.writeAndFlush(buf.duplicate()) // 监听，以便在消息写完后关闭连接 .addListener(ChannelFutureListener.CLOSE); &#125; &#125; ); &#125; &#125; ); ChannelFuture f = b.bind().sync(); f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); &#125; &#125; &#125; 传输 API传输 API 的核心是 interface Channel，它被用于所有的 I/O 操作 每个 Channel 都将会被分配一个 ChannelPipeline 和 ChannelConfig。ChannelConfig 包含了该 Channel 的所有配置设置，并且支持热更新。 由于 Channel 是独一无二的，为了保证顺序将 Channel 声明为 java.lang. Comparable 的一个子接口。 ChannelPipeline 持有所有将应用于入站和出站数据以及事件的 ChannelHandler 实例，这些 ChannelHandler 实现了应用程序用于处理状态变化以及数据处理的逻辑。你也可以根据需要通过添加或者移除ChannelHandler实例来修改 ChannelPipeline。通过利用Netty的这项能力可以构建出高度灵活的应用程序。 123456789101112131415161718192021// 写出到 ChannelChannel channel = ...;// 创建持有要写数据的 ByteBufByteBuf buf = Unpooled.copiedBuffer(\"your data\", CharsetUtil.UTF_8);// 写数据并且冲刷它ChannelFuture cf = channel.writeAndFlush(buf);// 添加监听器以便在操作完成后接收到通知cf.addListener( new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) &#123; // 操作完成并且没有发生错误 if (future.isSuccess()) &#123; System.out.println(\"Write successful\"); &#125; else &#123; System.err.println(\"Write error\"); future.cause().printStackTrace(); &#125; &#125; &#125;); Netty 的 Channel 实现是线程安全的，因此你可以存储一个到 Channel 的引用，并且每当你需要向远程节点写数据时，都可以使用它，即使当时许多线程都在使用它。 1234567891011121314151617// 从多个线程使用同一个 Channelfinal Channel channel = ...;final ByteBuf buf = Unpooled.copiedBuffer(\"your data\",CharsetUtil.UTF_8).retain();// 创建将数据写到 Channel 的 RunnableRunnable writer = new Runnable() &#123; @Override public void run() &#123; channel.writeAndFlush(buf.duplicate()); &#125;&#125;;// 获取到线程池 Executor 的引用Executor executor = Executors.newCachedThreadPool();// write in one threadexecutor.execute(writer);// write in another threadexecutor.execute(writer);... 内置的传输Netty 内置了一些可开箱即用的传输。因为并不是它们所有的传输都支持每一种协议，所以你必须选择一个和你的应用程序所使用的协议相容的传输。 NIONIO 提供了一个所有 I/O 操作的全异步的实现，利用了 JDK1.4 时便可用的基于选择器的 API。 选择器背后的基本概念是充当一个注册表，在那里你将可以请求在 Channel 的状态发生变化时得到通知。 class java.nio.channels.SelectionKey 定义了一组应用程序正在请求通知的状态变化集。 选择器选择并处理状态的变化 零拷贝（zero-copy）：它使你可以快速高效地将数据从文件系统移动到网络接口，而不需要将其从内核空间复制到用户空间，其在像 FTP 或者 HTTP 这样的协议中可以显著地提升性能。 Epoll用于 Linux 的本地非阻塞传输，Linux JDK NIO API 使用了这些 epoll 调用。 OIONetty 的 OIO 传输实现代表了一种折中：它可以通过常规的传输 API 使用，但是由于它是建立在 java.net 包的阻塞实现之上的，所以它不是异步的。但是，它仍然非常适合于某些用途。 Local 传输用于在同一个 JVM 中运行的客户端和服务器程序之间的异步通信。 Embedded 传输Netty 提供了一种额外的传输，使得你可以将一组 ChannelHandler 作为帮助器类嵌入到其他的 ChannelHandler 内部。通过这种方式，你将可以扩展一个 ChannelHandler 的功能，而又不需要修改其内部代码。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"Netty 组件和设计","slug":"Netty/Netty 入门/Netty 组件和设计","date":"2020-01-22T06:09:03.000Z","updated":"2020-04-19T06:31:16.834Z","comments":true,"path":"2020/01/22/Netty/Netty 入门/Netty 组件和设计/","link":"","permalink":"http://yoursite.com/2020/01/22/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20%E7%BB%84%E4%BB%B6%E5%92%8C%E8%AE%BE%E8%AE%A1/","excerpt":"Channel、EventLoop 和 ChannelFutureChannel、EventLoop 和 ChannelFuture 类合在一起可以被认为是 Netty 的网络抽象代表","text":"Channel、EventLoop 和 ChannelFutureChannel、EventLoop 和 ChannelFuture 类合在一起可以被认为是 Netty 的网络抽象代表 Channel：Socket EventLoop：控制流、多线程处理、并发 ChannelFuture：异步通知 Channel 接口基本的 I/O 操作（bind()、connect()、read()和 write()）依赖于底层网络传输所提供的原语。在基于 Java 的网络编程中，其基本的构造是 class Socket。Netty 的 Channel 接口所提供的 API，大大地降低了直接使用 Socket 类的复杂性。此外，Channel 也是拥有许多预定义的、专门化实现的广泛类层次结构的根。 EvenLoop 接口 一个 EventLoopGroup 包含一个或者多个 EventLoop； 一个 EventLoop 在它的生命周期内只和一个 Thread 绑定； 所有由 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理； 一个 Channel 在它的生命周期内只注册于一个 EventLoop； 一个 EventLoop 可能会被分配给一个或多个 Channel。 在这种设计中，一个给定 Channel 的 I/O 操作都是由相同的 Thread 执行的，实际上消除了对于同步的需要。 channelFuture 接口Netty 中所有的 I/O 操作都是异步的，因为一个操作可能不会立即返回，所以我们需要一种用于在之后的某个时间点确定其结果的方法。为此，Netty 提供了 ChannelFuture 接口，其 addListener() 方法注册了一个 ChannelFutureListener，以便在某个操作完成时（无论是否成功）得到通知。 ChannelHandler 和 ChannelPipeline接下来，让我们更加细致的看一看哪那些管理数据流以及执行应用程序处理逻辑的组件。 ChannelHandler 接口从应用程序开发人员的角度来看，Netty 的主要组件是 ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。这是可行的，因为 ChannelHandler 的方法是由网络事件（其中术语“事件”的使用非常广泛）触发的。事实上，ChannelHandler 可专门用于几乎任何类型的动作，例如将数据从一种格式转换为另外一种格式，或者处理转换过程中所抛出的异常。 你的应用程序的业务逻辑通常驻留在一个或者多个 ChannelInboundHandler 中。 ChannelPipeline 接口ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播入站和出站事件流的 API。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。 ChannelHandler 安装到 ChannelPipeline 中的过程： 一个ChannelInitializer的实现被注册到了ServerBootstrap中； 当 ChannelInitializer.initChannel() 方法被调用时，ChannelInitializer 将在 ChannelPipeline 中安装一组自定义的 ChannelHandler； ChannelInitializer 将它自己从 ChannelPipeline 中移除。 ChannelHandler 是专为支持广泛的用途而设计的，可以将它看作是处理往来 ChannelPipeline 事件（包括数据）的任何代码的通用容器。使得事件流经 ChannelPipeline 是 ChannelHandler 的工作，它们是在应用程序的初始化或者引导阶段被安装的。这些对象接收事件、执行它们所实现的处理逻辑，并将数据传递给链中的下一个 ChannelHandler。它们的执行顺序是由它们被添加的顺序所决定的。实际上，被我们称为 ChannelPipeline 的是这些 ChannelHandler 的编排顺序。 如同上图所示，入站和出站 ChannelHandler 可以被安装到同一个 ChannelPipeline 中。虽然 ChannelInboundHandle 和 ChannelOutboundHandle 都扩展自 ChannelHandler，但是 Netty 能区分 ChannelInboundHandler 实现和 ChannelOutboundHandler 实现，并确保数据只会在具有相同定向类型的两个 ChannelHandler 之间传递。 当 ChannelHandler 被添加到 ChannelPipeline 时，它将会被分配一个 ChannelHandlerContext，其代表了 ChannelHandler 和 ChannelPipeline 之间的绑定。虽然这个对象可以被用于获取底层的 Channel，但是它主要还是被用于写出站数据。 在 Netty 中，有两种发送消息的方式。你可以直接写到 Channel 中，也可以写到和 ChannelHandler 相关联的 ChannelHandlerContext 对象中。前一种方式将会导致消息从 ChannelPipeline 的尾端开始流动，而后者将导致消息从 ChannelPipeline 中的下一个 ChannelHandler 开始流动。 编码器和解码器正如有用来简化 ChannelHandler 的创建的适配器类一样，所有由 Netty 提供的编码器/解码器适配器类都实现 了 ChannelOutboundHandler 或者 ChannelInboundHandler 接口。 通常来说，这些基类的名称将类似于 ByteToMessageDecoder 或 MessageToByteEncoder。对于特殊的类型，你可能会发现类似于 ProtobufEncoder 和 ProtobufDecoder 这样的名称——预置的用来支持 Google 的 Protocol Buffers。 抽象类 SimpleChannelInboundHandler最常见的情况是，你的应用程序会利用一个 ChannelHandler 来接收解码消息，并对该数据应用业务逻辑。要创建一个这样的 ChannelHandler，你只需要扩展基类 SimpleChannelInboundHandler&lt;T&gt;，其中 T 是你要处理的消息的 Java 类型 。在这个 ChannelHandler 中，你将需要重写基类的一个或者多个方法，并且获取一个到 ChannelHandlerContext 的引用， 这个引用将作为输入参数传递给 ChannelHandler 的所有方法。 引导Netty 的引导类为应用程序的网络层配置提供了容器，这涉及将一个进程绑定到某个指定的端口，或者将一个进程连接到另一个运行在某个指定主机的指定端口上的进程。 “服务器”和“客户端”实际上表示了不同的网络行为；换句话说，是监听传入的连接还是建立到一个或者多个进程的连接。 因此，有两种类型的引导：一种用于客户端（简单地称为 Bootstrap），而另一种（ServerBootstrap）用于服务器。无论你的应用程序使用哪种协议或者处理哪种类型的数据，唯一决定它使用哪种引导类的是它是作为一个客户端还是作为一个服务器。 Bootstrap 将连接远程主机和端口，数量通常为一个。 ServerBootstrap 将绑定到一个端口，因为服务器必须要监听连接，数量通常为两个。 第一组将只包含一个 ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。 第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。 与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建 Channel 的 EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel 分配一个 EventLoop。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"一个简单的 Netty 应用程序","slug":"Netty/Netty 入门/Netty 简单应用程序","date":"2020-01-21T14:46:53.000Z","updated":"2020-02-17T10:51:25.668Z","comments":true,"path":"2020/01/21/Netty/Netty 入门/Netty 简单应用程序/","link":"","permalink":"http://yoursite.com/2020/01/21/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20%E7%AE%80%E5%8D%95%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/","excerpt":"应用程序 EchoEcho 客户端和服务器之间的交互是非常简单的；在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。这一简单的功能充分体现了客户端/服务器系统中典型的请求-响应交互模式。","text":"应用程序 EchoEcho 客户端和服务器之间的交互是非常简单的；在客户端建立一个连接之后，它会向服务器发送一个或多个消息，反过来，服务器又会将每个消息回送给客户端。这一简单的功能充分体现了客户端/服务器系统中典型的请求-响应交互模式。 编写 Echo 服务器所有的 Netty 服务器都需要以下两部分 至少一个 ChannelHandler：该组件实现了服务器对从客户端接收的数据的处理，即它的业务逻辑。 引导：这是配置服务器的启动代码。至少，它会将服务器绑定到它要监听连接请求的端口上。 ChannelHandler 和业务逻辑因为你的 Echo 服务器会响应传入的消息，所以它需要实现 ChannelInboundHandler 接口，用来定义响应入站事件的方法。这个简单的应用程序只需要用到少量的这些方法，所以继承 ChannelInboundHandlerAdapter 类也就足够了，它提供了 ChannelInboundHandler 的默认实现。 123456789101112131415161718192021222324// EchoServerHandler 类@Sharable // 标示一个 ChannelHandler 可以被多个 Channel 安全地共享public class EchoServerHandler extends ChannelInboundHandlerAdapter &#123; // 对于每个传入的消息都要调用 @Override public void channelRead(ChannelHandlerContext ctx, Object msg) &#123; ByteBuf in = (ByteBuf) msg; System.out.println(\"Server received: \" + in.toString(CharsetUtil.UTF_8)); // 将接收到的数据写给发送者 ctx.write(in); &#125; // 通知 ChannelInboundHandler 最后一次对 channelRead() 的调用是当前批量读取中的最后一条消息 @Override public void channelReadComplete(ChannelHandlerContext ctx) &#123; // 将消息冲刷到远程节点并且关闭该 Channel ctx.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(ChannelFutureListener.CLOSE); &#125; // 在读取操作期间，有异常抛出时会调用 @Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; ChannelHandler 的一些关键点： 针对不同类型的事件来调用 ChannelHandler； 应用程序通过实现或者扩展 ChannelHandler 来挂钩到事件的生命周期，并且提供自定义的应用程序逻辑； 在架构上，ChannelHandler 有助于保持业务逻辑与网络处理代码的分离。这简化了开发过程，因为代码必须不断地演化以响应不断变化的需求。 引导服务器绑定到服务器将在其上监听并接受传入连接请求的端口； 配置 Channel，以将有关的入站消息通知给 EchoServerHandler 实例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// EchoServer 类public class EchoServer &#123; private final int port; public EchoServer(int port) &#123; this.port = port; &#125; public static void main(String[] args) throws Exception &#123; if (args.length != 1) &#123; System.err.println(\"Usage: \" + EchoServer.class.getSimpleName() + \" &lt;port&gt;\"); &#125; int port = Integer.parseInt(args[0]); new EchoServer(port).start(); &#125; public void start() throws Exception &#123; final EchoServerHandler serverHandler = new EchoServerHandler(); // 创建一个循环组 EventLoopGroup EventLoopGroup group = new NioEventLoopGroup(); try &#123; // 创建一个 ServerBootstrap 的实例以引导和绑定服务器 ServerBootstrap b = new ServerBootstrap(); b.group(group) .channel(NioServerSocketChannel.class) // 指定服务器绑定的本地的 InetSocketAddress .localAddress(new InetSocketAddress(port)) .childHandler( // 接受一个新连接则一个新的子 Channel 将会被创建 new ChannelInitializer&lt;SocketChannel&gt;()&#123; // 使用一个 EchoServerHandler 的实例初始化每一个新的 Channel @Override public void initChannel(SocketChannel ch)throws Exception &#123; ch.pipeline().addLast(serverHandler); &#125; &#125; ); // 异步地绑定服务器，sync() 方法的调用将导致当前 Thread 阻塞，一直到绑定操作完成为止 ChannelFuture f = b.bind().sync(); // 异步地关闭服务器 f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); &#125; &#125; &#125; 编写 Echo 客户端 Echo 客户端将会： 连接到服务器； 发送一个或者多个消息； 对于每个消息，等待并接受从服务器发送回的相同消息 关闭连接。 通过 ChannelHandler 实现客户端逻辑如同服务器，客户端将拥有一个用来处理数据的 ChannelInboundHandler。 123456789101112131415161718192021// 客户端的 ChannelHandler// ByteBuf 为 Nutty 的字节容器@Sharablepublic class EchoClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123; // 在到服务器的连接已经建立之后将被调用 @Override public void channelActive(ChannelHandlerContext ctx) &#123; ctx.writeAndFlush(Unpooled.copiedBuffer(\"Netty rocks!\",CharsetUtil.UTF_8)); &#125; // 当从服务器接收到一条消息时被调用 @Override public void channelRead0(ChannelHandlerContext ctx, ByteBuf in) &#123; System.out.println(\"Client received: \" + in.toString(CharsetUtil.UTF_8)); &#125; // 在处理过程中引发异常时被调用 @Override public void exceptionCaught(ChannelHandlerContext ctx,Throwable cause) &#123; cause.printStackTrace(); ctx.close(); &#125;&#125; SimpleChannelInboundHandler 与 ChannelInboundHandler 你可能会想：为什么我们在客户端使用的是 SimpleChannelInboundHandler，而不是在 EchoServerHandler 中所使用的 ChannelInboundHandlerAdapter 呢？这和两个因素的相互作用有关：业务逻辑如何处理消息以及 Netty 如何管理资源。 在客户端，当 channelRead0() 方法完成时，你已经有了传入消息，并且已经处理完它了。当该方法返回时，SimpleChannelInboundHandler 负责释放指向保存该消息的 ByteBuf 的内存引用。 在 EchoServerHandler 中，你仍然需要将传入消息回送给发送者，而 write()操作是异步的，直到 channelRead() 方法返回后可能仍然没有完成。为此，EchoServerHandler 扩展了 ChannelInboundHandlerAdapter，其在这个时间点上不会释放消息。 消息在 EchoServerHandler 的 channelReadComplete() 方法中，当 writeAndFlush() 方法被调用时被释放 引导客户端引导客户端类似于引导服务器，不同的是，客户端是使用主机和端口参数来连接远程地址，也就是这里的 Echo 服务器的地址，而不是绑定到一个一直被监听的端口。 12345678910111213141516171819202122232425262728293031323334353637383940// 客户端的主类public class EchoClient &#123; private final String host; private final int port; public EchoClient(String host, int port) &#123; this.host = host; this.port = port; &#125; public void start() throws Exception &#123; EventLoopGroup group = new NioEventLoopGroup(); try &#123; Bootstrap b = new Bootstrap(); b.group(group) .channel(NioSocketChannel.class) .remoteAddress(new InetSocketAddress(host, port)) .handler( new ChannelInitializer&lt;SocketChannel&gt;() &#123; @Override public void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new EchoClientHandler()); &#125; &#125; ); ChannelFuture f = b.connect().sync(); f.channel().closeFuture().sync(); &#125; finally &#123; group.shutdownGracefully().sync(); &#125; &#125; public static void main(String[] args) throws Exception &#123; if (args.length != 2) &#123; System.err.println(\"Usage: \" + EchoClient.class.getSimpleName() + \" &lt;host&gt; &lt;port&gt;\"); return; &#125; String host = args[0]; int port = Integer.parseInt(args[1]); new EchoClient(host, port).start(); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]},{"title":"环境变量","slug":"环境变量","date":"2020-01-21T14:35:41.000Z","updated":"2020-02-14T13:31:29.028Z","comments":true,"path":"2020/01/21/环境变量/","link":"","permalink":"http://yoursite.com/2020/01/21/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/","excerpt":"Java 环境设置JAVA_HOME：[ JDK 安装目录 ]","text":"Java 环境设置JAVA_HOME：[ JDK 安装目录 ] CLASSPATH：…;%JAVA_HOME%\\bin Maven 环境设置M2_HOME：[ 安装目录 ]/apache-maven-x.x.x CLASSPATH：…;%M2_HOME%\\bin","categories":[{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"}],"tags":[{"name":"Path","slug":"Path","permalink":"http://yoursite.com/tags/Path/"}]},{"title":"Netty 入门简介","slug":"Netty/Netty 入门/Netty 入门简介","date":"2020-01-21T01:37:11.000Z","updated":"2020-04-19T06:31:06.211Z","comments":true,"path":"2020/01/21/Netty/Netty 入门/Netty 入门简介/","link":"","permalink":"http://yoursite.com/2020/01/21/Netty/Netty%20%E5%85%A5%E9%97%A8/Netty%20%E5%85%A5%E9%97%A8%E7%AE%80%E4%BB%8B/","excerpt":"Java IO无论是 C 语言，还是 Java，在进行网络编程的开发时都较为不友好。早期的 Java API（ java.net ）只支持由本地系统套接字库提供所谓的阻塞函数。","text":"Java IO无论是 C 语言，还是 Java，在进行网络编程的开发时都较为不友好。早期的 Java API（ java.net ）只支持由本地系统套接字库提供所谓的阻塞函数。 12345678910111213141516171819202122// 阻塞 I/O 示例I/O// 创建一个 ServerSocket 用以监听端口上的连接请求ServerSocket serverSocket = new ServerSocket(portNumber);// accept() 方法调用将被阻塞，直到一个连接建立Socket clientSocket = serverSocket.accept();BufferReader in = new BufferReader( new InputStreamReader( clientSocket.getInputStream() ));// PrintWriter(OutputStream out, boolean autoFlush) ???PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true);String request, response;while ((request = in.readLine()) != null) &#123; if (\"Done\".equals(request)) &#123; break; // 客户端发送了 Done 则退出处理循环 &#125; // You can use ProcessRequest to handle your request response = processRequest(request); out.println(response);&#125; 这段代码片段将只能同时处理一个连接，要管理多个并发客户端，需要为每个新的客户端 Socket 创建一个新的 Thread。 使用阻塞 I/O处理多个连接： Java NIOclass java.nio.channels.Selector 是 Java 的非阻塞 I/O 实现的关键。它使用了事件通知 API 以确定在一组非阻塞套接字中有哪些已经就绪能够进 行 I/O 相关的操作。因为可以在任何的时间检查任意 的读操作或者写操作的完成状态。 使用 Selector 的非阻塞 I/O Netty 简介在网络编程领域，Netty 是 Java 的卓越框架。它驾驭了 Java 高 API 的能力，并将其隐藏在一个易于使用的 API 之后。Netty 使你可以专注于自己真正感兴趣的：你的应用程序的独一无二的价值。 一个既是异步的又是事件驱动的系统会表现出一种特殊的、对我们来说极具价值的行为：它可以以任意的顺序响应在任意的时间点产生的事件。 完全异步的 I/O：非阻塞网络调用使得我们可以不必等待一个操作的完成。异步方法会立即返回，并且在它完成时，会直接或者在稍后的某个时间点通知用户。 选择器使得我们能够通过较少的线程便可监视许多连接上的事件。 Netty 的核心组件ChannelChannel 时 Java NIO 的一个基本构造。 它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执 行一个或者多个不同的I/O操作的程序组件）的开放连接，如读操作和写操作。 在一定程度上可以把 Channel 看作是传入（入站）或者传出（出站）数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。 回调Netty 在内部使用了回调来处理事件；当一个回调被触发时，相关的事件可以被一个 interfaceChannelHandler 的实现处理 12345678910// 被回调触发的 ChannelHandlerpublic class ConnectHandler extends ChannelInboundHandlerAdapter &#123; @Override // 当一个新的连接被建立完成时，此方法将会被调用 public void channelActive(ChannelHandlerContext ctx) throws Exception &#123; System.out.println( \"Client \" + ctx.channel().remoteAddress() + \" connected\" ); &#125;&#125; FutureFuture 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。 JDK 预置了 interface java.util.concurrent.Future，但是其所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以 Netty 提供了它自己的实现：ChannelFuture，用于在执行异步操作的时候使用。 ChannelFuture提供了几种额外的方法，这些方法使得我们能够注册一个或者多个 ChannelFutureListener 实例。由 ChannelFutureListener 提供的通知机制消除了手动检查对应的操作是否完成的必要。 监听器的回调方法 operationComplete()：将会在对应的操作完成时被调用。 监听器可以判断操作是成功地完成了还是出错了（ 检索产生的 Throwable ）。 每个 Netty 的出站 I/O 操作都将返回一个 ChannelFuture；也就是说，它们都不会阻塞。正如我们前面所提到过的一样，Netty 完全是异步和事件驱动的。 123456789101112131415161718192021222324252627// 异步的建立连接Channel channel = ...;// Does not blockChannelFuture future = channel.connect( // 异步地连接到远程节点 new InetSocketAddress(\"192.168.0.1\", 25));// 注册一个 ChannelFutureListener 以便在操作完成时获得通知future.addListener( new ChannelFutureListener() &#123; @Override public void operationComplete(ChannelFuture future) &#123; // 检查操作的状态 if (future.isSuccess())&#123; ByteBuf buffer = Unpooled.copiedBuffer( \"Hello\",Charset.defaultCharset() ); // 将数据异步发送到远程节点 ChannelFuture wf = future.channel().writeAndFlush(buffer); .... &#125; else &#123; Throwable cause = future.cause(); cause.printStackTrace(); &#125; &#125; &#125;); 回调和 Future 是相互补充的机制；它们相互结合，构成了 Netty 本身的关键构件块之一。 事件和 ChannelHandlerNetty 是一个网络编程框架，所以事件是按照它们与入站或出站数据流的相关性进行分类的。 可能由入站数据或者相关的状态更改而触发的事件： 连接已被激活或者连接失活； 数据读取； 用户事件； 错误事件。 出站事件是未来将会触发的某个动作的操作结果，这些动作包括： 打开或者关闭到远程节点的连接； 将数据写到或者冲刷到套接字。 每个事件都可以被分发给 ChannelHandler 类中的某个用户实现的方法，后面会对此类进行更进一步的说明，目前你可以每个 ChannelHandler 的实例都类似于一种为了响应特定事件而被执行的回调。 流经 ChannelHandler 链的入站事件和出站事件 各组件的整合 Future、回调和 ChannelHandler Netty 的异步编程模型是建立在 Future 和回调的概念之上的，而将事件派发到 ChannelHandler 的方法则发生在更深的层次上。结合在一起，这些元素就提供了一个处理环境，使你的应用程序逻 辑可以独立于任何网络操作相关的顾虑而独立地演变。这也是 Netty 的设计方式的一个关键目标。 拦截操作以及高速地转换入站数据和出站数据，都只需要你提供回调或者利用操作所返回的 Future。这使得链接操作变得既简单又高效，并且促进了可重用的通用代码的编写。 选择器、事件和 EventLoop Netty 通过触发事件将 Selector 从应用程序中抽象出来，消除了所有本来将需要手动编写 的派发代码。在内部，将会为每个 Channel 分配一个 EventLoop，用以处理所有事件。 EventLoop 本身只由一个线程驱动，其处理了一个 Channel 的所有 I/O 事件，并且在该 EventLoop 的整个生命周期内都不会改变（ 无需顾虑同步 ）。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"}]}],"categories":[{"name":"Distributed","slug":"Distributed","permalink":"http://yoursite.com/categories/Distributed/"},{"name":"Demo","slug":"Demo","permalink":"http://yoursite.com/categories/Demo/"},{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/categories/Tool/"},{"name":"ORM","slug":"ORM","permalink":"http://yoursite.com/categories/ORM/"},{"name":"FrontEnd","slug":"FrontEnd","permalink":"http://yoursite.com/categories/FrontEnd/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"},{"name":"Software","slug":"Software","permalink":"http://yoursite.com/categories/Software/"},{"name":"Welab","slug":"Welab","permalink":"http://yoursite.com/categories/Welab/"},{"name":"English","slug":"English","permalink":"http://yoursite.com/categories/English/"},{"name":"Project","slug":"Project","permalink":"http://yoursite.com/categories/Project/"},{"name":"Life","slug":"Life","permalink":"http://yoursite.com/categories/Life/"}],"tags":[{"name":"Dubbo","slug":"Dubbo","permalink":"http://yoursite.com/tags/Dubbo/"},{"name":"Redis","slug":"Redis","permalink":"http://yoursite.com/tags/Redis/"},{"name":"H2","slug":"H2","permalink":"http://yoursite.com/tags/H2/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Spring Boot","slug":"Spring-Boot","permalink":"http://yoursite.com/tags/Spring-Boot/"},{"name":"Aysnc","slug":"Aysnc","permalink":"http://yoursite.com/tags/Aysnc/"},{"name":"Scheduled","slug":"Scheduled","permalink":"http://yoursite.com/tags/Scheduled/"},{"name":"Email","slug":"Email","permalink":"http://yoursite.com/tags/Email/"},{"name":"Security","slug":"Security","permalink":"http://yoursite.com/tags/Security/"},{"name":"Shiro","slug":"Shiro","permalink":"http://yoursite.com/tags/Shiro/"},{"name":"ElasticSearch","slug":"ElasticSearch","permalink":"http://yoursite.com/tags/ElasticSearch/"},{"name":"MQ","slug":"MQ","permalink":"http://yoursite.com/tags/MQ/"},{"name":"Springboot","slug":"Springboot","permalink":"http://yoursite.com/tags/Springboot/"},{"name":"Cache","slug":"Cache","permalink":"http://yoursite.com/tags/Cache/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://yoursite.com/tags/MyBatis/"},{"name":"High Concurrency","slug":"High-Concurrency","permalink":"http://yoursite.com/tags/High-Concurrency/"},{"name":"Design Patterns","slug":"Design-Patterns","permalink":"http://yoursite.com/tags/Design-Patterns/"},{"name":"Crawler","slug":"Crawler","permalink":"http://yoursite.com/tags/Crawler/"},{"name":"Base","slug":"Base","permalink":"http://yoursite.com/tags/Base/"},{"name":"Tool","slug":"Tool","permalink":"http://yoursite.com/tags/Tool/"},{"name":"Project","slug":"Project","permalink":"http://yoursite.com/tags/Project/"},{"name":"CET6","slug":"CET6","permalink":"http://yoursite.com/tags/CET6/"},{"name":"JPA","slug":"JPA","permalink":"http://yoursite.com/tags/JPA/"},{"name":"Druid","slug":"Druid","permalink":"http://yoursite.com/tags/Druid/"},{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"},{"name":"Docker","slug":"Docker","permalink":"http://yoursite.com/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Web","slug":"Web","permalink":"http://yoursite.com/tags/Web/"},{"name":"Log","slug":"Log","permalink":"http://yoursite.com/tags/Log/"},{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"},{"name":"Chatroom","slug":"Chatroom","permalink":"http://yoursite.com/tags/Chatroom/"},{"name":"Servlet","slug":"Servlet","permalink":"http://yoursite.com/tags/Servlet/"},{"name":"Netty Websocket","slug":"Netty-Websocket","permalink":"http://yoursite.com/tags/Netty-Websocket/"},{"name":"Spring MVC","slug":"Spring-MVC","permalink":"http://yoursite.com/tags/Spring-MVC/"},{"name":"Friends","slug":"Friends","permalink":"http://yoursite.com/tags/Friends/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"},{"name":"Notes","slug":"Notes","permalink":"http://yoursite.com/tags/Notes/"},{"name":"Env","slug":"Env","permalink":"http://yoursite.com/tags/Env/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"MessyCode","slug":"MessyCode","permalink":"http://yoursite.com/tags/MessyCode/"},{"name":"Maven","slug":"Maven","permalink":"http://yoursite.com/tags/Maven/"},{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"Github","slug":"Github","permalink":"http://yoursite.com/tags/Github/"},{"name":"Path","slug":"Path","permalink":"http://yoursite.com/tags/Path/"}]}